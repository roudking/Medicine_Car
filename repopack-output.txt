This file is a merged representation of the entire codebase, combining all repository files into a single document.
Generated by Repopack on: 2025-07-19T13:31:02.816Z

================================================================
File Summary
================================================================

Purpose:
--------
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.

File Format:
------------
The content is organized as follows:
1. This summary section
2. Repository information
3. Repository structure
4. Multiple file entries, each consisting of:
  a. A separator line (================)
  b. The file path (File: path/to/file)
  c. Another separator line
  d. The full contents of the file
  e. A blank line

Usage Guidelines:
-----------------
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.

Notes:
------
- Some files may have been excluded based on .gitignore rules and Repopack's
  configuration.
- Binary files are not included in this packed representation. Please refer to
  the Repository Structure section for a complete list of file paths, including
  binary files.

Additional Info:
----------------

For more information about Repopack, visit: https://github.com/yamadashy/repopack

================================================================
Repository Structure
================================================================
.ccsproject
.clangd
.cproject
.gitignore
.project
.settings/org.eclipse.cdt.codan.core.prefs
.settings/org.eclipse.core.resources.prefs
Beep/Beep_config.c
Beep/Beep_config.h
Beep/Beep_gpio.c
Beep/Beep_gpio.h
Beep/Beep.c
Beep/Beep.h
Driver/Driver_config.c
Driver/Driver_config.h
Driver/Driver_Encoder.c
Driver/Driver_Encoder.h
Driver/Driver_pwm.c
Driver/Driver_pwm.h
Driver/Driver.c
Driver/Driver.h
Driver/pid.c
Driver/pid.h
empty.c
empty.syscfg
HWT101/hwt101_uart.c
HWT101/hwt101_uart.h
HWT101/my_HWT101.c
HWT101/my_HWT101.h
HWT101/REG.h
HWT101/wit_c_sdk.c
HWT101/wit_c_sdk.h
json指令集.txt
K210/K210_uart.c
K210/K210_uart.h
K210/K210.c
K210/K210.h
K230/K230_uart.c
K230/K230_uart.h
K230/K230.c
K230/K230.h
Key/Key_config.c
Key/Key_config.h
Key/Key_gpio.c
Key/Key_gpio.h
Key/Key.c
Key/Key.h
Laser/Laser_config.c
Laser/Laser_config.h
Laser/Laser_gpio.c
Laser/Laser_gpio.h
Laser/Laser.c
Laser/Laser.h
Mask/Car.c
Mask/Car.h
Mask/Mask_perform.c
Mask/Mask_perform.h
Mask/Mask.c
Mask/Mask.h
Raspberry_Pi/cJSON.c
Raspberry_Pi/cJSON.h
Raspberry_Pi/Raspberry_Pi.c
Raspberry_Pi/Raspberry_Pi.h
Raspberry_Pi/Raspberry_uart.c
Raspberry_Pi/Raspberry_uart.h
README.html
README.md
Servo/Servo_config.c
Servo/Servo_config.h
Servo/Servo_pwm.c
Servo/Servo_pwm.h
Servo/Servo.c
Servo/Servo.h
System/gpio_encoder.c
System/gpio_encoder.h
System/my_delay.c
System/my_delay.h
System/my_gpio.c
System/my_gpio.h
System/pwm.c
System/pwm.h
System/serial.c
System/serial.h
System/tim_it.c
System/tim_it.h
targetConfigs/MSPM0G3507.ccxml
targetConfigs/readme.txt

================================================================
Repository Files
================================================================

================
File: .ccsproject
================
<?xml version="1.0" encoding="UTF-8" ?>
<?ccsproject version="1.0"?>
<projectOptions>
	<ccsVariant value="50:Theia-based"/>
	<ccsVersion value="51.5.0"/>
	<deviceFamily value="TMS470"/>
	<connection value="common/targetdb/connections/TIXDS110_Connection.xml"/>
	<createSlaveProjects value=""/>
	<ignoreDefaultDeviceSettings value="true"/>
	<ignoreDefaultCCSSettings value="true"/>
	<templateProperties value="id=empty_LP_MSPM0G3507_nortos_ticlang.projectspec.empty_LP_MSPM0G3507_nortos_ticlang,buildProfile=release,isHybrid=true"/>
	<activeTargetConfiguration value="targetConfigs/MSPM0G3507.ccxml"/>
	<isTargetConfigurationManual value="false"/>
	<sourceLookupPath value="${COM_TI_MSPM0_SDK_INSTALL_DIR}/source/ti/driverlib"/>
	<origin value="C:\MySoftware\CCSTheia\mspm0_sdk_2_04_00_06\examples\nortos\LP_MSPM0G3507\driverlib\empty\ticlang\empty_LP_MSPM0G3507_nortos_ticlang.projectspec"/>
	<filesToOpen value="README.md,empty.syscfg"/>
</projectOptions>

================
File: .clangd
================
# This is an auto-generated file - do not add it to source-control

CompileFlags:
   CompilationDatabase: Debug/.clangd

Diagnostics:
   Suppress: '*'

InlayHints:
   Enabled: No

================
File: .cproject
================
<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<?fileVersion 4.0.0?><cproject storage_type_id="org.eclipse.cdt.core.XmlProjectDescriptionStorage">
    <storageModule moduleId="org.eclipse.cdt.core.settings">
        <cconfiguration id="com.ti.ccstudio.buildDefinitions.TMS470.Debug.123892182">
            <storageModule buildSystemId="org.eclipse.cdt.managedbuilder.core.configurationDataProvider" id="com.ti.ccstudio.buildDefinitions.TMS470.Debug.123892182" moduleId="org.eclipse.cdt.core.settings" name="Debug">
                <externalSettings/>
                <extensions>
                    <extension id="org.eclipse.cdt.core.GmakeErrorParser" point="com.ti.ccs.project.ErrorParser"/>
                    <extension id="org.eclipse.cdt.core.GASErrorParser" point="com.ti.ccs.project.ErrorParser"/>
                    <extension id="com.ti.ccs.errorparser.SysConfigErrorParser" point="com.ti.ccs.project.ErrorParser"/>
                    <extension id="org.eclipse.cdt.core.GCCErrorParser" point="com.ti.ccs.project.ErrorParser"/>
                    <extension id="com.ti.ccs.errorparser.CompilerErrorParser_TI" point="com.ti.ccs.project.ErrorParser"/>
                </extensions>
            </storageModule>
            <storageModule moduleId="cdtBuildSystem" version="4.0.0">
                <configuration artifactExtension="out" artifactName="${ProjName}" buildProperties="" cleanCommand="${CG_CLEAN_CMD}" description="" id="com.ti.ccstudio.buildDefinitions.TMS470.Debug.123892182" name="Debug" parent="com.ti.ccstudio.buildDefinitions.TMS470.Debug">
                    <folderInfo id="com.ti.ccstudio.buildDefinitions.TMS470.Debug.123892182." name="/" resourcePath="">
                        <toolChain id="com.ti.ccstudio.buildDefinitions.TMS470_TICLANG_4.0.exe.DebugToolchain.1863998414" name="TI Build Tools" superClass="com.ti.ccstudio.buildDefinitions.TMS470_TICLANG_4.0.exe.DebugToolchain" targetTool="com.ti.ccstudio.buildDefinitions.TMS470_TICLANG_4.0.exe.linkerDebug.533668538">
                            <option id="com.ti.ccstudio.buildDefinitions.core.OPT_TAGS.1499347712" superClass="com.ti.ccstudio.buildDefinitions.core.OPT_TAGS" valueType="stringList">
                                <listOptionValue value="DEVICE_CONFIGURATION_ID=Cortex M.MSPM0G3507"/>
                                <listOptionValue value="DEVICE_CORE_ID="/>
                                <listOptionValue value="DEVICE_ENDIANNESS=little"/>
                                <listOptionValue value="OUTPUT_FORMAT=ELF"/>
                                <listOptionValue value="CCS_MBS_VERSION=51.0.0"/>
                                <listOptionValue value="RUNTIME_SUPPORT_LIBRARY="/>
                                <listOptionValue value="OUTPUT_TYPE=executable"/>
                                <listOptionValue value="PRODUCTS=MSPM0-SDK:2.4.0.06;sysconfig:1.22.0;"/>
                                <listOptionValue value="PRODUCT_MACRO_IMPORTS={&quot;MSPM0-SDK&quot;:[&quot;${COM_TI_MSPM0_SDK_INCLUDE_PATH}&quot;,&quot;${COM_TI_MSPM0_SDK_LIBRARY_PATH}&quot;,&quot;${COM_TI_MSPM0_SDK_LIBRARIES}&quot;,&quot;${COM_TI_MSPM0_SDK_SYMBOLS}&quot;,&quot;${COM_TI_MSPM0_SDK_SYSCONFIG_MANIFEST}&quot;],&quot;sysconfig&quot;:[&quot;${SYSCONFIG_TOOL_INCLUDE_PATH}&quot;,&quot;${SYSCONFIG_TOOL_LIBRARY_PATH}&quot;,&quot;${SYSCONFIG_TOOL_LIBRARIES}&quot;,&quot;${SYSCONFIG_TOOL_SYMBOLS}&quot;,&quot;${SYSCONFIG_TOOL_SYSCONFIG_MANIFEST}&quot;]}"/>
                            </option>
                            <option id="com.ti.ccstudio.buildDefinitions.core.OPT_CODEGEN_VERSION.362977098" superClass="com.ti.ccstudio.buildDefinitions.core.OPT_CODEGEN_VERSION" value="TICLANG_4.0.0.LTS" valueType="string"/>
                            <targetPlatform id="com.ti.ccstudio.buildDefinitions.TMS470_TICLANG_4.0.exe.targetPlatformDebug.7582084" name="Platform" superClass="com.ti.ccstudio.buildDefinitions.TMS470_TICLANG_4.0.exe.targetPlatformDebug"/>
                            <builder buildPath="${BuildDirectory}" id="com.ti.ccstudio.buildDefinitions.TMS470_TICLANG_4.0.exe.builderDebug.598089142" keepEnvironmentInBuildfile="false" name="GNU Make" parallelBuildOn="true" parallelizationNumber="optimal" superClass="com.ti.ccstudio.buildDefinitions.TMS470_TICLANG_4.0.exe.builderDebug"/>
                            <tool id="com.ti.ccstudio.buildDefinitions.TMS470_TICLANG_4.0.exe.compilerDebug.484885024" name="Arm Compiler" superClass="com.ti.ccstudio.buildDefinitions.TMS470_TICLANG_4.0.exe.compilerDebug">
                                <option id="com.ti.ccstudio.buildDefinitions.TMS470_TICLANG_4.0.compilerID.GENERATE_DWARF_DEBUG.938274518" superClass="com.ti.ccstudio.buildDefinitions.TMS470_TICLANG_4.0.compilerID.GENERATE_DWARF_DEBUG" value="com.ti.ccstudio.buildDefinitions.TMS470_TICLANG_4.0.compilerID.GENERATE_DWARF_DEBUG.GDWARF_3" valueType="enumerated"/>
                                <option id="com.ti.ccstudio.buildDefinitions.TMS470_TICLANG_4.0.compilerID.ENDIAN_NESS__BIG_LITTLE.1216127289" superClass="com.ti.ccstudio.buildDefinitions.TMS470_TICLANG_4.0.compilerID.ENDIAN_NESS__BIG_LITTLE" value="com.ti.ccstudio.buildDefinitions.TMS470_TICLANG_4.0.compilerID.ENDIAN_NESS__BIG_LITTLE.MLITTLE_ENDIAN" valueType="enumerated"/>
                                <option id="com.ti.ccstudio.buildDefinitions.TMS470_TICLANG_4.0.compilerID.INCLUDE_PATH.536092389" superClass="com.ti.ccstudio.buildDefinitions.TMS470_TICLANG_4.0.compilerID.INCLUDE_PATH" valueType="includePath">
                                    <listOptionValue value="${COM_TI_MSPM0_SDK_INCLUDE_PATH}"/>
                                    <listOptionValue value="${SYSCONFIG_TOOL_INCLUDE_PATH}"/>
                                    <listOptionValue value="${PROJECT_ROOT}"/>
                                    <listOptionValue value="${PROJECT_ROOT}/K210"/>
                                    <listOptionValue value="${PROJECT_ROOT}/K230"/>
                                    <listOptionValue value="${PROJECT_ROOT}/Key"/>
                                    <listOptionValue value="${PROJECT_ROOT}/HWT101"/>
                                    <listOptionValue value="${PROJECT_ROOT}/Raspberry_Pi"/>
                                    <listOptionValue value="${PROJECT_ROOT}/Servo"/>
                                    <listOptionValue value="${PROJECT_ROOT}/Laser"/>
                                    <listOptionValue value="${PROJECT_ROOT}/Mask"/>
                                    <listOptionValue value="${PROJECT_ROOT}/Beep"/>
                                    <listOptionValue value="${PROJECT_ROOT}/Driver"/>
                                    <listOptionValue value="${PROJECT_ROOT}/System"/>
                                    <listOptionValue value="${PROJECT_ROOT}/${ConfigName}"/>
                                    <listOptionValue value="${COM_TI_MSPM0_SDK_INSTALL_DIR}/source/third_party/CMSIS/Core/Include"/>
                                    <listOptionValue value="${COM_TI_MSPM0_SDK_INSTALL_DIR}/source"/>
                                </option>
                                <option id="com.ti.ccstudio.buildDefinitions.TMS470_TICLANG_4.0.compilerID.DEFINE.1004908385" superClass="com.ti.ccstudio.buildDefinitions.TMS470_TICLANG_4.0.compilerID.DEFINE" valueType="definedSymbols">
                                    <listOptionValue value="${COM_TI_MSPM0_SDK_SYMBOLS}"/>
                                    <listOptionValue value="${SYSCONFIG_TOOL_SYMBOLS}"/>
                                </option>
                                <option id="com.ti.ccstudio.buildDefinitions.TMS470_TICLANG_4.0.compilerID.OPT_LEVEL.1407127920" superClass="com.ti.ccstudio.buildDefinitions.TMS470_TICLANG_4.0.compilerID.OPT_LEVEL" value="com.ti.ccstudio.buildDefinitions.TMS470_TICLANG_4.0.compilerID.OPT_LEVEL.0" valueType="enumerated"/>
                                <option id="com.ti.ccstudio.buildDefinitions.TMS470_TICLANG_4.0.compilerID.CMD_FILE.526152938" superClass="com.ti.ccstudio.buildDefinitions.TMS470_TICLANG_4.0.compilerID.CMD_FILE" valueType="stringList">
                                    <listOptionValue value="device.opt"/>
                                </option>
                                <option id="com.ti.ccstudio.buildDefinitions.TMS470_TICLANG_4.0.compilerID.MCPU.1334473327" superClass="com.ti.ccstudio.buildDefinitions.TMS470_TICLANG_4.0.compilerID.MCPU" value="com.ti.ccstudio.buildDefinitions.TMS470_TICLANG_4.0.compilerID.MCPU.cortex-m0plus" valueType="enumerated"/>
                                <option id="com.ti.ccstudio.buildDefinitions.TMS470_TICLANG_4.0.compilerID.MARCH.198365115" superClass="com.ti.ccstudio.buildDefinitions.TMS470_TICLANG_4.0.compilerID.MARCH" value="com.ti.ccstudio.buildDefinitions.TMS470_TICLANG_4.0.compilerID.MARCH.thumbv6m" valueType="enumerated"/>
                                <option id="com.ti.ccstudio.buildDefinitions.TMS470_TICLANG_4.0.compilerID.MFLOAT_ABI.1957954083" superClass="com.ti.ccstudio.buildDefinitions.TMS470_TICLANG_4.0.compilerID.MFLOAT_ABI" value="com.ti.ccstudio.buildDefinitions.TMS470_TICLANG_4.0.compilerID.MFLOAT_ABI.soft" valueType="enumerated"/>
                                <option id="com.ti.ccstudio.buildDefinitions.TMS470_TICLANG_4.0.compilerID.SELECT_PROCESSOR_MODE__ARM_THUMB.289788287" superClass="com.ti.ccstudio.buildDefinitions.TMS470_TICLANG_4.0.compilerID.SELECT_PROCESSOR_MODE__ARM_THUMB" value="com.ti.ccstudio.buildDefinitions.TMS470_TICLANG_4.0.compilerID.SELECT_PROCESSOR_MODE__ARM_THUMB.MTHUMB" valueType="enumerated"/>
                            </tool>
                            <tool id="com.ti.ccstudio.buildDefinitions.TMS470_TICLANG_4.0.exe.linkerDebug.533668538" name="Arm Linker" superClass="com.ti.ccstudio.buildDefinitions.TMS470_TICLANG_4.0.exe.linkerDebug">
                                <option id="com.ti.ccstudio.buildDefinitions.TMS470_TICLANG_4.0.linkerID.OUTPUT_FILE.1146682434" superClass="com.ti.ccstudio.buildDefinitions.TMS470_TICLANG_4.0.linkerID.OUTPUT_FILE" value="${ProjName}.out" valueType="string"/>
                                <option id="com.ti.ccstudio.buildDefinitions.TMS470_TICLANG_4.0.linkerID.MAP_FILE.1494345645" superClass="com.ti.ccstudio.buildDefinitions.TMS470_TICLANG_4.0.linkerID.MAP_FILE" value="${ProjName}.map" valueType="string"/>
                                <option id="com.ti.ccstudio.buildDefinitions.TMS470_TICLANG_4.0.linkerID.XML_LINK_INFO.415312755" superClass="com.ti.ccstudio.buildDefinitions.TMS470_TICLANG_4.0.linkerID.XML_LINK_INFO" value="${ProjName}_linkInfo.xml" valueType="string"/>
                                <option id="com.ti.ccstudio.buildDefinitions.TMS470_TICLANG_4.0.linkerID.DISPLAY_ERROR_NUMBER.950722215" superClass="com.ti.ccstudio.buildDefinitions.TMS470_TICLANG_4.0.linkerID.DISPLAY_ERROR_NUMBER" value="true" valueType="boolean"/>
                                <option id="com.ti.ccstudio.buildDefinitions.TMS470_TICLANG_4.0.linkerID.DIAG_WRAP.1595514880" superClass="com.ti.ccstudio.buildDefinitions.TMS470_TICLANG_4.0.linkerID.DIAG_WRAP" value="com.ti.ccstudio.buildDefinitions.TMS470_TICLANG_4.0.linkerID.DIAG_WRAP.off" valueType="enumerated"/>
                                <option id="com.ti.ccstudio.buildDefinitions.TMS470_TICLANG_4.0.linkerID.REREAD_LIBS.1463040342" superClass="com.ti.ccstudio.buildDefinitions.TMS470_TICLANG_4.0.linkerID.REREAD_LIBS" value="false" valueType="boolean"/>
                                <option id="com.ti.ccstudio.buildDefinitions.TMS470_TICLANG_4.0.linkerID.SEARCH_PATH.2125108231" superClass="com.ti.ccstudio.buildDefinitions.TMS470_TICLANG_4.0.linkerID.SEARCH_PATH" valueType="libPaths">
                                    <listOptionValue value="${COM_TI_MSPM0_SDK_LIBRARY_PATH}"/>
                                    <listOptionValue value="${SYSCONFIG_TOOL_LIBRARY_PATH}"/>
                                    <listOptionValue value="${COM_TI_MSPM0_SDK_INSTALL_DIR}/source"/>
                                    <listOptionValue value="${PROJECT_ROOT}"/>
                                    <listOptionValue value="${PROJECT_BUILD_DIR}/syscfg"/>
                                    <listOptionValue value="${CG_TOOL_ROOT}/lib"/>
                                </option>
                                <option id="com.ti.ccstudio.buildDefinitions.TMS470_TICLANG_4.0.linkerID.LIBRARY.194561857" superClass="com.ti.ccstudio.buildDefinitions.TMS470_TICLANG_4.0.linkerID.LIBRARY" valueType="libs">
                                    <listOptionValue value="${COM_TI_MSPM0_SDK_LIBRARIES}"/>
                                    <listOptionValue value="${SYSCONFIG_TOOL_LIBRARIES}"/>
                                    <listOptionValue value="device.cmd.genlibs"/>
                                    <listOptionValue value="libc.a"/>
                                </option>
                            </tool>
                            <tool id="com.ti.ccstudio.buildDefinitions.TMS470_TICLANG_4.0.hex.1541947897" name="Arm Hex Utility" superClass="com.ti.ccstudio.buildDefinitions.TMS470_TICLANG_4.0.hex"/>
                            <tool id="com.ti.ccstudio.buildDefinitions.TMS470_TICLANG_4.0.objcopy.299859876" name="Arm Objcopy Utility" superClass="com.ti.ccstudio.buildDefinitions.TMS470_TICLANG_4.0.objcopy"/>
                            <tool id="com.ti.ccstudio.buildDefinitions.sysConfig.1398482631" name="SysConfig" superClass="com.ti.ccstudio.buildDefinitions.sysConfig">
                                <option id="com.ti.ccstudio.buildDefinitions.sysConfig.PRODUCTS.1429224333" superClass="com.ti.ccstudio.buildDefinitions.sysConfig.PRODUCTS" valueType="stringList">
                                    <listOptionValue value="${COM_TI_MSPM0_SDK_SYSCONFIG_MANIFEST}"/>
                                    <listOptionValue value="${SYSCONFIG_TOOL_SYSCONFIG_MANIFEST}"/>
                                </option>
                                <option id="com.ti.ccstudio.buildDefinitions.sysConfig.OUTPUT_DIR__MANUAL.1012056058" superClass="com.ti.ccstudio.buildDefinitions.sysConfig.OUTPUT_DIR__MANUAL" value="." valueType="string"/>
                                <option id="com.ti.ccstudio.buildDefinitions.sysConfig.DIRECTORY_MODE.306485381" superClass="com.ti.ccstudio.buildDefinitions.sysConfig.DIRECTORY_MODE" value="com.ti.ccstudio.buildDefinitions.sysConfig.DIRECTORY_MODE.manual" valueType="enumerated"/>
                            </tool>
                        </toolChain>
                    </folderInfo>
                </configuration>
            </storageModule>
            <storageModule moduleId="org.eclipse.cdt.core.externalSettings"/>
        </cconfiguration>
    </storageModule>
    <storageModule moduleId="cdtBuildSystem" version="4.0.0">
        <project id="empty_LP_MSPM0G3507_nortos_ticlang.com.ti.ccstudio.buildDefinitions.TMS470.ProjectType.1112814674" name="TMS470" projectType="com.ti.ccstudio.buildDefinitions.TMS470.ProjectType"/>
    </storageModule>
</cproject>

================
File: .gitignore
================
Debug

================
File: .project
================
<?xml version="1.0" encoding="UTF-8"?>
<projectDescription>
	<name>Medicine_Car</name>
	<comment></comment>
	<projects>
	</projects>
	<buildSpec>
		<buildCommand>
			<name>org.eclipse.cdt.managedbuilder.core.genmakebuilder</name>
			<arguments>
			</arguments>
		</buildCommand>
	</buildSpec>
	<natures>
		<nature>com.ti.ccstudio.core.ccsNature</nature>
		<nature>org.eclipse.cdt.core.cnature</nature>
		<nature>org.eclipse.cdt.managedbuilder.core.managedBuildNature</nature>
		<nature>org.eclipse.cdt.core.ccnature</nature>
	</natures>
</projectDescription>

================
File: .settings/org.eclipse.cdt.codan.core.prefs
================
eclipse.preferences.version=1
inEditor=false
onBuild=false

================
File: .settings/org.eclipse.core.resources.prefs
================
eclipse.preferences.version=1
encoding//Debug/Beep/subdir_rules.mk=UTF-8
encoding//Debug/Beep/subdir_vars.mk=UTF-8
encoding//Debug/Driver/subdir_rules.mk=UTF-8
encoding//Debug/Driver/subdir_vars.mk=UTF-8
encoding//Debug/HWT101/subdir_rules.mk=UTF-8
encoding//Debug/HWT101/subdir_vars.mk=UTF-8
encoding//Debug/K210/subdir_rules.mk=UTF-8
encoding//Debug/K210/subdir_vars.mk=UTF-8
encoding//Debug/K230/subdir_rules.mk=UTF-8
encoding//Debug/K230/subdir_vars.mk=UTF-8
encoding//Debug/Key/subdir_rules.mk=UTF-8
encoding//Debug/Key/subdir_vars.mk=UTF-8
encoding//Debug/Laser/subdir_rules.mk=UTF-8
encoding//Debug/Laser/subdir_vars.mk=UTF-8
encoding//Debug/Mask/subdir_rules.mk=UTF-8
encoding//Debug/Mask/subdir_vars.mk=UTF-8
encoding//Debug/Raspberry_Pi/subdir_rules.mk=UTF-8
encoding//Debug/Raspberry_Pi/subdir_vars.mk=UTF-8
encoding//Debug/Resberry_Pi/subdir_rules.mk=UTF-8
encoding//Debug/Resberry_Pi/subdir_vars.mk=UTF-8
encoding//Debug/Servo/subdir_rules.mk=UTF-8
encoding//Debug/Servo/subdir_vars.mk=UTF-8
encoding//Debug/System/subdir_rules.mk=UTF-8
encoding//Debug/System/subdir_vars.mk=UTF-8
encoding//Debug/makefile=UTF-8
encoding//Debug/objects.mk=UTF-8
encoding//Debug/sources.mk=UTF-8
encoding//Debug/subdir_rules.mk=UTF-8
encoding//Debug/subdir_vars.mk=UTF-8

================
File: Beep/Beep_config.c
================
#include "Beep_config.h"


// BEEP_CONFIG beep_config = {
//     .gpio_port = BEEP_GPIO_PORT,
//     .gpio_pin = BEEP_GPIO_PIN
// };

================
File: Beep/Beep_config.h
================
#ifndef _BEEP_CONFIG_H
#define _BEEP_CONFIG_H

#include "my_gpio.h"
#include "ti_msp_dl_config.h"

typedef struct {
    GPIO_Regs *gpio_port;
    uint32_t gpio_pin;
}BEEP_CONFIG;

extern BEEP_CONFIG beep_config;

#endif

================
File: Beep/Beep_gpio.c
================
#include "Beep_gpio.h"

void beep_on(BEEP_CONFIG config)
{
  // Use the config structure to access the GPIO port and pin
  gpio_setpin(config.gpio_port, config.gpio_pin);
}

void beep_off(BEEP_CONFIG config)
{
  // Use the config structure to access the GPIO port and pin
  gpio_resetpin(config.gpio_port, config.gpio_pin);
}

================
File: Beep/Beep_gpio.h
================
#ifndef _BEEP_GPIO_H
#define _BEEP_GPIO_H

#include "Beep_config.h"

void beep_on(BEEP_CONFIG config);
void beep_off(BEEP_CONFIG config);

#endif

================
File: Beep/Beep.c
================
#include "Beep.h"

void Beep_create(BEEPER *beeper, BEEP_CONFIG config)
{
    // Initialize the beeper with its configuration
    beeper->beepconfig = config;
}

void Beep_on(BEEPER *beeper)
{
 beep_on(beeper->beepconfig);
}

void Beep_off(BEEPER *beeper)
{
 beep_off(beeper->beepconfig);
}

================
File: Beep/Beep.h
================
#ifndef _BEEP_H
#define _BEEP_H

#include "Beep_gpio.h"

typedef struct {
   BEEP_CONFIG beepconfig; // Configuration for the beep
} BEEPER;

void Beep_create(BEEPER *beeper, BEEP_CONFIG config);
void Beep_on(BEEPER *beeper);
void Beep_off(BEEPER *beeper);

#endif

================
File: Driver/Driver_config.c
================
#include "Driver_config.h"


DRIVER_CONFIG leftdriver = {

	.encoder_port = {
            //中断线	
            	.IRQn = GPIO_MULTIPLE_GPIOA_INT_IRQN,
            // GPIO端口
            	.gpio_port = Encoder_Left_PORT,
            	.EncoderA_PIN = Encoder_Left_Left_A_PIN,
            	.EncoderB_PIN = Encoder_Left_Left_B_PIN,
            	.EncoderC_PIN = Encoder_Left_Left_C_PIN,
            	.EncoderD_PIN = Encoder_Left_Left_D_PIN,
            // 编码器计数器
            	.encoder_counter = 0,
            // 编码器ID
            	.encoder_id = 0
        },

	.pwm_port = Driver_Left_INST,
	.DriverPWMTimer_autoreload = 7200,
	.Channel[0] = GPIO_Driver_Left_C0_IDX,
	.Channel[1] = GPIO_Driver_Left_C1_IDX,
	
	.Encoder_polarity = 0,

	.Pwm_polarity = 0

};

DRIVER_CONFIG rightdriver = {
            	.encoder_port = {
              //中断线
            	.IRQn = GPIO_MULTIPLE_GPIOA_INT_IRQN,
              // GPIO端口	
            	.gpio_port = Encoder_Right_PORT,
            	.EncoderA_PIN = Encoder_Right_Right_A_PIN,
            	.EncoderB_PIN = Encoder_Right_Right_B_PIN,
            	.EncoderC_PIN = Encoder_Right_Right_C_PIN,
            	.EncoderD_PIN = Encoder_Right_Right_D_PIN,
              // 编码器计数器	
                .encoder_counter = 0,
              // 编码器ID
            	.encoder_id = 1
          },
        
	.pwm_port = Driver_Right_INST,
	.DriverPWMTimer_autoreload = 7200,
	.Channel[0] = GPIO_Driver_Right_C0_IDX,
	.Channel[1] = GPIO_Driver_Right_C1_IDX,

	.Encoder_polarity = 1,

	.Pwm_polarity = 1
};

================
File: Driver/Driver_config.h
================
#ifndef _DRIVER_CONFIG
#define _DRIVER_CONFIG

#include "gpio_encoder.h"
#include "ti_msp_dl_config.h"
#include "pwm.h"

typedef struct {

	//电机编码器端口设置
    ENCODER_PORT encoder_port;

	//电机PWM端口设置
	GPTIMER_Regs *pwm_port;
	DL_TIMER_CC_INDEX Channel[2];
  	int DriverPWMTimer_autoreload;

	//电机编码器极性设置  （软件）
	int Encoder_polarity;

	//电机PWM极性设置（软件）
	int Pwm_polarity;

} DRIVER_CONFIG;


extern DRIVER_CONFIG leftdriver;
extern DRIVER_CONFIG rightdriver;



#endif

================
File: Driver/Driver_Encoder.c
================
#include "Driver_Encoder.h"

void DriverEncoder_start(DRIVER_CONFIG driver)
{
     encoder_init(driver.encoder_port.encoder_id, driver.encoder_port);
     encoder_start(driver.encoder_port.encoder_id);
}

int16_t DriverEncoder_getcounter(DRIVER_CONFIG driver)
{
    if (driver.Encoder_polarity == 1) {
        return encoder_getcounter(driver.encoder_port.encoder_id);
    }
    else {
        return -encoder_getcounter(driver.encoder_port.encoder_id);
    }

}

================
File: Driver/Driver_Encoder.h
================
#ifndef _DRIVER_ENCODER_H
#define _DRIVER_ENCODER_H


#include "Driver_config.h"
#include "stdint.h"


void DriverEncoder_start(DRIVER_CONFIG driver);
int16_t DriverEncoder_getcounter(DRIVER_CONFIG driver);


#endif

================
File: Driver/Driver_pwm.c
================
#include "Driver_pwm.h"

//初始化硬件pwm
void DriverPwm_start(DRIVER_CONFIG driver)
{
  pwm_init(driver.pwm_port);
}

//设置PWM
static void Driver_setonechannelpwm(DRIVER_CONFIG driver,int channel, int pwm)
{
    pwm_set(driver.pwm_port,driver.Channel[channel - 1],pwm);
}

// //滑行
// void Driver_setpwm(DRIVER_CONFIG driver,int pwm)
// {
// 	if (driver.Pwm_polarity == 0){
// 		if (pwm > 0) {
// 			Driver_setonechannelpwm(driver, 1, pwm);
// 			Driver_setonechannelpwm(driver, 2, 0);
// 		} else if (pwm < 0) {
// 			Driver_setonechannelpwm(driver, 1, 0);
// 			Driver_setonechannelpwm(driver, 2, -pwm);
// 		}
// 	} else if (driver.Pwm_polarity == 1) {
// 		if (pwm > 0) {
// 			Driver_setonechannelpwm(driver, 1, 0);
// 			Driver_setonechannelpwm(driver, 2, pwm);
// 		} else if (pwm < 0) {
// 			Driver_setonechannelpwm(driver, 1, -pwm);
// 			Driver_setonechannelpwm(driver, 2, 0);
// 		}
// 	}
// 	if (pwm == 0) {
// 		Driver_setonechannelpwm(driver, 1, 0);
// 		Driver_setonechannelpwm(driver, 2, 0);
// 	}
// }

//刹车
void Driver_setpwm(DRIVER_CONFIG driver,int pwm)
{
	if (driver.Pwm_polarity == 1) {
		if (pwm > 0) {
			Driver_setonechannelpwm(driver, 1, driver.DriverPWMTimer_autoreload - pwm);
			Driver_setonechannelpwm(driver, 2, driver.DriverPWMTimer_autoreload);
		} else if (pwm < 0) {
			Driver_setonechannelpwm(driver, 1, driver.DriverPWMTimer_autoreload);
			Driver_setonechannelpwm(driver, 2, driver.DriverPWMTimer_autoreload  + pwm);
		}
	} else if (driver.Pwm_polarity == 0) {
		if (pwm > 0) {
			Driver_setonechannelpwm(driver, 1, driver.DriverPWMTimer_autoreload);
			Driver_setonechannelpwm(driver, 2, driver.DriverPWMTimer_autoreload - pwm);
		} else if (pwm < 0) {
			Driver_setonechannelpwm(driver, 1, driver.DriverPWMTimer_autoreload  + pwm);
			Driver_setonechannelpwm(driver, 2, driver.DriverPWMTimer_autoreload);
		}
	}
	if (pwm == 0) {
		Driver_setonechannelpwm(driver, 1, driver.DriverPWMTimer_autoreload);
		Driver_setonechannelpwm(driver, 2, driver.DriverPWMTimer_autoreload);
	}
}

================
File: Driver/Driver_pwm.h
================
#ifndef _DRIVER_PWM_H
#define _DRIVER_PWM_H

#include "Driver_config.h"

void DriverPwm_start(DRIVER_CONFIG driver);
void Driver_setpwm(DRIVER_CONFIG driver,int pwm);


#endif

================
File: Driver/Driver.c
================
#include "Driver.h"

//PID pidL = {25.0,5.0,0.0};
//PID pidR = {25.0,5.0,0.0};

//实例化电机
void Driver_creatmotor(MOTOR *mymotor, PID pid, DRIVER_CONFIG driver)
{
	  mymotor->pid = pid;
	  pidmemory_clear(&(mymotor->pid));
	
	  mymotor->lastspeed = 0;
	  mymotor->targetspeed = 0;
	
	  mymotor->config = driver;
}

//初始化电机驱动边上外设
void Driver_init(MOTOR *motor)
{
     DriverEncoder_start(motor->config);
     DriverPwm_start(motor->config);
}


void Driver_setmotorpwm(MOTOR *motor1,int pwm1, MOTOR *motor2,int pwm2)
{
    Driver_setpwm(motor1->config,pwm1);
   	Driver_setpwm(motor2->config,pwm2);
}


void Driver_setmotor_targetspeed(MOTOR *motor,int target_speed)
{
     motor -> targetspeed = target_speed;
}

void Driver_getmotor_currentspeed(MOTOR *motor)
{
	motor->currentspeed = DriverEncoder_getcounter(motor->config);
}


void Driver_setspeed(MOTOR *motor1,MOTOR *motor2)
{
	int pwm1 = (int) deltaPid_Cal((float) (motor1->targetspeed), (float) (motor1->currentspeed), &(motor1->pid));
	int pwm2 = (int) deltaPid_Cal((float) (motor2->targetspeed), (float) (motor2->currentspeed), &(motor2->pid));

    if (motor1->targetspeed == 0) {
	    pwm1 = 0;
	    pidmemory_clear(&(motor1->pid));
    }
    if (motor2->targetspeed == 0) {
	    pwm2 = 0;
	    pidmemory_clear(&(motor2->pid));
    }
   
   Driver_setmotorpwm(motor1,pwm1,motor2,pwm2);
}

void Driver_setspeedwithfliter(MOTOR *motor1, MOTOR *motor2, float filter) {
	motor1->flitspeed = (float) motor1->flitspeed * filter + (float) motor1->currentspeed * (1.0 - filter);
	motor2->flitspeed = (float) motor2->flitspeed * filter + (float) motor2->currentspeed * (1.0 - filter);

	int pwm1 = (int) deltaPid_Cal((float) (motor1->targetspeed), (float) (motor1->flitspeed), &(motor1->pid));
	int pwm2 = (int) deltaPid_Cal((float) (motor2->targetspeed), (float) (motor2->flitspeed), &(motor2->pid));

	if (motor1->targetspeed == 0 && motor2->targetspeed == 0) {
		pwm1 = 0;
		pwm2 = 0;
		pidmemory_clear(&(motor1->pid));
		pidmemory_clear(&(motor2->pid));
	}

	Driver_setmotorpwm(motor1, pwm1, motor2, pwm2);
}

================
File: Driver/Driver.h
================
#ifndef _DRIVER_H
#define _DRIVER_H

#include "Driver_Encoder.h"
#include "Driver_pwm.h"
#include "pid.h"
#include "stdlib.h"

extern PID pidL;
extern PID pidR;


typedef struct
{
	DRIVER_CONFIG config;
	int targetspeed;
	int currentspeed;
	int flitspeed;
	int lastspeed;
	PID pid;

}MOTOR;

void Driver_creatmotor(MOTOR *mymotor,PID pid,DRIVER_CONFIG driver);

void Driver_init(MOTOR *motor);

void Driver_setmotor_targetspeed(MOTOR *motor,int target_speed);

void Driver_getmotor_currentspeed(MOTOR *motor);

void Driver_setmotorpwm(MOTOR *motor1,int pwm1, MOTOR *motor2,int pwm2);

void Driver_setspeed(MOTOR *motor1,MOTOR *motor2);

void Driver_setspeedwithfliter(MOTOR *motor1, MOTOR *motor2, float filter);



#endif

================
File: Driver/pid.c
================
#include "pid.h"


double xianfu(double value, double min, double max) {
    if (value > max) return max;
    if (value < min) return min;
    return value;
}

double position_divAPI_PID_Cal(double targetvalue,double currentvalue,double current_div,PID* pid) {
	
	pid->last_outvalue = pid->outvalue;
	// 1. 计算当前偏差
	double bias = targetvalue - currentvalue;

	// 2. 计算比例项
	double P = pid->kp * bias;

	// 3. 更新积分项（累积当前偏差）
	pid->integral += bias;

	// 4. 计算积分项和微分项
	double I = pid->ki * pid->integral;
		  //积分限幅 
	if(pid->integrate_xianfu > 0)
	 {
	  I = xianfu(I, -pid->integrate_xianfu, pid->integrate_xianfu);
	 }
	 
	double D = current_div * pid->kd;

	// 5. 计算总输出
	   pid->outvalue = P + I + D;

	// 6. 对输出进行限幅
	 if(pid->out_xianfu > 0)
	 {
	 	 pid->outvalue = xianfu(pid->outvalue, -pid->out_xianfu, pid->out_xianfu);
	 }

	return pid->outvalue;
}


// 位置式 PID 计算函数（带输出限幅和积分抗饱和）
double positionPid_Cal(double targetvalue, double currentvalue, PID* pid) {
    
	
		pid->last_outvalue = pid->outvalue;
	  // 1. 计算当前偏差
    double bias = targetvalue - currentvalue;

    // 2. 计算比例项
    double P = pid->kp * bias;

    // 3. 更新积分项（累积当前偏差）
    pid->integral += bias;

    // 4. 计算积分项和微分项
    double I = pid->ki * pid->integral;
	  //积分限幅 
	 if(pid->integrate_xianfu > 0)
	 {
	  I = xianfu(I, -pid->integrate_xianfu, pid->integrate_xianfu);
	 }
    double D = pid->kd * (bias - pid->last_bias);

    // 5. 计算总输出
     pid->outvalue = P + I + D;

	  // 6. 对输出进行限幅
	  if(pid->out_xianfu > 0)
		{
			  pid->outvalue = xianfu(pid->outvalue, -pid->out_xianfu, pid->out_xianfu);
		}

    // 8. 更新状态
    pid->last_bias = bias;      // 保存当前偏差，用于下一次微分计算

    return pid->outvalue;
}

// 位置式 FF-PID 计算函数
double positionFFPid_Cal(double targetvalue, double currentvalue, PID* pid) {
    
	double Uff = pid->kff * targetvalue;

		pid->last_outvalue = pid->outvalue;
	  // 1. 计算当前偏差
    double bias = targetvalue - currentvalue;

    // 2. 计算比例项
    double P = pid->kp * bias;

    // 3. 更新积分项（累积当前偏差）
    pid->integral += bias;

    // 4. 计算积分项和微分项
    double I = pid->ki * pid->integral;
	  //积分限幅 
	 if(pid->integrate_xianfu > 0)
	 {
	  I = xianfu(I, -pid->integrate_xianfu, pid->integrate_xianfu);
	 }
    double D = pid->kd * (bias - pid->last_bias);

    // 5. 计算总输出
     pid->outvalue = P + I + D + Uff;

	  // 6. 对输出进行限幅
	  if(pid->out_xianfu > 0)
		{
			  pid->outvalue = xianfu(pid->outvalue, -pid->out_xianfu, pid->out_xianfu);
		}

    // 8. 更新状态
    pid->last_bias = bias;      // 保存当前偏差，用于下一次微分计算

    return pid->outvalue;
}

// 增量式 PID 计算函数
double deltaPid_Cal(double targetvalue,double currentvalue,PID* pid)
{
	
		pid->last_outvalue = pid->outvalue;
	
	double bias,current_bias,outputvalue; 
	
	current_bias = targetvalue - currentvalue;

  bias = current_bias - pid->last_bias;

	pid -> outvalue += pid->kp * bias + pid->ki * current_bias + pid->kd * (current_bias - 2*pid->last_bias + pid->last2_bias);

	pid->last2_bias = pid->last_bias; // 保存上上次偏差
	pid->last_bias = current_bias;
	
	if(pid->out_xianfu > 0)
	{
	  pid -> outvalue = xianfu(pid -> outvalue,-pid->out_xianfu,pid->out_xianfu);
	}

	return pid -> outvalue;
}

double deltaFFPid_Cal(double targetvalue,double currentvalue,PID* pid)
{

	double delta_u = targetvalue - pid->last_targetvalue;

	pid->last_outvalue = pid->outvalue;
	
	double bias,current_bias,outputvalue; 
	
	current_bias = targetvalue - currentvalue;

    bias = current_bias - pid->last_bias;
	
	pid -> outvalue += pid->kp * bias + pid->ki * current_bias + pid->kff * delta_u;

	pid->last_bias = current_bias;

	pid -> last_targetvalue = targetvalue;

	if(pid->out_xianfu > 0)
	{
	  pid -> outvalue = xianfu(pid -> outvalue,-pid->out_xianfu,pid->out_xianfu);
	}

	return pid -> outvalue;

}

void pidmemory_clear(PID* pid)
{
	  pid->integral  = 0;
      pid->last_bias = 0;
	  pid->last2_bias = 0;
	  pid->outvalue  = 0;
	  pid->last_outvalue = 0;
	  pid->last_targetvalue = 0;
}

================
File: Driver/pid.h
================
#ifndef _PID_H
#define _PID_H

#include "math.h"

typedef struct
{

	double kff; //前馈系数
	double kp; //比例系数
	double ki; //积分系数
	double kd; //微分系数

	double out_xianfu; //输出限幅
	double integrate_xianfu; //积分限幅

    double last_targetvalue; //上次目标值	
	double last_bias;  //上次偏差
	double last2_bias; //上上次偏差
	double integral;   //积分值
	double outvalue;   //输出值
	double last_outvalue; //上次输出值

}PID;


//PID相关数学函数
  //限幅函数
double xianfu(double value, double min, double max);

//暴露微分
double position_divAPI_PID_Cal(double targetvalue,double currentvalue,double current_div,PID* pid);
// 位置式 PID 计算函数（带输出限幅和积分抗饱和）
double positionPid_Cal(double targetvalue, double currentvalue, PID* pid);
//位置式 FFPID 计算函数
double positionFFPid_Cal(double targetvalue, double currentvalue, PID* pid);
//增量式 PID 计算函数
double deltaPid_Cal(double targetvalue, double currentvalue, PID* pid);
//增量式 FFPID 计算函数
double deltaFFPid_Cal(double targetvalue, double currentvalue, PID* pid);
//清除PID内存
void pidmemory_clear(PID* pid);

#endif

================
File: empty.c
================
/*
 * Copyright (c) 2021, Texas Instruments Incorporated
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *
 * *  Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 *
 * *  Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 *
 * *  Neither the name of Texas Instruments Incorporated nor the names of
 *    its contributors may be used to endorse or promote products derived
 *    from this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
 * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 * PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR
 * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
 * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
 * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS;
 * OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
 * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR
 * OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
 * EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

#include "ti_msp_dl_config.h"
#include "Mask.h"

int main(void)
{
    SYSCFG_DL_init();

    Mask_start();

    while (1) {
    }
}

================
File: empty.syscfg
================
/**
 * These arguments were used when this file was generated. They will be automatically applied on subsequent loads
 * via the GUI or CLI. Run CLI with '--help' for additional information on how to override these arguments.
 * @cliArgs --device "MSPM0G350X" --part "Default" --package "LQFP-64(PM)" --product "mspm0_sdk@2.04.00.06"
 * @v2CliArgs --device "MSPM0G3507" --package "LQFP-64(PM)" --product "mspm0_sdk@2.04.00.06"
 * @versions {"tool":"1.21.1+3772"}
 */

/**
 * Import the modules used in this configuration.
 */
const GPIO   = scripting.addModule("/ti/driverlib/GPIO", {}, false);
const GPIO1  = GPIO.addInstance();
const GPIO2  = GPIO.addInstance();
const GPIO3  = GPIO.addInstance();
const GPIO4  = GPIO.addInstance();
const PWM    = scripting.addModule("/ti/driverlib/PWM", {}, false);
const PWM1   = PWM.addInstance();
const PWM2   = PWM.addInstance();
const PWM3   = PWM.addInstance();
const SYSCTL = scripting.addModule("/ti/driverlib/SYSCTL");
const TIMER  = scripting.addModule("/ti/driverlib/TIMER", {}, false);
const TIMER1 = TIMER.addInstance();
const UART   = scripting.addModule("/ti/driverlib/UART", {}, false);
const UART1  = UART.addInstance();
const UART2  = UART.addInstance();
const UART3  = UART.addInstance();
const UART4  = UART.addInstance();

/**
 * Write custom configuration values to the imported modules.
 */
const divider6       = system.clockTree["PLL_CLK2X_DIV"];
divider6.divideValue = 4;

const divider7       = system.clockTree["PLL_PDIV"];
divider7.divideValue = 2;

const divider9       = system.clockTree["UDIV"];
divider9.divideValue = 2;

const multiplier2         = system.clockTree["PLL_QDIV"];
multiplier2.multiplyValue = 10;

const mux8       = system.clockTree["HSCLKMUX"];
mux8.inputSelect = "HSCLKMUX_SYSPLL2X";

GPIO1.$name                              = "Encoder_Left";
GPIO1.port                               = "PORTA";
GPIO1.associatedPins.create(4);
GPIO1.associatedPins[0].direction        = "INPUT";
GPIO1.associatedPins[0].internalResistor = "PULL_UP";
GPIO1.associatedPins[0].interruptEn      = true;
GPIO1.associatedPins[0].polarity         = "FALL";
GPIO1.associatedPins[0].$name            = "Left_A";
GPIO1.associatedPins[0].pin.$assign      = "PA24";
GPIO1.associatedPins[1].direction        = "INPUT";
GPIO1.associatedPins[1].internalResistor = "PULL_UP";
GPIO1.associatedPins[1].interruptEn      = true;
GPIO1.associatedPins[1].$name            = "Left_B";
GPIO1.associatedPins[1].polarity         = "RISE";
GPIO1.associatedPins[1].pin.$assign      = "PA17";
GPIO1.associatedPins[2].direction        = "INPUT";
GPIO1.associatedPins[2].internalResistor = "PULL_UP";
GPIO1.associatedPins[2].interruptEn      = true;
GPIO1.associatedPins[2].$name            = "Left_C";
GPIO1.associatedPins[2].polarity         = "FALL";
GPIO1.associatedPins[2].pin.$assign      = "PA16";
GPIO1.associatedPins[3].direction        = "INPUT";
GPIO1.associatedPins[3].internalResistor = "PULL_UP";
GPIO1.associatedPins[3].interruptEn      = true;
GPIO1.associatedPins[3].polarity         = "RISE";
GPIO1.associatedPins[3].$name            = "Left_D";
GPIO1.associatedPins[3].pin.$assign      = "PA15";

const Board = scripting.addModule("/ti/driverlib/Board", {}, false);

GPIO2.$name                              = "Encoder_Right";
GPIO2.port                               = "PORTA";
GPIO2.associatedPins.create(4);
GPIO2.associatedPins[0].$name            = "Right_A";
GPIO2.associatedPins[0].direction        = "INPUT";
GPIO2.associatedPins[0].internalResistor = "PULL_UP";
GPIO2.associatedPins[0].interruptEn      = true;
GPIO2.associatedPins[0].polarity         = "FALL";
GPIO2.associatedPins[0].pin.$assign      = "PA25";
GPIO2.associatedPins[1].$name            = "Right_B";
GPIO2.associatedPins[1].direction        = "INPUT";
GPIO2.associatedPins[1].internalResistor = "PULL_UP";
GPIO2.associatedPins[1].interruptEn      = true;
GPIO2.associatedPins[1].polarity         = "RISE";
GPIO2.associatedPins[1].pin.$assign      = "PA9";
GPIO2.associatedPins[2].$name            = "Right_C";
GPIO2.associatedPins[2].direction        = "INPUT";
GPIO2.associatedPins[2].internalResistor = "PULL_UP";
GPIO2.associatedPins[2].interruptEn      = true;
GPIO2.associatedPins[2].polarity         = "FALL";
GPIO2.associatedPins[2].pin.$assign      = "PA8";
GPIO2.associatedPins[3].$name            = "Right_D";
GPIO2.associatedPins[3].direction        = "INPUT";
GPIO2.associatedPins[3].internalResistor = "PULL_UP";
GPIO2.associatedPins[3].interruptEn      = true;
GPIO2.associatedPins[3].polarity         = "RISE";
GPIO2.associatedPins[3].pin.$assign      = "PA26";

GPIO3.$name                         = "RGY_LED";
GPIO3.associatedPins.create(3);
GPIO3.associatedPins[0].$name       = "R_Pin";
GPIO3.associatedPins[0].pin.$assign = "PB19";
GPIO3.associatedPins[1].$name       = "G_Pin";
GPIO3.associatedPins[1].pin.$assign = "PB18";
GPIO3.associatedPins[2].$name       = "Y_Pin";
GPIO3.associatedPins[2].pin.$assign = "PA22";

GPIO4.$name                              = "Key";
GPIO4.associatedPins[0].$name            = "Key_Pin";
GPIO4.associatedPins[0].direction        = "INPUT";
GPIO4.associatedPins[0].internalResistor = "PULL_UP";
GPIO4.associatedPins[0].pin.$assign      = "PB8";

PWM1.$name                              = "Driver_Left";
PWM1.timerCount                         = 7200;
PWM1.pwmMode                            = "EDGE_ALIGN_UP";
PWM1.peripheral.$assign                 = "TIMG0";
PWM1.peripheral.ccp0Pin.$assign         = "PA12";
PWM1.peripheral.ccp1Pin.$assign         = "PA13";
PWM1.PWM_CHANNEL_0.$name                = "ti_driverlib_pwm_PWMTimerCC0";
PWM1.PWM_CHANNEL_1.$name                = "ti_driverlib_pwm_PWMTimerCC1";
PWM1.ccp0PinConfig.$name                = "ti_driverlib_gpio_GPIOPinGeneric0";
PWM1.ccp0PinConfig.direction            = scripting.forceWrite("OUTPUT");
PWM1.ccp0PinConfig.hideOutputInversion  = scripting.forceWrite(false);
PWM1.ccp0PinConfig.onlyInternalResistor = scripting.forceWrite(false);
PWM1.ccp0PinConfig.passedPeripheralType = scripting.forceWrite("Digital");
PWM1.ccp1PinConfig.$name                = "ti_driverlib_gpio_GPIOPinGeneric1";
PWM1.ccp1PinConfig.direction            = scripting.forceWrite("OUTPUT");
PWM1.ccp1PinConfig.hideOutputInversion  = scripting.forceWrite(false);
PWM1.ccp1PinConfig.onlyInternalResistor = scripting.forceWrite(false);
PWM1.ccp1PinConfig.passedPeripheralType = scripting.forceWrite("Digital");

PWM2.$name                              = "Driver_Right";
PWM2.clockDivider                       = 2;
PWM2.timerCount                         = 7200;
PWM2.pwmMode                            = "EDGE_ALIGN_UP";
PWM2.peripheral.$assign                 = "TIMG6";
PWM2.peripheral.ccp0Pin.$assign         = "PB6";
PWM2.peripheral.ccp1Pin.$assign         = "PB7";
PWM2.PWM_CHANNEL_0.$name                = "ti_driverlib_pwm_PWMTimerCC2";
PWM2.PWM_CHANNEL_1.$name                = "ti_driverlib_pwm_PWMTimerCC3";
PWM2.ccp0PinConfig.$name                = "ti_driverlib_gpio_GPIOPinGeneric2";
PWM2.ccp0PinConfig.direction            = scripting.forceWrite("OUTPUT");
PWM2.ccp0PinConfig.hideOutputInversion  = scripting.forceWrite(false);
PWM2.ccp0PinConfig.onlyInternalResistor = scripting.forceWrite(false);
PWM2.ccp0PinConfig.passedPeripheralType = scripting.forceWrite("Digital");
PWM2.ccp1PinConfig.$name                = "ti_driverlib_gpio_GPIOPinGeneric3";
PWM2.ccp1PinConfig.direction            = scripting.forceWrite("OUTPUT");
PWM2.ccp1PinConfig.hideOutputInversion  = scripting.forceWrite(false);
PWM2.ccp1PinConfig.onlyInternalResistor = scripting.forceWrite(false);
PWM2.ccp1PinConfig.passedPeripheralType = scripting.forceWrite("Digital");

PWM3.$name                              = "Servo";
PWM3.pwmMode                            = "EDGE_ALIGN_UP";
PWM3.ccIndex                            = [0];
PWM3.timerCount                         = 5000;
PWM3.clockPrescale                      = 80;
PWM3.peripheral.$assign                 = "TIMG7";
PWM3.peripheral.ccp0Pin.$assign         = "PA28";
PWM3.PWM_CHANNEL_0.$name                = "ti_driverlib_pwm_PWMTimerCC4";
PWM3.ccp0PinConfig.$name                = "ti_driverlib_gpio_GPIOPinGeneric4";
PWM3.ccp0PinConfig.direction            = scripting.forceWrite("OUTPUT");
PWM3.ccp0PinConfig.hideOutputInversion  = scripting.forceWrite(false);
PWM3.ccp0PinConfig.onlyInternalResistor = scripting.forceWrite(false);
PWM3.ccp0PinConfig.passedPeripheralType = scripting.forceWrite("Digital");

SYSCTL.forceDefaultClkConfig = true;
SYSCTL.clockTreeEn           = true;

TIMER1.$name              = "Mask_Timer";
TIMER1.timerMode          = "PERIODIC_UP";
TIMER1.timerPeriod        = "10 ms";
TIMER1.timerClkPrescale   = 40;
TIMER1.interrupts         = ["LOAD"];
TIMER1.interruptPriority  = "2";
TIMER1.peripheral.$assign = "TIMG8";

UART1.$name                            = "Debugger_UART";
UART1.enabledInterrupts                = ["RX"];
UART1.targetBaudRate                   = 115200;
UART1.peripheral.$assign               = "UART0";
UART1.peripheral.rxPin.$assign         = "PA11";
UART1.peripheral.txPin.$assign         = "PA10";
UART1.txPinConfig.direction            = scripting.forceWrite("OUTPUT");
UART1.txPinConfig.hideOutputInversion  = scripting.forceWrite(false);
UART1.txPinConfig.onlyInternalResistor = scripting.forceWrite(false);
UART1.txPinConfig.passedPeripheralType = scripting.forceWrite("Digital");
UART1.txPinConfig.$name                = "ti_driverlib_gpio_GPIOPinGeneric5";
UART1.rxPinConfig.hideOutputInversion  = scripting.forceWrite(false);
UART1.rxPinConfig.onlyInternalResistor = scripting.forceWrite(false);
UART1.rxPinConfig.passedPeripheralType = scripting.forceWrite("Digital");
UART1.rxPinConfig.$name                = "ti_driverlib_gpio_GPIOPinGeneric6";

UART2.$name                            = "HWT_UART";
UART2.enabledInterrupts                = ["RX"];
UART2.interruptPriority                = "1";
UART2.peripheral.$assign               = "UART3";
UART2.peripheral.rxPin.$assign         = "PB13";
UART2.peripheral.txPin.$assign         = "PB12";
UART2.txPinConfig.direction            = scripting.forceWrite("OUTPUT");
UART2.txPinConfig.hideOutputInversion  = scripting.forceWrite(false);
UART2.txPinConfig.onlyInternalResistor = scripting.forceWrite(false);
UART2.txPinConfig.passedPeripheralType = scripting.forceWrite("Digital");
UART2.txPinConfig.$name                = "ti_driverlib_gpio_GPIOPinGeneric7";
UART2.rxPinConfig.hideOutputInversion  = scripting.forceWrite(false);
UART2.rxPinConfig.onlyInternalResistor = scripting.forceWrite(false);
UART2.rxPinConfig.passedPeripheralType = scripting.forceWrite("Digital");
UART2.rxPinConfig.$name                = "ti_driverlib_gpio_GPIOPinGeneric8";

UART3.$name                            = "Raspberry_Pi_UART";
UART3.enabledInterrupts                = ["RX"];
UART3.peripheral.$assign               = "UART1";
UART3.peripheral.rxPin.$assign         = "PB5";
UART3.peripheral.txPin.$assign         = "PB4";
UART3.txPinConfig.direction            = scripting.forceWrite("OUTPUT");
UART3.txPinConfig.hideOutputInversion  = scripting.forceWrite(false);
UART3.txPinConfig.onlyInternalResistor = scripting.forceWrite(false);
UART3.txPinConfig.passedPeripheralType = scripting.forceWrite("Digital");
UART3.txPinConfig.$name                = "ti_driverlib_gpio_GPIOPinGeneric9";
UART3.rxPinConfig.hideOutputInversion  = scripting.forceWrite(false);
UART3.rxPinConfig.onlyInternalResistor = scripting.forceWrite(false);
UART3.rxPinConfig.passedPeripheralType = scripting.forceWrite("Digital");
UART3.rxPinConfig.$name                = "ti_driverlib_gpio_GPIOPinGeneric10";

UART4.$name                            = "K230_UART";
UART4.targetBaudRate                   = 115200;
UART4.enabledInterrupts                = ["RX"];
UART4.peripheral.$assign               = "UART2";
UART4.peripheral.rxPin.$assign         = "PB16";
UART4.peripheral.txPin.$assign         = "PB17";
UART4.txPinConfig.direction            = scripting.forceWrite("OUTPUT");
UART4.txPinConfig.hideOutputInversion  = scripting.forceWrite(false);
UART4.txPinConfig.onlyInternalResistor = scripting.forceWrite(false);
UART4.txPinConfig.passedPeripheralType = scripting.forceWrite("Digital");
UART4.txPinConfig.$name                = "ti_driverlib_gpio_GPIOPinGeneric11";
UART4.rxPinConfig.hideOutputInversion  = scripting.forceWrite(false);
UART4.rxPinConfig.onlyInternalResistor = scripting.forceWrite(false);
UART4.rxPinConfig.passedPeripheralType = scripting.forceWrite("Digital");
UART4.rxPinConfig.$name                = "ti_driverlib_gpio_GPIOPinGeneric12";

/**
 * Pinmux solution for unlocked pins/peripherals. This ensures that minor changes to the automatic solver in a future
 * version of the tool will not impact the pinmux you originally saw.  These lines can be completely deleted in order to
 * re-solve from scratch.
 */
Board.peripheral.$suggestSolution          = "DEBUGSS";
Board.peripheral.swclkPin.$suggestSolution = "PA20";
Board.peripheral.swdioPin.$suggestSolution = "PA19";

================
File: HWT101/hwt101_uart.c
================
#include "hwt101_uart.h"

void Uart2Send(unsigned char *p_data, unsigned int uiSize)
{	
   usart_transmit(HWT101_UART,p_data,uiSize);
}

void HWT101_UARTStart(void)
{
   usart_rx_it_start(HWT_UART_INST_INT_IRQN);
}

void HWT_UART_INST_IRQHandler(void)
{
    unsigned char ucTemp = usart_receivebyte(HWT101_UART);
	WitSerialDataIn(ucTemp);
}

================
File: HWT101/hwt101_uart.h
================
#ifndef _HWT101_UART
#define _HWT101_UART

#include "serial.h"
#include "wit_c_sdk.h"
#include "ti_msp_dl_config.h"

#define HWT101_UART HWT_UART_INST
#define Hwt_printf(fmt, ...)  usart_printf(HWT101_UART, fmt, ##__VA_ARGS__)

void HWT101_UARTStart(void);
void Uart2Send(unsigned char *p_data, unsigned int uiSize);


#endif

================
File: HWT101/my_HWT101.c
================
/*
@ Function:
1. Power on automatic detection sensor
2. Read acceleration, angular velocity, angle and magnetic field data
3. Set switching baud rate parameters
*/

#include "my_HWT101.h"

#define ACC_UPDATE		0x01
#define GYRO_UPDATE		0x02
#define ANGLE_UPDATE	0x04
#define MAG_UPDATE		0x08
#define READ_UPDATE		0x80

static volatile char s_cDataUpdate1 = 0,s_cDataUpdate2 = 0,s_cDataUpdate3 = 0,s_cDataUpdate4 = 0, s_cCmd = 0xff;
const uint32_t c_uiBaud[10] = {0, 4800, 9600, 19200, 38400, 57600, 115200, 230400, 460800, 921600};
static void CmdProcess(void);
static void AutoScanSensor(void);
static void SensorUartSend(uint8_t *p_data, uint32_t uiSize);
static void SensorDataUpdata(uint32_t uiReg, uint32_t uiRegNum);
static void Delayms(uint16_t ucMs);

extern uint8_t ucRegIndex;
extern uint16_t usRegDataBuff[4];
extern uint32_t uiRegDataLen;

  

void Myhwt101_init(void)
{
	WitInit(WIT_PROTOCOL_NORMAL, 0x50);
	WitSerialWriteRegister(SensorUartSend);
	WitRegisterCallBack(SensorDataUpdata);
	WitDelayMsRegister(Delayms);
	HWT101_UARTStart();

    delay_ms(2500);
}


void Myhwt101_getdata(IMU *hwt_data)
{
		CopeWitData(ucRegIndex,usRegDataBuff,uiRegDataLen);
		if(s_cDataUpdate1 || s_cDataUpdate2 ||s_cDataUpdate3 ||s_cDataUpdate4)
		{
			for(int i = 0; i < 3; i++)
			{
				hwt_data->fAcc[i] = sReg[AX+i] / 32768.0f * 16.0f;
				hwt_data->fGyro[i] = sReg[GX+i] / 32768.0f * 2000.0f;
				hwt_data->fAngle[i] = sReg[Roll+i] / 32768.0f * 180.0f;
				
             if(i == yaw_id) 
             {
                hwt_data->last_yaw = hwt_data->current_yaw;
                hwt_data->current_yaw = hwt_data->fAngle[yaw_id];

                  static int cnt = 0;
             if(hwt_data->last_yaw < 180 && hwt_data->last_yaw > 160 && hwt_data->current_yaw > -180 && hwt_data->current_yaw < -160){
                cnt ++;
                } 
            else if (hwt_data->current_yaw < 180 && hwt_data->current_yaw > 160 && hwt_data->last_yaw > -180 && hwt_data->last_yaw < -160) {
                 cnt --;
                }
            hwt_data->real_yaw = hwt_data->current_yaw + cnt * 360.0;

} 


			}
			if(s_cDataUpdate1 | ACC_UPDATE)
			{
				s_cDataUpdate1 &= ~ACC_UPDATE;
			}
			if(s_cDataUpdate2 | GYRO_UPDATE)
			{
				s_cDataUpdate2 &= ~GYRO_UPDATE;
			}
			if(s_cDataUpdate3 | ANGLE_UPDATE)
			{
				s_cDataUpdate3 &= ~ANGLE_UPDATE;
			}
			if(s_cDataUpdate4 | MAG_UPDATE)
			{
				s_cDataUpdate4 &= ~MAG_UPDATE;
			}
		}
}


//101z轴置零
void Myhwt101_resetz(IMU *imu)                  
{
   while(imu->zero_yaw == 0.0)
   {
    Myhwt101_getdata(imu);
   imu-> zero_yaw = imu->current_yaw;
   }
}



void CopeCmdData(unsigned char ucData)
{
	static unsigned char s_ucData[50], s_ucRxCnt = 0;
	
	s_ucData[s_ucRxCnt++] = ucData;
	if(s_ucRxCnt<3)return;										//Less than three data returned
	if(s_ucRxCnt >= 50) s_ucRxCnt = 0;
	if(s_ucRxCnt >= 3)
	{
		if((s_ucData[1] == '\r') && (s_ucData[2] == '\n'))
		{
			s_cCmd = s_ucData[0];
			memset(s_ucData,0,50);//
			s_ucRxCnt = 0;
		}
		else 
		{
			s_ucData[0] = s_ucData[1];
			s_ucData[1] = s_ucData[2];
			s_ucRxCnt = 2;
		}
	}

}

static void ShowHelp(void)
{
	printf("\r\n************************	 WIT_SDK_DEMO	************************");
	printf("\r\n************************          HELP           ************************\r\n");
	printf("UART SEND:a\\r\\n   Acceleration calibration.\r\n");
	printf("UART SEND:m\\r\\n   Magnetic field calibration,After calibration send:   e\\r\\n   to indicate the end\r\n");
	printf("UART SEND:U\\r\\n   Bandwidth increase.\r\n");
	printf("UART SEND:u\\r\\n   Bandwidth reduction.\r\n");
	printf("UART SEND:B\\r\\n   Baud rate increased to 115200.\r\n");
	printf("UART SEND:b\\r\\n   Baud rate reduction to 9600.\r\n");
	printf("UART SEND:R\\r\\n   The return rate increases to 10Hz.\r\n");
	printf("UART SEND:r\\r\\n   The return rate reduction to 1Hz.\r\n");
	printf("UART SEND:C\\r\\n   Basic return content: acceleration, angular velocity, angle, magnetic field.\r\n");
	printf("UART SEND:c\\r\\n   Return content: acceleration.\r\n");
	printf("UART SEND:h\\r\\n   help.\r\n");
	printf("******************************************************************************\r\n");
}

static void CmdProcess(void)
{
	switch(s_cCmd)
	{
		case 'a':	
			if(WitStartAccCali() != WIT_HAL_OK) 
				printf("\r\nSet AccCali Error\r\n");
			break;
		case 'm':	
			if(WitStartMagCali() != WIT_HAL_OK) 
				printf("\r\nSet MagCali Error\r\n");
			break;
		case 'e':	
			if(WitStopMagCali() != WIT_HAL_OK)
				printf("\r\nSet MagCali Error\r\n");
			break;
		case 'u':	
			if(WitSetBandwidth(BANDWIDTH_5HZ) != WIT_HAL_OK) 
				printf("\r\nSet Bandwidth Error\r\n");
			break;
		case 'U':	
			if(WitSetBandwidth(BANDWIDTH_256HZ) != WIT_HAL_OK) 
				printf("\r\nSet Bandwidth Error\r\n");
			break;
		case 'B':	
			if(WitSetUartBaud(WIT_BAUD_115200) != WIT_HAL_OK) 
				printf("\r\nSet Baud Error\r\n");
			else 
//				Usart2Init(c_uiBaud[WIT_BAUD_115200]);											
			break;
		case 'b':	
			if(WitSetUartBaud(WIT_BAUD_9600) != WIT_HAL_OK)
				printf("\r\nSet Baud Error\r\n");
			else 
//				Usart2Init(c_uiBaud[WIT_BAUD_9600]);												
			break;
		case 'R':	
			if(WitSetOutputRate(RRATE_10HZ) != WIT_HAL_OK) 
				printf("\r\nSet Rate Error\r\n");
			break;
		case 'r':	
			if(WitSetOutputRate(RRATE_1HZ) != WIT_HAL_OK) 
				printf("\r\nSet Rate Error\r\n");
			break;
		case 'C':	
			if(WitSetContent(RSW_ACC|RSW_GYRO|RSW_ANGLE|RSW_MAG) != WIT_HAL_OK) 
				printf("\r\nSet RSW Error\r\n");
			break;
		case 'c':	
			if(WitSetContent(RSW_ACC) != WIT_HAL_OK) 
				printf("\r\nSet RSW Error\r\n");
			break;
		case 'h':
			ShowHelp();
			break;
	}
	s_cCmd = 0xff;
}

static void SensorUartSend(uint8_t *p_data, uint32_t uiSize)
{
	    Uart2Send(p_data, uiSize);
}

static void Delayms(uint16_t ucMs)
{
	delay_ms(ucMs);
}

static void SensorDataUpdata(uint32_t uiReg, uint32_t uiRegNum)
{
	int i;
    for(i = 0; i < uiRegNum; i++)
    {
        switch(uiReg)
        {
//            case AX:
//            case AY:
            case AZ:
				s_cDataUpdate1 |= ACC_UPDATE;
            break;
//            case GX:
//            case GY:
            case GZ:
				s_cDataUpdate2 |= GYRO_UPDATE;
            break;
//            case HX:
//            case HY:
            case HZ:
				s_cDataUpdate4 |= MAG_UPDATE;
            break;
//            case Roll:
//            case Pitch:
            case Yaw:
				s_cDataUpdate3 |= ANGLE_UPDATE;
            break;
//            default:
//				s_cDataUpdate1 |= READ_UPDATE;
//			break;
        }
		uiReg++;
    }
}

================
File: HWT101/my_HWT101.h
================
#ifndef _MY_HWT101
#define _MY_HWT101

#include "string.h"
#include "stdio.h"
#include "wit_c_sdk.h"
#include "hwt101_uart.h"
#include "my_delay.h"

#define yaw_id 2


typedef struct
{
  	float fAcc[3];
   	float fGyro[3];
	float fAngle[3];

    float current_yaw;
    float last_yaw;
    float real_yaw;

    float zero_yaw;
	
}IMU;

void Myhwt101_init(void);
void Myhwt101_getdata(IMU *hwt_data);
void Myhwt101_resetz(IMU *imu);      


#endif

================
File: HWT101/REG.h
================
#ifndef __AHRSREG_H
#define __AHRSREG_H

#ifdef __cplusplus
extern "C" {
#endif
#define REGSIZE 0x90

#define SAVE 		0x00
#define CALSW 		0x01
#define RSW 		0x02
#define RRATE		0x03
#define BAUD 		0x04
#define AXOFFSET	0x05
#define AYOFFSET	0x06
#define AZOFFSET	0x07
#define GXOFFSET	0x08
#define GYOFFSET	0x09
#define GZOFFSET	0x0a
#define HXOFFSET	0x0b`
#define HYOFFSET	0x0c
#define HZOFFSET	0x0d
#define D0MODE		0x0e
#define D1MODE		0x0f
#define D2MODE		0x10
#define D3MODE		0x11
#define D0PWMH		0x12
#define D1PWMH		0x13
#define D2PWMH		0x14
#define D3PWMH		0x15
#define D0PWMT		0x16
#define D1PWMT		0x17
#define D2PWMT		0x18
#define D3PWMT		0x19
#define IICADDR		0x1a
#define LEDOFF 		0x1b
#define MAGRANGX	0x1c
#define MAGRANGY	0x1d
#define MAGRANGZ	0x1e
#define BANDWIDTH	0x1f
#define GYRORANGE	0x20
#define ACCRANGE	0x21
#define SLEEP       0x22
#define ORIENT		0x23
#define AXIS6       0x24
#define FILTK       0x25
#define GPSBAUD		0x26
#define READADDR	0x27
#define BWSCALE		0x28
#define MOVETHR		0x28
#define MOVESTA		0x29
#define ACCFILT		0x2A
#define GYROFILT	0x2b
#define MAGFILT		0x2c
#define POWONSEND	0x2d
#define VERSION		0x2e
#define CCBW			  0x2f
#define YYMM				0x30
#define DDHH				0x31
#define MMSS				0x32
#define MS					0x33
#define AX					0x34
#define AY					0x35
#define AZ					0x36
#define GX					0x37
#define GY					0x38
#define GZ					0x39
#define HX					0x3a
#define HY					0x3b
#define HZ					0x3c
#define Roll				0x3d
#define Pitch				0x3e
#define Yaw					0x3f
#define TEMP				0x40
#define D0Status		0x41
#define D1Status		0x42
#define D2Status		0x43
#define D3Status		0x44
#define PressureL		0x45
#define PressureH		0x46
#define HeightL			0x47
#define HeightH			0x48
#define LonL				0x49
#define LonH				0x4a
#define LatL				0x4b
#define LatH				0x4c
#define GPSHeight       0x4d
#define GPSYAW          0x4e
#define GPSVL				0x4f
#define GPSVH				0x50
#define q0					0x51
#define q1					0x52
#define q2					0x53
#define q3					0x54
#define SVNUM				0x55
#define PDOP				0x56
#define HDOP				0x57
#define VDOP				0x58
#define DELAYT			0x59
#define XMIN            0x5a
#define XMAX            0x5b
#define BATVAL          0x5c
#define ALARMPIN        0x5d
#define YMIN            0x5e
#define YMAX            0x5f
#define GYROZSCALE		0x60
#define GYROCALITHR     0x61
#define ALARMLEVEL      0x62
#define GYROCALTIME		0x63
#define REFROLL			0x64
#define REFPITCH		0x65
#define REFYAW			0x66
#define GPSTYPE     0x67
#define TRIGTIME    0x68
#define KEY         0x69
#define WERROR      0x6a
#define TIMEZONE    0x6b
#define CALICNT     0x6c
#define WZCNT       0x6d
#define WZTIME      0x6e
#define WZSTATIC    0x6f
#define ACCSENSOR 	0x70
#define GYROSENSOR 	0x71
#define MAGSENSOR 	0x72
#define PRESSENSOR 	0x73
#define MODDELAY    0x74

#define ANGLEAXIS   0x75
#define XRSCALE			0x76    
#define YRSCALE			0x77
#define ZRSCALE			0x78

#define XREFROLL		0x79    
#define YREFPITCH		0x7a
#define ZREFYAW			0x7b

#define ANGXOFFSET		0x7c    
#define ANGYOFFSET		0x7d
#define ANGZOFFSET		0x7e

#define NUMBERID1    0x7f
#define NUMBERID2    0x80
#define NUMBERID3    0x81
#define NUMBERID4    0x82
#define NUMBERID5    0x83
#define NUMBERID6    0x84

#define XA85PSCALE       0x85
#define XA85NSCALE       0x86
#define YA85PSCALE       0x87
#define YA85NSCALE       0x88
#define XA30PSCALE       0x89
#define XA30NSCALE       0x8a
#define YA30PSCALE       0x8b
#define YA30NSCALE       0x8c

#define CHIPIDL     0x8D
#define CHIPIDH     0x8E
#define REGINITFLAG       REGSIZE-1 


/* AXIS6 */
#define ALGRITHM9 0
#define ALGRITHM6 1

/************CALSW**************/
#define NORMAL          0x00
#define CALGYROACC      0x01
#define CALMAG          0x02
#define CALALTITUDE     0x03
#define CALANGLEZ       0x04
#define CALACCL         0x05
#define CALACCR         0x06
#define CALMAGMM        0x07
#define CALREFANGLE		0x08
#define CALMAG2STEP		0x09
//#define CALACCX       0x09
//#define ACC45PRX      0x0A
//#define ACC45NRX      0x0B
//#define CALACCY       0x0C
//#define ACC45PRY      0x0D
//#define ACC45NRY     	0x0E
//#define CALREFANGLER  0x0F
//#define CALACCINIT    0x10
//#define CALREFANGLEINIT 0x11
#define CALHEXAHEDRON		0x12

/************OUTPUTHEAD**************/
#define WIT_TIME        0x50
#define WIT_ACC         0x51
#define WIT_GYRO        0x52
#define WIT_ANGLE       0x53
#define WIT_MAGNETIC    0x54
#define WIT_DPORT       0x55
#define WIT_PRESS       0x56
#define WIT_GPS         0x57
#define WIT_VELOCITY    0x58
#define WIT_QUATER      0x59
#define WIT_GSA         0x5A
#define WIT_REGVALUE    0x5F

/************RSW**************/
#define RSW_TIME 	0x01
#define RSW_ACC		0x02
#define RSW_GYRO	0x04
#define RSW_ANGLE	0x08
#define RSW_MAG		0x10
#define RSW_PORT	0x20
#define RSW_PRESS	0x40
#define RSW_GPS		0x80
#define RSW_V       0x100
#define RSW_Q       0x200
#define	RSW_GSA		0x400
#define RSW_MASK	0xfff

/**RRATE*****/
#define RRATE_NONE	0x0d
#define RRATE_02HZ	0x01
#define RRATE_05HZ	0x02
#define RRATE_1HZ 	0x03
#define RRATE_2HZ 	0x04
#define RRATE_5HZ 	0x05
#define RRATE_10HZ	0x06
#define RRATE_20HZ	0x07
#define RRATE_50HZ	0x08
#define RRATE_100HZ	0x09
#define RRATE_125HZ	0x0a	//only WT931
#define RRATE_200HZ	0x0b
#define RRATE_ONCE 	0x0c

/* BAUD */
#define WIT_BAUD_4800	  1
#define WIT_BAUD_9600	  2
#define WIT_BAUD_19200	  3
#define WIT_BAUD_38400	  4
#define WIT_BAUD_57600	  5
#define WIT_BAUD_115200	  6
#define WIT_BAUD_230400	  7
#define WIT_BAUD_460800	  8
#define WIT_BAUD_921600	  9

/*CAN BAUD*/
#define CAN_BAUD_1000000	 	0
#define CAN_BAUD_800000	  		1
#define CAN_BAUD_500000	  		2
#define CAN_BAUD_400000	  		3
#define CAN_BAUD_250000	  		4
#define CAN_BAUD_200000   		5
#define CAN_BAUD_125000	  		6
#define CAN_BAUD_100000  		7
#define CAN_BAUD_80000	  		8
#define CAN_BAUD_50000  		9
#define CAN_BAUD_40000	  		10
#define CAN_BAUD_20000  		11
#define CAN_BAUD_10000	  		12
#define CAN_BAUD_5000	  		13
#define CAN_BAUD_3000	  		14

/* KEY */
#define KEY_UNLOCK	0xB588

/* SAVE */
#define SAVE_PARAM	0x00
#define SAVE_SWRST	0xFF

/* ORIENT */
#define ORIENT_HERIZONE	0
#define ORIENT_VERTICLE	1

/* BANDWIDTH */
#define BANDWIDTH_256HZ	0
#define BANDWIDTH_184HZ	1
#define BANDWIDTH_94HZ	2
#define BANDWIDTH_44HZ	3
#define BANDWIDTH_21HZ	4
#define BANDWIDTH_10HZ	5
#define BANDWIDTH_5HZ	6


#ifdef __cplusplus
}
#endif

#endif

================
File: HWT101/wit_c_sdk.c
================
#include "wit_c_sdk.h"

static SerialWrite p_WitSerialWriteFunc = NULL;
static WitI2cWrite p_WitI2cWriteFunc = NULL;
static WitI2cRead p_WitI2cReadFunc = NULL;
static CanWrite p_WitCanWriteFunc = NULL;
static RegUpdateCb p_WitRegUpdateCbFunc = NULL;
static DelaymsCb p_WitDelaymsFunc = NULL;

static uint8_t s_ucAddr = 0xff;
static uint8_t s_ucWitDataBuff[WIT_DATA_BUFF_SIZE];
static uint32_t s_uiWitDataCnt = 0, s_uiProtoclo = 0, s_uiReadRegIndex = 0;
int16_t sReg[REGSIZE];

uint8_t ucRegIndex = 0;
uint16_t usRegDataBuff[4] = {0};
uint32_t uiRegDataLen = 0;

#define FuncW 0x06
#define FuncR 0x03

static const uint8_t __auchCRCHi[256] = {
    0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0, 0x80, 0x41, 0x01, 0xC0, 0x80, 0x41, 0x00, 0xC1, 0x81,
    0x40, 0x01, 0xC0, 0x80, 0x41, 0x00, 0xC1, 0x81, 0x40, 0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0,
    0x80, 0x41, 0x01, 0xC0, 0x80, 0x41, 0x00, 0xC1, 0x81, 0x40, 0x00, 0xC1, 0x81, 0x40, 0x01,
    0xC0, 0x80, 0x41, 0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0, 0x80, 0x41, 0x01, 0xC0, 0x80, 0x41,
    0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0, 0x80, 0x41, 0x00, 0xC1, 0x81, 0x40, 0x00, 0xC1, 0x81,
    0x40, 0x01, 0xC0, 0x80, 0x41, 0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0, 0x80, 0x41, 0x01, 0xC0,
    0x80, 0x41, 0x00, 0xC1, 0x81, 0x40, 0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0, 0x80, 0x41, 0x01,
    0xC0, 0x80, 0x41, 0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0, 0x80, 0x41, 0x00, 0xC1, 0x81, 0x40,
    0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0, 0x80, 0x41, 0x01, 0xC0, 0x80, 0x41, 0x00, 0xC1, 0x81,
    0x40, 0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0, 0x80, 0x41, 0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0,
    0x80, 0x41, 0x01, 0xC0, 0x80, 0x41, 0x00, 0xC1, 0x81, 0x40, 0x00, 0xC1, 0x81, 0x40, 0x01,
    0xC0, 0x80, 0x41, 0x01, 0xC0, 0x80, 0x41, 0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0, 0x80, 0x41,
    0x00, 0xC1, 0x81, 0x40, 0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0, 0x80, 0x41, 0x00, 0xC1, 0x81,
    0x40, 0x01, 0xC0, 0x80, 0x41, 0x01, 0xC0, 0x80, 0x41, 0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0,
    0x80, 0x41, 0x00, 0xC1, 0x81, 0x40, 0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0, 0x80, 0x41, 0x01,
    0xC0, 0x80, 0x41, 0x00, 0xC1, 0x81, 0x40, 0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0, 0x80, 0x41,
    0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0, 0x80, 0x41, 0x01, 0xC0, 0x80, 0x41, 0x00, 0xC1, 0x81,
    0x40
};
static const uint8_t __auchCRCLo[256] = {
    0x00, 0xC0, 0xC1, 0x01, 0xC3, 0x03, 0x02, 0xC2, 0xC6, 0x06, 0x07, 0xC7, 0x05, 0xC5, 0xC4,
    0x04, 0xCC, 0x0C, 0x0D, 0xCD, 0x0F, 0xCF, 0xCE, 0x0E, 0x0A, 0xCA, 0xCB, 0x0B, 0xC9, 0x09,
    0x08, 0xC8, 0xD8, 0x18, 0x19, 0xD9, 0x1B, 0xDB, 0xDA, 0x1A, 0x1E, 0xDE, 0xDF, 0x1F, 0xDD,
    0x1D, 0x1C, 0xDC, 0x14, 0xD4, 0xD5, 0x15, 0xD7, 0x17, 0x16, 0xD6, 0xD2, 0x12, 0x13, 0xD3,
    0x11, 0xD1, 0xD0, 0x10, 0xF0, 0x30, 0x31, 0xF1, 0x33, 0xF3, 0xF2, 0x32, 0x36, 0xF6, 0xF7,
    0x37, 0xF5, 0x35, 0x34, 0xF4, 0x3C, 0xFC, 0xFD, 0x3D, 0xFF, 0x3F, 0x3E, 0xFE, 0xFA, 0x3A,
    0x3B, 0xFB, 0x39, 0xF9, 0xF8, 0x38, 0x28, 0xE8, 0xE9, 0x29, 0xEB, 0x2B, 0x2A, 0xEA, 0xEE,
    0x2E, 0x2F, 0xEF, 0x2D, 0xED, 0xEC, 0x2C, 0xE4, 0x24, 0x25, 0xE5, 0x27, 0xE7, 0xE6, 0x26,
    0x22, 0xE2, 0xE3, 0x23, 0xE1, 0x21, 0x20, 0xE0, 0xA0, 0x60, 0x61, 0xA1, 0x63, 0xA3, 0xA2,
    0x62, 0x66, 0xA6, 0xA7, 0x67, 0xA5, 0x65, 0x64, 0xA4, 0x6C, 0xAC, 0xAD, 0x6D, 0xAF, 0x6F,
    0x6E, 0xAE, 0xAA, 0x6A, 0x6B, 0xAB, 0x69, 0xA9, 0xA8, 0x68, 0x78, 0xB8, 0xB9, 0x79, 0xBB,
    0x7B, 0x7A, 0xBA, 0xBE, 0x7E, 0x7F, 0xBF, 0x7D, 0xBD, 0xBC, 0x7C, 0xB4, 0x74, 0x75, 0xB5,
    0x77, 0xB7, 0xB6, 0x76, 0x72, 0xB2, 0xB3, 0x73, 0xB1, 0x71, 0x70, 0xB0, 0x50, 0x90, 0x91,
    0x51, 0x93, 0x53, 0x52, 0x92, 0x96, 0x56, 0x57, 0x97, 0x55, 0x95, 0x94, 0x54, 0x9C, 0x5C,
    0x5D, 0x9D, 0x5F, 0x9F, 0x9E, 0x5E, 0x5A, 0x9A, 0x9B, 0x5B, 0x99, 0x59, 0x58, 0x98, 0x88,
    0x48, 0x49, 0x89, 0x4B, 0x8B, 0x8A, 0x4A, 0x4E, 0x8E, 0x8F, 0x4F, 0x8D, 0x4D, 0x4C, 0x8C,
    0x44, 0x84, 0x85, 0x45, 0x87, 0x47, 0x46, 0x86, 0x82, 0x42, 0x43, 0x83, 0x41, 0x81, 0x80,
    0x40
};


static uint16_t __CRC16(uint8_t *puchMsg, uint16_t usDataLen)
{
    uint8_t uchCRCHi = 0xFF;
    uint8_t uchCRCLo = 0xFF;
    uint8_t uIndex;
    int i = 0;
    uchCRCHi = 0xFF;
    uchCRCLo = 0xFF;
    for (; i<usDataLen; i++)
    {
        uIndex = uchCRCHi ^ puchMsg[i];
        uchCRCHi = uchCRCLo ^ __auchCRCHi[uIndex];
        uchCRCLo = __auchCRCLo[uIndex] ;
    }
    return (uint16_t)(((uint16_t)uchCRCHi << 8) | (uint16_t)uchCRCLo) ;
}
static uint8_t __CaliSum(uint8_t *data, uint32_t len)
{
    uint32_t i;
    uint8_t ucCheck = 0;
    for(i=0; i<len; i++) ucCheck += *(data + i);
    return ucCheck;
}
int32_t WitSerialWriteRegister(SerialWrite Write_func)
{
    if(!Write_func)return WIT_HAL_INVAL;
    p_WitSerialWriteFunc = Write_func;
    return WIT_HAL_OK;
}
void CopeWitData(uint8_t ucIndex, uint16_t *p_data, uint32_t uiLen)
{
    uint32_t uiReg1 = 0, uiReg2 = 0, uiReg1Len = 0, uiReg2Len = 0;
    uint16_t *p_usReg1Val = p_data;
    uint16_t *p_usReg2Val = p_data+3;
    
    uiReg1Len = 4;
    switch(ucIndex)
    {
        case WIT_ACC:   uiReg1 = AX;    uiReg1Len = 3;  uiReg2 = TEMP;  uiReg2Len = 1;  break;
        case WIT_ANGLE: uiReg1 = Roll;  uiReg1Len = 3;  uiReg2 = VERSION;  uiReg2Len = 1;  break;
        case WIT_TIME:  uiReg1 = YYMM;	break;
        case WIT_GYRO:  uiReg1 = GX;  uiLen = 3;break;
        case WIT_MAGNETIC: uiReg1 = HX;  uiLen = 3;break;
        case WIT_DPORT: uiReg1 = D0Status;  break;
        case WIT_PRESS: uiReg1 = PressureL;  break;
        case WIT_GPS:   uiReg1 = LonL;  break;
        case WIT_VELOCITY: uiReg1 = GPSHeight;  break;
        case WIT_QUATER:    uiReg1 = q0;  break;
        case WIT_GSA:   uiReg1 = SVNUM;  break;
        case WIT_REGVALUE:  uiReg1 = s_uiReadRegIndex;  break;
		default:
			return ;

    }
    if(uiLen == 3)
    {
        uiReg1Len = 3;
        uiReg2Len = 0;
    }
    if(uiReg1Len)
	{
		memcpy(&sReg[uiReg1], p_usReg1Val, uiReg1Len<<1);
		p_WitRegUpdateCbFunc(uiReg1, uiReg1Len);
	}
    if(uiReg2Len)
	{
		memcpy(&sReg[uiReg2], p_usReg2Val, uiReg2Len<<1);
		p_WitRegUpdateCbFunc(uiReg2, uiReg2Len);
	}
}

void WitSerialDataIn(uint8_t ucData)
{
    uint16_t usCRC16, usTemp, i, usData[4];
    uint8_t ucSum;

    if(p_WitRegUpdateCbFunc == NULL)return ;
    s_ucWitDataBuff[s_uiWitDataCnt++] = ucData;
    switch(s_uiProtoclo)
    {
        case WIT_PROTOCOL_NORMAL:
            if(s_ucWitDataBuff[0] != 0x55)
            {
                s_uiWitDataCnt--;
                memcpy(s_ucWitDataBuff, &s_ucWitDataBuff[1], s_uiWitDataCnt);
                return ;
            }
            if(s_uiWitDataCnt >= 11)
            {
                ucSum = __CaliSum(s_ucWitDataBuff, 10);
                if(ucSum != s_ucWitDataBuff[10])
                {
                    s_uiWitDataCnt--;
                    memcpy(s_ucWitDataBuff, &s_ucWitDataBuff[1], s_uiWitDataCnt);
                    return ;
                }
                usData[0] = ((uint16_t)s_ucWitDataBuff[3] << 8) | (uint16_t)s_ucWitDataBuff[2];
                usData[1] = ((uint16_t)s_ucWitDataBuff[5] << 8) | (uint16_t)s_ucWitDataBuff[4];
                usData[2] = ((uint16_t)s_ucWitDataBuff[7] << 8) | (uint16_t)s_ucWitDataBuff[6];
                usData[3] = ((uint16_t)s_ucWitDataBuff[9] << 8) | (uint16_t)s_ucWitDataBuff[8];
//                CopeWitData(s_ucWitDataBuff[1], usData, 4);
                s_uiWitDataCnt = 0;
								ucRegIndex = s_ucWitDataBuff[1];
								memcpy(usRegDataBuff,usData,8);
								uiRegDataLen = 4;
            }
        break;
        case WIT_PROTOCOL_MODBUS:
            if(s_uiWitDataCnt > 2)
            {
                if(s_ucWitDataBuff[1] != FuncR)
                {
                    s_uiWitDataCnt--;
                    memcpy(s_ucWitDataBuff, &s_ucWitDataBuff[1], s_uiWitDataCnt);
                    return ;
                }
                if(s_uiWitDataCnt < (s_ucWitDataBuff[2] + 5))return ;
                usTemp = ((uint16_t)s_ucWitDataBuff[s_uiWitDataCnt-2] << 8) | s_ucWitDataBuff[s_uiWitDataCnt-1];
                usCRC16 = __CRC16(s_ucWitDataBuff, s_uiWitDataCnt-2);
                if(usTemp != usCRC16)
                {
                    s_uiWitDataCnt--;
                    memcpy(s_ucWitDataBuff, &s_ucWitDataBuff[1], s_uiWitDataCnt);
                    return ;
                }
                usTemp = s_ucWitDataBuff[2] >> 1;
                for(i = 0; i < usTemp; i++)
                {
                    sReg[i+s_uiReadRegIndex] = ((uint16_t)s_ucWitDataBuff[(i<<1)+3] << 8) | s_ucWitDataBuff[(i<<1)+4];
                }
                p_WitRegUpdateCbFunc(s_uiReadRegIndex, usTemp);
                s_uiWitDataCnt = 0;
            }
        break;
        case WIT_PROTOCOL_CAN:
        case WIT_PROTOCOL_I2C:
        s_uiWitDataCnt = 0;
        break;
    }
    if(s_uiWitDataCnt == WIT_DATA_BUFF_SIZE)s_uiWitDataCnt = 0;
}
int32_t WitI2cFuncRegister(WitI2cWrite write_func, WitI2cRead read_func)
{
    if(!write_func)return WIT_HAL_INVAL;
    if(!read_func)return WIT_HAL_INVAL;
    p_WitI2cWriteFunc = write_func;
    p_WitI2cReadFunc = read_func;
    return WIT_HAL_OK;
}
int32_t WitCanWriteRegister(CanWrite Write_func)
{
    if(!Write_func)return WIT_HAL_INVAL;
    p_WitCanWriteFunc = Write_func;
    return WIT_HAL_OK;
}
void WitCanDataIn(uint8_t ucData[8], uint8_t ucLen)
{
	uint16_t usData[3];
    if(p_WitRegUpdateCbFunc == NULL)return ;
    if(ucLen < 8)return ;
    switch(s_uiProtoclo)
    {
        case WIT_PROTOCOL_CAN:
            if(ucData[0] != 0x55)return ;
            usData[0] = ((uint16_t)ucData[3] << 8) | ucData[2];
            usData[1] = ((uint16_t)ucData[5] << 8) | ucData[4];
            usData[2] = ((uint16_t)ucData[7] << 8) | ucData[6];
            CopeWitData(ucData[1], usData, 3);
            break;
        case WIT_PROTOCOL_NORMAL:
        case WIT_PROTOCOL_MODBUS:
        case WIT_PROTOCOL_I2C:
            break;
    }
}
int32_t WitRegisterCallBack(RegUpdateCb update_func)
{
    if(!update_func)return WIT_HAL_INVAL;
    p_WitRegUpdateCbFunc = update_func;
    return WIT_HAL_OK;
}
int32_t WitWriteReg(uint32_t uiReg, uint16_t usData)
{
    uint16_t usCRC;
    uint8_t ucBuff[8];
    if(uiReg >= REGSIZE)return WIT_HAL_INVAL;
    switch(s_uiProtoclo)
    {
        case WIT_PROTOCOL_NORMAL:
            if(p_WitSerialWriteFunc == NULL)return WIT_HAL_EMPTY;
            ucBuff[0] = 0xFF;
            ucBuff[1] = 0xAA;
            ucBuff[2] = uiReg & 0xFF;
            ucBuff[3] = usData & 0xff;
            ucBuff[4] = usData >> 8;
            p_WitSerialWriteFunc(ucBuff, 5);
            break;
        case WIT_PROTOCOL_MODBUS:
            if(p_WitSerialWriteFunc == NULL)return WIT_HAL_EMPTY;
            ucBuff[0] = s_ucAddr;
            ucBuff[1] = FuncW;
            ucBuff[2] = uiReg >> 8;
            ucBuff[3] = uiReg & 0xFF;
            ucBuff[4] = usData >> 8;
            ucBuff[5] = usData & 0xff;
            usCRC = __CRC16(ucBuff, 6);
            ucBuff[6] = usCRC >> 8;
            ucBuff[7] = usCRC & 0xff;
            p_WitSerialWriteFunc(ucBuff, 8);
            break;
        case WIT_PROTOCOL_CAN:
            if(p_WitCanWriteFunc == NULL)return WIT_HAL_EMPTY;
            ucBuff[0] = 0xFF;
            ucBuff[1] = 0xAA;
            ucBuff[2] = uiReg & 0xFF;
            ucBuff[3] = usData & 0xff;
            ucBuff[4] = usData >> 8;
            p_WitCanWriteFunc(s_ucAddr, ucBuff, 5);
            break;
        case WIT_PROTOCOL_I2C:
            if(p_WitI2cWriteFunc == NULL)return WIT_HAL_EMPTY;
            ucBuff[0] = usData & 0xff;
            ucBuff[1] = usData >> 8;
			if(p_WitI2cWriteFunc(s_ucAddr << 1, uiReg, ucBuff, 2) != 1)
			{
				//printf("i2c write fail\r\n");
			}
        break;
	default: 
            return WIT_HAL_INVAL;        
    }
    return WIT_HAL_OK;
}
int32_t WitReadReg(uint32_t uiReg, uint32_t uiReadNum)
{
    uint16_t usTemp, i;
    uint8_t ucBuff[8];
    if((uiReg + uiReadNum) >= REGSIZE)return WIT_HAL_INVAL;
    switch(s_uiProtoclo)
    {
        case WIT_PROTOCOL_NORMAL:
            if(uiReadNum > 4)return WIT_HAL_INVAL;
            if(p_WitSerialWriteFunc == NULL)return WIT_HAL_EMPTY;
            ucBuff[0] = 0xFF;
            ucBuff[1] = 0xAA;
            ucBuff[2] = 0x27;
            ucBuff[3] = uiReg & 0xff;
            ucBuff[4] = uiReg >> 8;
            p_WitSerialWriteFunc(ucBuff, 5);
            break;
        case WIT_PROTOCOL_MODBUS:
            if(p_WitSerialWriteFunc == NULL)return WIT_HAL_EMPTY;
            usTemp = uiReadNum << 1;
            if((usTemp + 5) > WIT_DATA_BUFF_SIZE)return WIT_HAL_NOMEM;
            ucBuff[0] = s_ucAddr;
            ucBuff[1] = FuncR;
            ucBuff[2] = uiReg >> 8;
            ucBuff[3] = uiReg & 0xFF;
            ucBuff[4] = uiReadNum >> 8;
            ucBuff[5] = uiReadNum & 0xff;
            usTemp = __CRC16(ucBuff, 6);
            ucBuff[6] = usTemp >> 8;
            ucBuff[7] = usTemp & 0xff;
            p_WitSerialWriteFunc(ucBuff, 8);
            break;
        case WIT_PROTOCOL_CAN:
            if(uiReadNum > 3)return WIT_HAL_INVAL;
            if(p_WitCanWriteFunc == NULL)return WIT_HAL_EMPTY;
            ucBuff[0] = 0xFF;
            ucBuff[1] = 0xAA;
            ucBuff[2] = 0x27;
            ucBuff[3] = uiReg & 0xff;
            ucBuff[4] = uiReg >> 8;
            p_WitCanWriteFunc(s_ucAddr, ucBuff, 5);
            break;
        case WIT_PROTOCOL_I2C:
            if(p_WitI2cReadFunc == NULL)return WIT_HAL_EMPTY;
            usTemp = uiReadNum << 1;
            if(WIT_DATA_BUFF_SIZE < usTemp)return WIT_HAL_NOMEM;
            if(p_WitI2cReadFunc(s_ucAddr << 1, uiReg, s_ucWitDataBuff, usTemp) == 1)
            {
                if(p_WitRegUpdateCbFunc == NULL)return WIT_HAL_EMPTY;
                for(i = 0; i < uiReadNum; i++)
                {
                    sReg[i+uiReg] = ((uint16_t)s_ucWitDataBuff[(i<<1)+1] << 8) | s_ucWitDataBuff[i<<1];
                }
                p_WitRegUpdateCbFunc(uiReg, uiReadNum);
            }
			
            break;
		default: 
            return WIT_HAL_INVAL;
    }
    s_uiReadRegIndex = uiReg;

    return WIT_HAL_OK;
}
int32_t WitInit(uint32_t uiProtocol, uint8_t ucAddr)
{
	if(uiProtocol > WIT_PROTOCOL_I2C)return WIT_HAL_INVAL;
    s_uiProtoclo = uiProtocol;
    s_ucAddr = ucAddr;
    s_uiWitDataCnt = 0;
    return WIT_HAL_OK;
}
void WitDeInit(void)
{
    p_WitSerialWriteFunc = NULL;
    p_WitI2cWriteFunc = NULL;
    p_WitI2cReadFunc = NULL;
    p_WitCanWriteFunc = NULL;
    p_WitRegUpdateCbFunc = NULL;
    s_ucAddr = 0xff;
    s_uiWitDataCnt = 0;
    s_uiProtoclo = 0;
}

int32_t WitDelayMsRegister(DelaymsCb delayms_func)
{
    if(!delayms_func)return WIT_HAL_INVAL;
    p_WitDelaymsFunc = delayms_func;
    return WIT_HAL_OK;
}

char CheckRange(short sTemp,short sMin,short sMax)
{
    if ((sTemp>=sMin)&&(sTemp<=sMax)) return 1;
    else return 0;
}
/*Acceleration calibration demo*/
int32_t WitStartAccCali(void)
{
/*
	First place the equipment horizontally, and then perform the following operations
*/
	if(WitWriteReg(KEY, KEY_UNLOCK) != WIT_HAL_OK)	    return  WIT_HAL_ERROR;// unlock reg
	if(s_uiProtoclo == WIT_PROTOCOL_MODBUS)	p_WitDelaymsFunc(20);
	else if(s_uiProtoclo == WIT_PROTOCOL_NORMAL) p_WitDelaymsFunc(1);
	else ;
	if(WitWriteReg(CALSW, CALGYROACC) != WIT_HAL_OK)	return  WIT_HAL_ERROR;
	return WIT_HAL_OK;
}
int32_t WitStopAccCali(void)
{
	if(WitWriteReg(CALSW, NORMAL) != WIT_HAL_OK)	return  WIT_HAL_ERROR;
	if(s_uiProtoclo == WIT_PROTOCOL_MODBUS)	p_WitDelaymsFunc(20);
	else if(s_uiProtoclo == WIT_PROTOCOL_NORMAL) p_WitDelaymsFunc(1);
	else ;
	if(WitWriteReg(SAVE, SAVE_PARAM) != WIT_HAL_OK)	return  WIT_HAL_ERROR;
	return WIT_HAL_OK;
}
/*Magnetic field calibration*/
int32_t WitStartMagCali(void)
{
	if(WitWriteReg(KEY, KEY_UNLOCK) != WIT_HAL_OK)	return  WIT_HAL_ERROR;
	if(s_uiProtoclo == WIT_PROTOCOL_MODBUS)	p_WitDelaymsFunc(20);
	else if(s_uiProtoclo == WIT_PROTOCOL_NORMAL) p_WitDelaymsFunc(1);
	else ;
	if(WitWriteReg(CALSW, CALMAGMM) != WIT_HAL_OK)	return  WIT_HAL_ERROR;
	return WIT_HAL_OK;
}
int32_t WitStopMagCali(void)
{
	if(WitWriteReg(KEY, KEY_UNLOCK) != WIT_HAL_OK)	return  WIT_HAL_ERROR;
	if(s_uiProtoclo == WIT_PROTOCOL_MODBUS)	p_WitDelaymsFunc(20);
	else if(s_uiProtoclo == WIT_PROTOCOL_NORMAL) p_WitDelaymsFunc(1);
	else ;
	if(WitWriteReg(CALSW, NORMAL) != WIT_HAL_OK)	return  WIT_HAL_ERROR;
	return WIT_HAL_OK;
}
/*change Band*/
int32_t WitSetUartBaud(int32_t uiBaudIndex)
{
	if(!CheckRange(uiBaudIndex,WIT_BAUD_4800,WIT_BAUD_230400))
	{
		return WIT_HAL_INVAL;
	}
	if(WitWriteReg(KEY, KEY_UNLOCK) != WIT_HAL_OK)	return  WIT_HAL_ERROR;
	if(s_uiProtoclo == WIT_PROTOCOL_MODBUS)	p_WitDelaymsFunc(20);
	else if(s_uiProtoclo == WIT_PROTOCOL_NORMAL) p_WitDelaymsFunc(1);
	else ;
	if(WitWriteReg(BAUD, uiBaudIndex) != WIT_HAL_OK)	return  WIT_HAL_ERROR;
	return WIT_HAL_OK;
}
/*change Can Band*/
int32_t WitSetCanBaud(int32_t uiBaudIndex)
{
	if(!CheckRange(uiBaudIndex,CAN_BAUD_1000000,CAN_BAUD_3000))
	{
		return WIT_HAL_INVAL;
	}
	if(WitWriteReg(KEY, KEY_UNLOCK) != WIT_HAL_OK)	return  WIT_HAL_ERROR;
	if(s_uiProtoclo == WIT_PROTOCOL_MODBUS)	p_WitDelaymsFunc(20);
	else if(s_uiProtoclo == WIT_PROTOCOL_NORMAL) p_WitDelaymsFunc(1);
	else ;
	if(WitWriteReg(BAUD, uiBaudIndex) != WIT_HAL_OK)	return  WIT_HAL_ERROR;
	return WIT_HAL_OK;
}
/*change Bandwidth*/
int32_t WitSetBandwidth(int32_t uiBaudWidth)
{	
	if(!CheckRange(uiBaudWidth,BANDWIDTH_256HZ,BANDWIDTH_5HZ))
	{
		return WIT_HAL_INVAL;
	}
	if(WitWriteReg(KEY, KEY_UNLOCK) != WIT_HAL_OK)	return  WIT_HAL_ERROR;
	if(s_uiProtoclo == WIT_PROTOCOL_MODBUS)	p_WitDelaymsFunc(20);
	else if(s_uiProtoclo == WIT_PROTOCOL_NORMAL) p_WitDelaymsFunc(1);
	else ;
	if(WitWriteReg(BANDWIDTH, uiBaudWidth) != WIT_HAL_OK)	return  WIT_HAL_ERROR;
	return WIT_HAL_OK;
}

/*change output rate */
int32_t WitSetOutputRate(int32_t uiRate)
{	
	if(!CheckRange(uiRate,RRATE_02HZ,RRATE_NONE))
	{
		return WIT_HAL_INVAL;
	}
	if(WitWriteReg(KEY, KEY_UNLOCK) != WIT_HAL_OK)	return  WIT_HAL_ERROR;
	if(s_uiProtoclo == WIT_PROTOCOL_MODBUS)	p_WitDelaymsFunc(20);
	else if(s_uiProtoclo == WIT_PROTOCOL_NORMAL) p_WitDelaymsFunc(1);
	else ;
	if(WitWriteReg(RRATE, uiRate) != WIT_HAL_OK)	return  WIT_HAL_ERROR;
	return WIT_HAL_OK;
}

/*change WitSetContent */
int32_t WitSetContent(int32_t uiRsw)
{	
	if(!CheckRange(uiRsw,RSW_TIME,RSW_MASK))
	{
		return WIT_HAL_INVAL;
	}
	if(WitWriteReg(KEY, KEY_UNLOCK) != WIT_HAL_OK)	return  WIT_HAL_ERROR;
	if(s_uiProtoclo == WIT_PROTOCOL_MODBUS)	p_WitDelaymsFunc(20);
	else if(s_uiProtoclo == WIT_PROTOCOL_NORMAL) p_WitDelaymsFunc(1);
	else ;
	if(WitWriteReg(RSW, uiRsw) != WIT_HAL_OK)	return  WIT_HAL_ERROR;
	return WIT_HAL_OK;
}

================
File: HWT101/wit_c_sdk.h
================
#ifndef __WIT_C_SDK_H
#define __WIT_C_SDK_H

#ifdef __cplusplus
extern "C" {
#endif

#include <stdint.h>
#include <stdio.h>
#include <string.h>
#include "REG.h"


#define WIT_HAL_OK      (0)     /**< There is no error */
#define WIT_HAL_BUSY    (-1)    /**< Busy */
#define WIT_HAL_TIMEOUT (-2)    /**< Timed out */
#define WIT_HAL_ERROR   (-3)    /**< A generic error happens */
#define WIT_HAL_NOMEM   (-4)    /**< No memory */
#define WIT_HAL_EMPTY   (-5)    /**< The resource is empty */
#define WIT_HAL_INVAL   (-6)    /**< Invalid argument */

#define WIT_DATA_BUFF_SIZE  256

#define WIT_PROTOCOL_NORMAL 0
#define WIT_PROTOCOL_MODBUS 1
#define WIT_PROTOCOL_CAN    2
#define WIT_PROTOCOL_I2C    3


/* serial function */
void CopeWitData(uint8_t ucIndex, uint16_t *p_data, uint32_t uiLen);
typedef void (*SerialWrite)(uint8_t *p_ucData, uint32_t uiLen);
int32_t WitSerialWriteRegister(SerialWrite write_func);
void WitSerialDataIn(uint8_t ucData);

/* iic function */

/*
    i2c write function example

    int32_t WitI2cWrite(uint8_t ucAddr, uint8_t ucReg, uint8_t *p_ucVal, uint32_t uiLen)
    {
        i2c_start();
        i2c_send(ucAddr);
        if(i2c_wait_ask() != SUCCESS)return 0;
        i2c_send(ucReg);
        if(i2c_wait_ask() != SUCCESS)return 0;
        for(uint32_t i = 0; i < uiLen; i++)
        {
            i2c_send(*p_ucVal++); 
            if(i2c_wait_ask() != SUCCESS)return 0;
        }
        i2c_stop();
        return 1;
    }
*/
typedef int32_t (*WitI2cWrite)(uint8_t ucAddr, uint8_t ucReg, uint8_t *p_ucVal, uint32_t uiLen);
/*
    i2c read function example

    int32_t WitI2cRead(uint8_t ucAddr, uint8_t ucReg, uint8_t *p_ucVal, uint32_t uiLen)
    {
        i2c_start();
        i2c_send(ucAddr);
        if(i2c_wait_ask() != SUCCESS)return 0;
        i2c_send(ucReg);
        if(i2c_wait_ask() != SUCCESS)return 0;
        
        i2c_start();
        i2c_send(ucAddr+1);
        for(uint32_t i = 0; i < uiLen; i++)
        {
            if(i+1 == uiLen)*p_ucVal++ = i2c_read(0);  //last byte no ask
            else *p_ucVal++ = i2c_read(1);  //  ask
        }
        i2c_stop();
        return 1;
    }
*/
typedef int32_t (*WitI2cRead)(uint8_t ucAddr, uint8_t ucReg, uint8_t *p_ucVal, uint32_t uiLen);
int32_t WitI2cFuncRegister(WitI2cWrite write_func, WitI2cRead read_func);

/* can function */
typedef void (*CanWrite)(uint8_t ucStdId, uint8_t *p_ucData, uint32_t uiLen);
int32_t WitCanWriteRegister(CanWrite write_func);

/* Delayms function */
typedef void (*DelaymsCb)(uint16_t ucMs);
int32_t WitDelayMsRegister(DelaymsCb delayms_func);


void WitCanDataIn(uint8_t ucData[8], uint8_t ucLen);


typedef void (*RegUpdateCb)(uint32_t uiReg, uint32_t uiRegNum);
int32_t WitRegisterCallBack(RegUpdateCb update_func);
int32_t WitWriteReg(uint32_t uiReg, uint16_t usData);
int32_t WitReadReg(uint32_t uiReg, uint32_t uiReadNum);
int32_t WitInit(uint32_t uiProtocol, uint8_t ucAddr);
void WitDeInit(void);



/**
  ******************************************************************************
  * @file    wit_c_sdk.h
  * @author  Wit
  * @version V1.0
  * @date    05-May-2022
  * @brief   This file provides all Configure sensor function.
  ******************************************************************************
  * @attention
  *
  *        http://wit-motion.cn/
  *
  ******************************************************************************
  */
int32_t WitStartAccCali(void);
int32_t WitStopAccCali(void);
int32_t WitStartMagCali(void);
int32_t WitStopMagCali(void);
int32_t WitSetUartBaud(int32_t uiBaudIndex);
int32_t WitSetBandwidth(int32_t uiBaudWidth);
int32_t WitSetOutputRate(int32_t uiRate);
int32_t WitSetContent(int32_t uiRsw);
int32_t WitSetCanBaud(int32_t uiBaudIndex);

char CheckRange(short sTemp,short sMin,short sMax);

extern int16_t sReg[REGSIZE];

#ifdef __cplusplus
}
#endif

#endif /* __WIT_C_SDK_H */

================
File: json指令集.txt
================
最开始
主：{"cmd":"mode","park":"A"/"B","target":1(远)/0(近)}
从：{"cmd":"mode","result":"ok"}


主车等待从车到位
主：{"cmd":"run"}
从： {"cmd":"run","parked":1} //到位

从车等待主车发送启动命令
主车:{"cmd":"start"}

================
File: K210/K210_uart.c
================
#include "K210_uart.h"

#define BUFFER_SIZE 1000
unsigned char k210_cmd_buffer[BUFFER_SIZE]; //命令缓冲区
char k210_cmd[1000];


//树莓派串口中断初始化
void K210_uartinit(void)
{
   usart_rx_it_start(Debugger_UART_INST_INT_IRQN);
}

void Debugger_UART_INST_IRQHandler(void)
{
			static int i = 0;
            uint8_t k210_uctemp = usart_receivebyte(K210_UART);

	  if (k210_uctemp != '\n' && i < BUFFER_SIZE - 1) {
            k210_cmd_buffer[i++] = k210_uctemp;
        }
		 
	 else 
		{
			k210_cmd_buffer[i] = '\0'; // 完成字符串
			i = 0; // 重置索引
			
		   cJSON *json = cJSON_Parse((char *)k210_cmd_buffer);
		
		  if (json) {
				 cJSON *json_command = cJSON_GetObjectItem(json, "cmd");
		
			   if (json_command && json_command->type == cJSON_String) 
	  			{
             strcpy(k210_cmd, json_command->valuestring); // 更新全局变量cmd
  				if(strcmp(k210_cmd,"num") == 0)
				 {
                    cJSON *num_json = cJSON_GetObjectItem(json, "result");
					char num_str[6];
					strcpy(num_str, num_json->valuestring);
					//将拿到的数字 一位一位存进num[6]
					int num[6] = {0, 0, 0, 0, 0, 0};
					int len = strlen(num_str);
					for (int i = 0; i < 6; i++) {
                        if (i < len)
                            num[i] = num_str[i] - '0'; // 字符转数字
                        else
							num[i] = 0; // 超出部分清0
					}

                 //对数组num[6]进行排序从大到小
                    for (int j = 0; j < 6 - 1; j++) {
                        for (int k = 0; k < 6 - j - 1; k++) {
                            if (num[k] < num[k + 1]) {
                                int temp = num[k];
                                num[k] = num[k + 1];
                                num[k + 1] = temp;
                            }
                        }
                    }

                    K210_numdataIN(num);
				}


				memset(k210_cmd_buffer,'\0',sizeof(k210_cmd_buffer));
				memset(k210_cmd,'\0',sizeof(k210_cmd));
		     }
        }
	      cJSON_Delete(json);	
      }
}

================
File: K210/K210_uart.h
================
#ifndef _K210_UART_H 
#define _K210_UART_H

#include "serial.h"
#include "cJSON.h"
#include "string.h"
#include "stdio.h"
#include "stdlib.h"
#include "K210.h"
#include "ti_msp_dl_config.h"

#define K210_UART  Debugger_UART_INST
#define K210_printf(fmt, ...)  usart_printf(K210_UART, fmt, ##__VA_ARGS__)

void K210_uartinit(void);


#endif

================
File: K210/K210.c
================
#include "K210.h"

//树莓派缓存区
static K210 k210_temp;

void K210_numstatusIN(int status)
{
    k210_temp.status.numstatus = status;
}

void K210_getnumstatus(K210 *k210)
{
    k210->status.numstatus = k210_temp.status.numstatus;
}

void K210_numdataIN(int *num)
{
    k210_temp.num[0] = num[0];
    k210_temp.num[1] = num[1];
    k210_temp.num[2] = num[2];
    k210_temp.num[3] = num[3];
    k210_temp.num[4] = num[4];
    k210_temp.num[5] = num[5];
}

void K210_getnumdata(K210 *k210)
{
    k210->num[0] = k210_temp.num[0];
    k210->num[1] = k210_temp.num[1];
    k210->num[2] = k210_temp.num[2];
    k210->num[3] = k210_temp.num[3];
    k210->num[4] = k210_temp.num[4];
    k210->num[5] = k210_temp.num[5];
}

================
File: K210/K210.h
================
#ifndef _K210_H
#define _K210_H

#include "string.h"

typedef struct
{
   int numstatus;
}K210_STATUS;

typedef struct
{
    volatile int num[6];
	volatile K210_STATUS status;
}K210;

// void K210_getnumstatus(K210 *k210);
// void K210_numstatusIN(int status);
void K210_numdataIN(int *num);
void K210_getnumdata(K210 *k210);


#endif

================
File: K230/K230_uart.c
================
#include "K230_uart.h"

#define BUFFER_SIZE 1000
unsigned char k230_cmd_buffer[BUFFER_SIZE]; //命令缓冲区


//树莓派串口中断初始化
void K230_uartinit(void)
{
   usart_rx_it_start(K230_UART_INST_INT_IRQN);
}

void K230_UART_INST_IRQHandler(void)
{
			static int i = 0;
            uint8_t k230_uctemp = usart_receivebyte(K230_UART);

	  if (k230_uctemp != '\n' && i < BUFFER_SIZE - 1) {
            k230_cmd_buffer[i++] = k230_uctemp;
        }
		 
	 else 
		{
			k230_cmd_buffer[i] = '\0'; // 完成字符串
			i = 0; // 重置索引
			
		   cJSON *json = cJSON_Parse((char *)k230_cmd_buffer);
		
		  if (json) {
					//获得位置数据
                    cJSON *pos_json = cJSON_GetObjectItem(json, "offset");
                    float pos = pos_json->valuedouble;
                    K230_posdataIN(pos);
				
					//获取T路口状态
					cJSON *Tstatus_json = cJSON_GetObjectItem(json, "junction");
					int Tstatus;
					Tstatus = Tstatus_json->valueint;
					K230_tstatusIN(Tstatus);
				
					//获取N路口状态
					cJSON *Nstatus_json = cJSON_GetObjectItem(json, "have_line");
					int Nstatus;
					Nstatus = Nstatus_json->valueint;
					K230_nstatusIN(1 - Nstatus);
				
				memset(k230_cmd_buffer,'\0',sizeof(k230_cmd_buffer));
		     
        }
	      cJSON_Delete(json);	
      }
}

================
File: K230/K230_uart.h
================
#ifndef _K230_UART_H 
#define _K230_UART_H

#include "serial.h"
#include "cJSON.h"
#include "string.h"
#include "stdio.h"
#include "stdlib.h"
#include "K230.h"
#include "ti_msp_dl_config.h"

#define K230_UART  K230_UART_INST
#define K230_printf(fmt, ...)  usart_printf(K230_UART, fmt, ##__VA_ARGS__)

void K230_uartinit(void);


#endif

================
File: K230/K230.c
================
#include "K230.h"

// K230缓存区
static K230 k230_temp;


void K230_posdataIN(float pos)
{
   k230_temp.pos = pos;
}

void K230_getposdata(K230 *k230)
{
    k230->pos = k230_temp.pos;
}

void K230_tstatusIN(int Tstatus)
{
    k230_temp.status.tstatus = Tstatus;
}

void K230_gettstatus(K230 *k230)
{
    k230->status.tstatus = k230_temp.status.tstatus;
}

void K230_nstatusIN(int Nstatus)
{
    k230_temp.status.nstatus = Nstatus;
}

void K230_getnstatus(K230 *k230)
{
    k230->status.nstatus = k230_temp.status.nstatus;
}

================
File: K230/K230.h
================
#ifndef _K230_H
#define _K230_H

#include "string.h"

typedef struct
{
    int tstatus; //到达T路口
    int nstatus; //到达空白路口
}K230_STATUS;


typedef struct
{
    volatile float pos;
	volatile K230_STATUS status;
}K230;


//获取位置信息
void K230_posdataIN(float pos);
void K230_getposdata(K230 *k230);

//获取T路口状态
void K230_tstatusIN(int Tstatus);
void K230_gettstatus(K230 *k230);

//获取N路口状态
void K230_nstatusIN(int Nstatus);
void K230_getnstatus(K230 *k230);

#endif

================
File: Key/Key_config.c
================
#include "Key_config.h"


KEY_CONFIG key1_config = {
    .gpio_port = Key_PORT,
    .gpio_pin = Key_Key_Pin_PIN
};

================
File: Key/Key_config.h
================
#ifndef KEY_CONFIG_H
#define KEY_CONFIG_H

#include "my_gpio.h"
#include "ti_msp_dl_config.h"

typedef struct
{
    GPIO_Regs *gpio_port;  // GPIO port for the key
    uint32_t gpio_pin;        // GPIO pin number for the key
} KEY_CONFIG;

extern KEY_CONFIG key1_config;


#endif // KEY_CONFIG_H

================
File: Key/Key_gpio.c
================
#include "Key_gpio.h"

int Key_getvalue(KEY_CONFIG config)
{
  return gpio_readpin(config.gpio_port, config.gpio_pin);
}

================
File: Key/Key_gpio.h
================
#ifndef _KEY_GPIO_H
#define _KEY_GPIO_H

#include "Key_config.h"

int Key_getvalue(KEY_CONFIG config);

#endif

================
File: Key/Key.c
================
#include "Key.h"

void Key_create(MYKEY *key, KEY_CONFIG config)
{
  key->config = config;
}

void Key_read(MYKEY *key)
{
  key->pin_value = Key_getvalue(key->config);
}

================
File: Key/Key.h
================
#ifndef _KEY_H
#define _KEY_H

#include "Key_gpio.h"
 
typedef struct
{
   int pin_value;
   KEY_CONFIG config; // Key configuration structure
}MYKEY;

void Key_create(MYKEY *key, KEY_CONFIG config);
void Key_read(MYKEY *key);

#endif

================
File: Laser/Laser_config.c
================
#include "Laser_config.h"

LASER_CONFIG rled_config = {
    .gpio_port = RGY_LED_R_Pin_PORT,
    .gpio_pin = RGY_LED_R_Pin_PIN
};

LASER_CONFIG gled_config = {
    .gpio_port = RGY_LED_G_Pin_PORT,
    .gpio_pin = RGY_LED_G_Pin_PIN
};

LASER_CONFIG yled_config = {
    .gpio_port = RGY_LED_Y_Pin_PORT,
    .gpio_pin = RGY_LED_Y_Pin_PIN
};

================
File: Laser/Laser_config.h
================
#ifndef _LASER_CONFIG_H
#define _LASER_CONFIG_H

#include "my_gpio.h"
#include "ti_msp_dl_config.h"

typedef struct
{
    GPIO_Regs *gpio_port;  // GPIO port for the laser
    uint32_t  gpio_pin;       // GPIO pin for the laser
} LASER_CONFIG;

extern LASER_CONFIG rled_config,gled_config,yled_config;

#endif

================
File: Laser/Laser_gpio.c
================
#include "Laser_gpio.h"

void _Laser_on(LASER_CONFIG config)
{
    gpio_setpin(config.gpio_port, config.gpio_pin);
}

void _Laser_off(LASER_CONFIG config)
{
    gpio_resetpin(config.gpio_port, config.gpio_pin);
}

================
File: Laser/Laser_gpio.h
================
#ifndef _LASER_GPIO_H
#define _LASER_GPIO_H

#include "Laser_config.h"

void _Laser_on(LASER_CONFIG config);
void _Laser_off(LASER_CONFIG config);


#endif

================
File: Laser/Laser.c
================
#include "Laser.h"

void Laser_create(LASER *laser, LASER_CONFIG laser_config)
{
     laser->config = laser_config;
}

void Laser_on(LASER *laser)
{
   _Laser_on(laser->config);
}

void Laser_off(LASER *laser)
{
  _Laser_off(laser->config);
}

================
File: Laser/Laser.h
================
#ifndef _LASER_H
#define _LASER_H

#include "Laser_gpio.h"

typedef struct
{
    LASER_CONFIG config;  // Configuration for the laser
}LASER;

void Laser_create(LASER *laser, LASER_CONFIG config);
void Laser_on(LASER *laser);
void Laser_off(LASER *laser);


#endif

================
File: Mask/Car.c
================
#include "Car.h"


//已整定pid
PID pidL = {
    .kp = 170.5,
    .ki =43.0,
    .kd = 0.0,
    .out_xianfu = 7199.0
};
PID pidR = {
    .kp = 180.5,
    .ki =43.0,
    .kd = 0.0,
    .out_xianfu = 7199.0
};

PID pidtrance = {
    .kp = 0.75,
    .ki = 0.00,
    .kd = 3.97,
    .out_xianfu = 6.5
};

PID pidturn = {
    .kp = 0.75,
    .ki = 0.00,
    .kd = 3.37,
    .out_xianfu = 35.0
};

PID pidposition = {
    .kp = 9.0,
    .ki = 0.00,
    .kd = 12.2,
    .out_xianfu = 20.0
};

//载入任务
static int Mask_getmasknum(MASK mask)
{
    return sizeof(mask.mask_list)/sizeof(mask.mask_list[0]);
}

void Car_setmask(CAR *car,MASK mask)
{
    car->mask = mask;
    car->mask.mask_num = Mask_getmasknum(mask);
	car->mask.mask_pc = 0; // 初始化mask_pc为0
}

void Car_settrancepid(CAR *car, PID trancepid)
{
    car->trance_pid = trancepid;
}

float Car_trancepidcal(CAR *car)
{
    return positionPid_Cal(car->imu.zero_yaw, car->imu.real_yaw, &(car->trance_pid));
}

void Car_setturnpid(CAR *car, PID turnpid)
{
    car->turn_pid = turnpid;
}

float Car_turnpidcal(CAR *car)
{
    return positionPid_Cal(car->imu.zero_yaw, car->imu.real_yaw, &(car->turn_pid));
}

void Car_setpositionpid(CAR *car, PID positionpid)
{
    car->position_pid = positionpid;
}

float Car_positionpidcal(CAR *car)
{
    return positionPid_Cal(0.0, car->k230.pos, &(car->position_pid));
}

float Car_getdeltaspeed(CAR *car)
{
     if(car->status.turnstatus == 1){
      //判定转弯完成,进行状态转换
       if(fabs(car->imu.real_yaw - car->imu.zero_yaw) < 2.0){  
          car->status.turnstatus = 0;
       }
      return  Car_turnpidcal(car);
     }

     else if(car->status.turnstatus == 0){
        if(car->basespeed == 0.0)
        {
            return Car_trancepidcal(car);
        }
        else
        {
            return Car_trancepidcal(car) + Car_positionpidcal(car);
        }
     }

}

//设置基础速度
void Car_setbasespeed(CAR *car, float basespeed)
{
    car->basespeed = basespeed;
}

//获取当前距离
void Car_getdistance(CAR *car)
{
   car->distance += (car->motor1.currentspeed + car->motor2.currentspeed) / 2.0;
}   



// typedef enum
// {
//     stop, //停止
//     wait_keyon, //等待按键放置药品  
//     wait_keyoff, //等待按键取走药品
//     turnright, //右转
//     turnleft, //左转
//     turnback, //掉头
//     go_over, //过弯
//     rled, //红色LED
//     gled, //绿色LED
//     yled, //黄色LED
//     nled, //关闭LED
//     goto_T, //到达T路口
//     goto_N, //到达N路口
//     get_num, //获取数字
//     get_mode, //获取模式
//     get_run, //获取运行状态
//     echo_park, //回复到位
//     mask_load //加载任务流程
//     wait_start //等待开始
// }MASK_ENUM;

//任务流程书写；
//stop
int Car_stopfuc(CAR *car)
{
    Car_setbasespeed(car,0.0);
    return 1;
}

//rled
int Car_rledfuc(CAR *car)
{
    Laser_on(&(car->rled));
    Laser_off(&(car->gled));
    Laser_off(&(car->yled));
    return 1; //操作完成
}

//gled
int Car_gledfuc(CAR *car)
{
    Laser_off(&(car->rled));
    Laser_on(&(car->gled));
    Laser_off(&(car->yled));
    return 1; //操作完成
}

//yled
int Car_yledfuc(CAR *car)
{
    Laser_off(&(car->rled));
    Laser_off(&(car->gled));
    Laser_on(&(car->yled));
    return 1; //操作完成
}

//nled
int Car_nledfuc(CAR *car)
{
    Laser_off(&(car->rled));
    Laser_off(&(car->gled));
    Laser_off(&(car->yled));
    return 1; //操作完成
}

//wait_keyon
int Car_waitkeyonfuc(CAR *car)
{
    Key_read(&(car->key));
    if(car->key.pin_value == 1)
    {
        return 1; //药品已放置
    }
    else 
    {
        return 0; //药品未放置
    }
}

//wait_keyoff
int Car_waitkeyofffuc(CAR *car)
{
    Key_read(&(car->key));
    if(car->key.pin_value == 0)
    {
        return 1; //药品已取走
    }
    else 
    {
        return 0; //药品未取走
    }
}


//turnright
int Car_turnrightfuc(CAR *car)
{
   static int pc = 0;
   if(pc == 0)
   {
       car->status.turnstatus = 1;
       car->imu.zero_yaw = car->imu.zero_yaw - 90.0; //设置转弯角度
       pc++;
       return 0; //转弯开始
   }
   else {
     if(car->status.turnstatus == 1) {
       return 0; //保持当前状态
    }
      else {
       pc = 0; //重置计数器
       return 1; //转弯完成
     }

   }
}

//turnleft
int Car_turnleftfuc(CAR *car)
{
   static int pc = 0;
   if(pc == 0)
   {
       car->status.turnstatus = 1;
       car->imu.zero_yaw = car->imu.zero_yaw + 90.0; //设置转弯角度
       pc++;
       return 0; //转弯开始
   }
   else {
     if(car->status.turnstatus == 1) {
       return 0; //保持当前状态
    }
      else {
       pc = 0; //重置计数器
       return 1; //转弯完成
      }

    }
}

//turnback
int Car_turnbackfuc(CAR *car)
{
   static int pc = 0;
   if(pc == 0)
   {
       car->status.turnstatus = 1;
       car->imu.zero_yaw = car->imu.zero_yaw + 180.0; //设置转弯角度
       pc++;
       return 0; //转弯开始
   }
   else {
     if(car->status.turnstatus == 1) {
       return 0; //保持当前状态
    }
      else {
       pc = 0; //重置计数器
       return 1; //转弯完成
     }

   }
}

//get_num
int Car_getnumfuc(CAR *car)
{
    K210_getnumdata(&(car->k210)); //获取数字
    if(car->k210.num[0] == 0) {
         return 0; //未获取到数字
    }
    else {
        return 1; //获取到数字
    }
}


//go_over
const float go_over_distance = 960.0; //过弯距离
int Car_gooverfuc(CAR *car)
{
    static int pc = 0;
    if(pc == 0)
    {
     car->distance = 0; //重置距离
        pc++;
        return 0; //开始转弯
    }
    else {
        if(car->distance < go_over_distance) 
        {
            return 0; //保持当前状态
        }
        else {
            car->distance = 0; //重置距离
            pc = 0; //重置计数器
            return 1; //过弯完成
        }
    }
}

//goto_T
const float basespeed = 30.0; //基础速度
int Car_gotoTfuc(CAR *car)
{
    Car_setbasespeed(car, basespeed);
    K230_gettstatus(&(car->k230));
    if(car->k230.status.tstatus == 1) {
        //到达T路口，执行相应操作
        return 1; //到达T路口
    }
    else {
        //未到达T路口，继续前进
        return 0; //保持当前状态
    }

}

//goto_N
int Car_gotoNfuc(CAR *car)
{
    Car_setbasespeed(car, basespeed);
    K230_getnstatus(&(car->k230));
    if(car->k230.status.nstatus == 1) {
        //到达N路口，执行相应操作
        return 1; //到达N路口
    }
    else {
        //未到达N路口，继续前进
        return 0; //保持当前状态
    }
}

//get_mode
int Car_getmodefuc(CAR *car)
{
    Raspberry_getmodedata_update(&(car->raspberry));
    if(car->raspberry.status.modedata_update == 1) {
         //模式数据已更新
         Raspberry_getmodedata(&(car->raspberry)); //获取模式数据
         //发送{"cmd":"mode","result":"ok"}
         Raspberry_printf("{\"cmd\":\"mode\",\"result\":\"ok\"}\n");
         return 1; //获取完成
    }
    else {
         return 0; //保持当前状态
    }
}


//wait_run
int Car_waitrunfuc(CAR *car)
{
    Raspberry_getrun(&(car->raspberry));
    if(car->raspberry.status.run == 1) {
         return 1; //获取完成
    }
    else {
         return 0; //保持当前状态
    }
}

//echo_park
int Car_echoparkfuc(CAR *car)
{
//回复{"cmd":"run","parked":1} //到位
    Raspberry_printf("{\"cmd\":\"run\",\"parked\":1}\n");
    return 1; //回复完成
}

//wait_start
int Car_waitstartfuc(CAR *car)
{
    Raspberry_getstart(&(car->raspberry));
    if(car->raspberry.status.start == 1) {
        //开始状态为1，开始执行任务
        return 1; //开始执行任务
    }
    else {
        //开始状态为0，保持等待
        return 0; //保持当前状态
    }
}

//
MASK mask_a = {
    .mask_list = {    
       stop,  
       wait_keyoff,
       wait_run,

       goto_T,
       go_over,
       goto_T,
       go_over,
       turnleft,
       goto_N,
       go_over,
       stop,
       yled,
       echo_park,      
       wait_start,

       nled,
       turnback,
       goto_T,
       go_over,
       goto_N,
       go_over,
       stop
    
    },
    .mask_num = 14
};

MASK mask_b = {
    .mask_list = {    
       stop,  
       wait_keyoff,
       wait_run,

       goto_T,
       go_over,
       goto_T,
       go_over,
       turnright,
       goto_N,
       go_over,
       stop,
       yled,
       echo_park,      
       wait_start,

       nled,
       turnback,
       goto_T,
       go_over,
       goto_N,
       go_over,
       stop
    },
    .mask_num = 14
};

MASK mask_c = {
    .mask_list = {
     wait_run,
     stop,
     goto_T,
     go_over,
     goto_T,
     go_over,
     turnright,
     goto_N,
     go_over,
     stop,
     yled,
     echo_park,
     wait_start,

     nled,
     turnback,
     goto_T,
     go_over,
     turnright,

     goto_T,
     get_num,
     go_over,
     mask_load
    },
    .mask_num = 18
};

MASK mask_c1 = {
    .mask_list = {    
    turnright,

    goto_T,
    get_num,    
    go_over,
    mask_load
    },
    .mask_num = 5
};

MASK mask_c2 = {
    .mask_list = {    
    turnleft,
    
    goto_T,
    get_num,      
    go_over,
    mask_load
    },
    .mask_num = 5
};

MASK mask_c3 = {
    .mask_list = {
        turnright,
        goto_N,
        go_over,
        rled,
        stop
    },
    .mask_num = 4
};

MASK mask_c4 = {
    .mask_list = {
        turnleft,
        goto_N,
        go_over,
        rled,
        stop
    },
    .mask_num = 4
};

//mask_load
int Car_maskloadfuc(CAR *car)
{
  if(car->raspberry.mode.target == 0)
  {
    if(car->raspberry.mode.park == 'A')
    {
        Car_setmask(car, mask_a);
    }
    else if(car->raspberry.mode.park == 'B')
    {
        Car_setmask(car, mask_b);
    }
  }
  else if(car->raspberry.mode.target == 1)
  {
    static int pc = 0;
    if(pc == 0)
    {
        car->target_num = car->k210.num[0]; //设置目标数字
        Car_setmask(car, mask_c);
        pc++;
    }
    else if(pc == 1)
    {
      if(car->k210.num[0] == car->target_num || car->k210.num[1] == car->target_num || car->k210.num[2] == car->target_num ||
         car->k210.num[3] == car->target_num || car->k210.num[4] == car->target_num || car->k210.num[5] == car->target_num)
      {
        Car_setmask(car, mask_c1);
      }
      else{
        Car_setmask(car, mask_c2);
      }
        pc++;
    }
    else if(pc == 2)
    {
      if(car->k210.num[0] == car->target_num || car->k210.num[1] == car->target_num || car->k210.num[2] == car->target_num ||
         car->k210.num[3] == car->target_num || car->k210.num[4] == car->target_num || car->k210.num[5] == car->target_num)
      {
        Car_setmask(car, mask_c3);
      }
      else{
        Car_setmask(car, mask_c4);
      }
   }
 }
  
   return 1; //加载完成
}

================
File: Mask/Car.h
================
#ifndef _CAR_H
#define _CAR_H

#include "Driver.h"
#include "Servo.h"
#include "my_HWT101.h"
#include "Laser.h"
#include "Key.h"

#include "K230.h"
#include "K230_uart.h"
#include "K210.h"
#include "K210_uart.h"
#include "Raspberry_Pi.h"
#include "Raspberry_uart.h"


typedef struct
{
    int turnstatus;
    int trance_status;
}CAR_STATUS;

typedef enum
{
   wait_keyon,
   wait_keyoff,
   get_num,
   goto_T,
   goto_N,
   go_over,
   turnright,
   turnleft,
   turnback,
   mask_load,
   echo_park,
   wait_run,
   rled,
   gled,
   yled,
   nled,
   wait_start,
   get_mode,
   stop
}MASK_ENUM;

typedef struct
{
    MASK_ENUM mask_list[200];
    int mask_num;
    int mask_pc;
}MASK;


typedef struct 
{
    MOTOR motor1;
    MOTOR motor2;
    SERVO servo;
    RASPBERRY raspberry;
    K230  k230;
    K210  k210;
    LASER rled;
    LASER gled;
    LASER yled;
    IMU imu;
    MYKEY key;

    PID trance_pid;
    PID turn_pid;
    PID position_pid;

    float basespeed;// 基础速度
    int   distance; // 距离

    volatile MASK mask;
    int target_num; // 目标数字

    CAR_STATUS status;
}CAR;

//已整定pid
extern PID pidL,pidR,pidtrance,pidturn,pidposition;

//载入任务
void Car_setmask(CAR *car,MASK mask);

//设置巡线角度环PID
void Car_settrancepid(CAR *car, PID trancepid);
float Car_trancepidcal(CAR *car);

//设置转向环PID 
void Car_setturnpid(CAR *car, PID turnpid);
float Car_turnpidcal(CAR *car);

//设置位置环PID
void Car_setpositionpid(CAR *car, PID positionpid);
float Car_positionpidcal(CAR *car);

//获得左右轮差速
float Car_getdeltaspeed(CAR *car);

//设置基础速度
void Car_setbasespeed(CAR *car, float basespeed);
//获取当前距离
void Car_getdistance(CAR *car);

//任务流程
//stop
int Car_stopfuc(CAR *car);

//rled
int Car_rledfuc(CAR *car);

//gled
int Car_gledfuc(CAR *car);

//yled
int Car_yledfuc(CAR *car);

//nled
int Car_nledfuc(CAR *car);

//wait_keyon
int Car_waitkeyonfuc(CAR *car);

//wait_keyoff
int Car_waitkeyofffuc(CAR *car);

//turnright
int Car_turnrightfuc(CAR *car);

//turnleft
int Car_turnleftfuc(CAR *car);

//turnback
int Car_turnbackfuc(CAR *car);

//goto_T
int Car_gotoTfuc(CAR *car); 

//goto_N
int Car_gotoNfuc(CAR *car);

//get_num
int Car_getnumfuc(CAR *car);

//go_over
int Car_gooverfuc(CAR *car);

//get_mode
int Car_getmodefuc(CAR *car);

//echo_park
int Car_echoparkfuc(CAR *car);

//wait_start
int Car_waitstartfuc(CAR *car);

//wait_run
int Car_waitrunfuc(CAR *car);

//mask_load
int Car_maskloadfuc(CAR *car);

#endif

================
File: Mask/Mask_perform.c
================
#include "Mask_perform.h"

int Mask_performmask(CAR *car, MASK_ENUM mask_enum)
{
	  switch(mask_enum)
		{
			case rled:
					return Car_rledfuc(car); break;
			case gled:
					return Car_gledfuc(car); break;
			case yled:
					return Car_yledfuc(car); break;
			case nled:
					return Car_nledfuc(car); break;
			case wait_keyon:
					return Car_waitkeyonfuc(car); break;
			case wait_keyoff:
					return Car_waitkeyofffuc(car); break;
			case get_num:
					return Car_getnumfuc(car); break;
			case goto_T:
					return Car_gotoTfuc(car); break;
			case goto_N:
					return Car_gotoNfuc(car); break;
			case go_over:
					return Car_gooverfuc(car); break;
			case turnright:
					return Car_turnrightfuc(car); break;	
			case turnleft:
					return Car_turnleftfuc(car); break;
			case turnback:
					return Car_turnbackfuc(car); break;
			case stop:
					return Car_stopfuc(car);
			case mask_load:
				    return Car_maskloadfuc(car); break;
			case echo_park:
					return Car_echoparkfuc(car); break;
			case wait_run:
					return Car_waitrunfuc(car); break;
			case get_mode:
					return Car_getmodefuc(car); break;
			case wait_start:
					return Car_waitstartfuc(car); break;
			default:
					return Car_stopfuc(car);
			    break;
				
		}

}


void Mask_performmasks(CAR *car)
{
	if(car->mask.mask_pc < car->mask.mask_num)
	 {
		if(car->mask.mask_list[car->mask.mask_pc] == mask_load)
		{
			Mask_performmask(car,car->mask.mask_list[car->mask.mask_pc]);
		}
		else
		{
		 int i = Mask_performmask(car,car->mask.mask_list[car->mask.mask_pc]);
		  car->mask.mask_pc = car->mask.mask_pc + i;
		}

	 }
	else
	 {
	   Mask_performmask(car,stop);
	 }		
}

================
File: Mask/Mask_perform.h
================
#ifndef _MASK_PERFORM_H
#define _MASK_PERFORM_H

#include "Car.h"

void Mask_performmasks(CAR *car);

#endif

================
File: Mask/Mask.c
================
#include "Mask.h"

//定义对象
CAR car;

MASK mask_start = {
    .mask_list = {        
       stop,
       yled,
       get_num,
       nled,
       yled,
       get_mode,
       nled,
       mask_load
    },
    .mask_num = 4,
};

void Mask_start(void)
{
    //电机初始化
	 Driver_creatmotor(&(car.motor1),pidL,leftdriver);
	 Driver_creatmotor(&(car.motor2),pidR,rightdriver);
     Driver_init(&(car.motor1));
     Driver_init(&(car.motor2));

    //LED初始化
     Laser_create(&(car.rled), rled_config);
     Laser_create(&(car.gled), gled_config);
     Laser_create(&(car.yled), yled_config);
    //上电关灯
     Laser_off(&(car.rled));
     Laser_off(&(car.gled));
     Laser_off(&(car.yled));

    //树莓派串口初始化
     Raspberry_uartinit();

    //K230串口初始化
     K230_uartinit();

    //K210串口初始化
     K210_uartinit();

    //陀螺仪初始化
     Myhwt101_init(); 
     Myhwt101_resetz(&(car.imu));

    //按键初始化
     Key_create(&(car.key), key1_config);

    //舵机初始化
     Servo_create(&(car.servo), servo_config);
     Servo_init(&(car.servo));
     Servo_setangle(&(car.servo), 109.0f);

    //设置trancePID
     Car_settrancepid(&car, pidtrance);

     //设置turnPID
     Car_setturnpid(&car, pidturn);

     //设置positionPID
     Car_setpositionpid(&car, pidposition);
     
     //设置任务流程
     Car_setmask(&car, mask_start);

    //开启任务定时中断
     tim_it_start(Mask_Timer_INST,Mask_Timer_INST_INT_IRQN);
	
}

void Mask_Timer_INST_IRQHandler(void)
{ 
	Driver_getmotor_currentspeed(&(car.motor1));
	Driver_getmotor_currentspeed(&(car.motor2));

    Car_getdistance(&car);

    Myhwt101_getdata(&(car.imu));

    K230_getposdata(&(car.k230));

    //获得左右轮差速
     float delta = Car_getdeltaspeed(&car);

     Mask_performmasks(&car);

     Driver_setmotor_targetspeed(&(car.motor1), car.basespeed - delta);
     Driver_setmotor_targetspeed(&(car.motor2), car.basespeed + delta);


    Driver_setspeed(&(car.motor1),&(car.motor2));

}

//调试
    //输出速度信息    
    // Debugger_printf("%d,%d\n",car.motor1.currentspeed,car.motor2.currentspeed);
    //输出角度信息
    // Debugger_printf("%.3f,%.3f,%.3f\n",car.imu.current_yaw,car.imu.real_yaw,car.imu.zero_yaw);
    // Debugger_printf("%.3f,%.3f,%.3f,%.3f\n",car.imu.real_yaw,car.imu.zero_yaw,car.imu.current_yaw,delta);
    //输出位置信息
    // Debugger_printf("%.3f,%d,%d\n",car.k230.pos,car.k230.status.nstatus,car.status.tstatus);


//循迹角度环TEST
    // float delta = Car_trancepidcal(&car);
    // float base_speed = 25.0;
    // Driver_setmotor_targetspeed(&(car.motor1), base_speed - delta);
    // Driver_setmotor_targetspeed(&(car.motor2), base_speed + delta);

//TEST代码
// 	int time = 1500;
// 	static int i = 0;
//   if(i<time/10)
// 	{
//     Driver_setmotor_targetspeed(&(car.motor2),0.0);
//     Driver_setmotor_targetspeed(&(car.motor1),0.0);
// 		i++;
// 	}
// 	else if(i < 2*time/10)
// 	{
//     Driver_setmotor_targetspeed(&(car.motor2),25.0);
//     Driver_setmotor_targetspeed(&(car.motor1),25.0);
// 		i++;	
// 	}
// 	else if(i < 3*time/10)
// 	{
//     Driver_setmotor_targetspeed(&(car.motor1),40.0);
//     Driver_setmotor_targetspeed(&(car.motor2),40.0);
// 		i++;	
// 	}    
// 	else if(i < 4*time/10)
// 	{
//     Driver_setmotor_targetspeed(&(car.motor1),25.0);
//     Driver_setmotor_targetspeed(&(car.motor2),25.0);
// 		i++;
// 	}
//     else if(i < 5*time/10){
//     Driver_setmotor_targetspeed(&(car.motor1),0.0);  
//     Driver_setmotor_targetspeed(&(car.motor2),0.0);
//     i++;
//     }
//   else if(i < 6*time/10){
//     Driver_setmotor_targetspeed(&(car.motor1),-25.0);  
//     Driver_setmotor_targetspeed(&(car.motor2),-25.0);
//     i++;
//     }
//   else if(i < 7*time/10){
//     Driver_setmotor_targetspeed(&(car.motor1),-40.0);  
//     Driver_setmotor_targetspeed(&(car.motor2),-40.0);
//     i++;
//     }
//   else if(i < 8*time/10){
//     Driver_setmotor_targetspeed(&(car.motor1),-25.0);  
//     Driver_setmotor_targetspeed(&(car.motor2),-25.0);
//     i++;
//     }
//   else{
//     Driver_setmotor_targetspeed(&(car.motor1),0.0);  
//     Driver_setmotor_targetspeed(&(car.motor2),0.0);
//   }

//稳定性测试任务流程
// MASK mask = {
//     .mask_list = {        
//         stop,
//         wait_keyoff,
//         goto_T,
//         go_over,
//         turnright,
//         goto_N,
//         go_over,
//         stop,
//         wait_keyon,
//         turnback,
//         goto_T,
//         go_over,
//         turnright,
//         goto_T,
//         go_over,
//         turnright,
//         goto_N,
//         go_over,
//         stop,
//         wait_keyoff,
//         turnback,
//         goto_T,
//         go_over,
//         turnright,
//         goto_T,
//         go_over,
//         turnright,
//         goto_T,
//         go_over,
//         turnright,
//         goto_N,
//         go_over,
//         stop,
//         wait_keyon,
//         turnback,
//         goto_T,
//         go_over,
//         turnleft,
//         goto_T,
//         go_over,
//         turnleft,
//         goto_N,
//         go_over,
//         stop
//     },
//     .mask_num = 40
// };

================
File: Mask/Mask.h
================
#ifndef _MASK_H
#define _MASK_H

#include "tim_it.h"
#include "serial.h"
#include "my_delay.h"
#include "Car.h"
#include "Mask_perform.h"

void Mask_start(void);

#endif

================
File: Raspberry_Pi/cJSON.c
================
/*
  Copyright (c) 2009 Dave Gamble

  Permission is hereby granted, free of charge, to any person obtaining a copy
  of this software and associated documentation files (the "Software"), to deal
  in the Software without restriction, including without limitation the rights
  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
  copies of the Software, and to permit persons to whom the Software is
  furnished to do so, subject to the following conditions:

  The above copyright notice and this permission notice shall be included in
  all copies or substantial portions of the Software.

  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
  THE SOFTWARE.
*/

/* cJSON */
/* JSON parser in C. */

#include <string.h>
#include <stdio.h>
#include <math.h>
#include <stdlib.h>
#include <float.h>
#include <limits.h>
#include <ctype.h>
#include "cJSON.h"

static const char *ep;

const char *cJSON_GetErrorPtr(void) {return ep;}

static int cJSON_strcasecmp(const char *s1,const char *s2)
{
	if (!s1) return (s1==s2)?0:1;if (!s2) return 1;
	for(; tolower(*s1) == tolower(*s2); ++s1, ++s2)	if(*s1 == 0)	return 0;
	return tolower(*(const unsigned char *)s1) - tolower(*(const unsigned char *)s2);
}

static void *(*cJSON_malloc)(size_t sz) = malloc;
static void (*cJSON_free)(void *ptr) = free;

static char* cJSON_strdup(const char* str)
{
      size_t len;
      char* copy;

      len = strlen(str) + 1;
      if (!(copy = (char*)cJSON_malloc(len))) return 0;
      memcpy(copy,str,len);
      return copy;
}

void cJSON_InitHooks(cJSON_Hooks* hooks)
{
    if (!hooks) { /* Reset hooks */
        cJSON_malloc = malloc;
        cJSON_free = free;
        return;
    }

	cJSON_malloc = (hooks->malloc_fn)?hooks->malloc_fn:malloc;
	cJSON_free	 = (hooks->free_fn)?hooks->free_fn:free;
}

/* Internal constructor. */
static cJSON *cJSON_New_Item(void)
{
	cJSON* node = (cJSON*)cJSON_malloc(sizeof(cJSON));
	if (node) memset(node,0,sizeof(cJSON));
	return node;
}

/* Delete a cJSON structure. */
void cJSON_Delete(cJSON *c)
{
	cJSON *next;
	while (c)
	{
		next=c->next;
		if (!(c->type&cJSON_IsReference) && c->child) cJSON_Delete(c->child);
		if (!(c->type&cJSON_IsReference) && c->valuestring) cJSON_free(c->valuestring);
		if (!(c->type&cJSON_StringIsConst) && c->string) cJSON_free(c->string);
		cJSON_free(c);
		c=next;
	}
}

/* Parse the input text to generate a number, and populate the result into item. */
static const char *parse_number(cJSON *item,const char *num)
{
	double n=0,sign=1,scale=0;int subscale=0,signsubscale=1;

	if (*num=='-') sign=-1,num++;	/* Has sign? */
	if (*num=='0') num++;			/* is zero */
	if (*num>='1' && *num<='9')	do	n=(n*10.0)+(*num++ -'0');	while (*num>='0' && *num<='9');	/* Number? */
	if (*num=='.' && num[1]>='0' && num[1]<='9') {num++;		do	n=(n*10.0)+(*num++ -'0'),scale--; while (*num>='0' && *num<='9');}	/* Fractional part? */
	if (*num=='e' || *num=='E')		/* Exponent? */
	{	num++;if (*num=='+') num++;	else if (*num=='-') signsubscale=-1,num++;		/* With sign? */
		while (*num>='0' && *num<='9') subscale=(subscale*10)+(*num++ - '0');	/* Number? */
	}

	n=sign*n*pow(10.0,(scale+subscale*signsubscale));	/* number = +/- number.fraction * 10^+/- exponent */
	
	item->valuedouble=n;
	item->valueint=(int)n;
	item->type=cJSON_Number;
	return num;
}

static int pow2gt (int x)	{	--x;	x|=x>>1;	x|=x>>2;	x|=x>>4;	x|=x>>8;	x|=x>>16;	return x+1;	}

typedef struct {char *buffer; int length; int offset; } printbuffer;

static char* ensure(printbuffer *p,int needed)
{
	char *newbuffer;int newsize;
	if (!p || !p->buffer) return 0;
	needed+=p->offset;
	if (needed<=p->length) return p->buffer+p->offset;

	newsize=pow2gt(needed);
	newbuffer=(char*)cJSON_malloc(newsize);
	if (!newbuffer) {cJSON_free(p->buffer);p->length=0,p->buffer=0;return 0;}
	if (newbuffer) memcpy(newbuffer,p->buffer,p->length);
	cJSON_free(p->buffer);
	p->length=newsize;
	p->buffer=newbuffer;
	return newbuffer+p->offset;
}

static int update(printbuffer *p)
{
	char *str;
	if (!p || !p->buffer) return 0;
	str=p->buffer+p->offset;
	return p->offset+strlen(str);
}

/* Render the number nicely from the given item into a string. */
static char *print_number(cJSON *item,printbuffer *p)
{
	char *str=0;
	double d=item->valuedouble;
	if (d==0)
	{
		if (p)	str=ensure(p,2);
		else	str=(char*)cJSON_malloc(2);	/* special case for 0. */
		if (str) strcpy(str,"0");
	}
	else if (fabs(((double)item->valueint)-d)<=DBL_EPSILON && d<=INT_MAX && d>=INT_MIN)
	{
		if (p)	str=ensure(p,21);
		else	str=(char*)cJSON_malloc(21);	/* 2^64+1 can be represented in 21 chars. */
		if (str)	sprintf(str,"%d",item->valueint);
	}
	else
	{
		if (p)	str=ensure(p,64);
		else	str=(char*)cJSON_malloc(64);	/* This is a nice tradeoff. */
		if (str)
		{
			if (fabs(floor(d)-d)<=DBL_EPSILON && fabs(d)<1.0e60)sprintf(str,"%.0f",d);
			else if (fabs(d)<1.0e-6 || fabs(d)>1.0e9)			sprintf(str,"%e",d);
			else												sprintf(str,"%f",d);
		}
	}
	return str;
}

static unsigned parse_hex4(const char *str)
{
	unsigned h=0;
	if (*str>='0' && *str<='9') h+=(*str)-'0'; else if (*str>='A' && *str<='F') h+=10+(*str)-'A'; else if (*str>='a' && *str<='f') h+=10+(*str)-'a'; else return 0;
	h=h<<4;str++;
	if (*str>='0' && *str<='9') h+=(*str)-'0'; else if (*str>='A' && *str<='F') h+=10+(*str)-'A'; else if (*str>='a' && *str<='f') h+=10+(*str)-'a'; else return 0;
	h=h<<4;str++;
	if (*str>='0' && *str<='9') h+=(*str)-'0'; else if (*str>='A' && *str<='F') h+=10+(*str)-'A'; else if (*str>='a' && *str<='f') h+=10+(*str)-'a'; else return 0;
	h=h<<4;str++;
	if (*str>='0' && *str<='9') h+=(*str)-'0'; else if (*str>='A' && *str<='F') h+=10+(*str)-'A'; else if (*str>='a' && *str<='f') h+=10+(*str)-'a'; else return 0;
	return h;
}

/* Parse the input text into an unescaped cstring, and populate item. */
static const unsigned char firstByteMark[7] = { 0x00, 0x00, 0xC0, 0xE0, 0xF0, 0xF8, 0xFC };
static const char *parse_string(cJSON *item,const char *str)
{
	const char *ptr=str+1;char *ptr2;char *out;int len=0;unsigned uc,uc2;
	if (*str!='\"') {ep=str;return 0;}	/* not a string! */
	
	while (*ptr!='\"' && *ptr && ++len) if (*ptr++ == '\\') ptr++;	/* Skip escaped quotes. */
	
	out=(char*)cJSON_malloc(len+1);	/* This is how long we need for the string, roughly. */
	if (!out) return 0;
	
	ptr=str+1;ptr2=out;
	while (*ptr!='\"' && *ptr)
	{
		if (*ptr!='\\') *ptr2++=*ptr++;
		else
		{
			ptr++;
			switch (*ptr)
			{
				case 'b': *ptr2++='\b';	break;
				case 'f': *ptr2++='\f';	break;
				case 'n': *ptr2++='\n';	break;
				case 'r': *ptr2++='\r';	break;
				case 't': *ptr2++='\t';	break;
				case 'u':	 /* transcode utf16 to utf8. */
					uc=parse_hex4(ptr+1);ptr+=4;	/* get the unicode char. */

					if ((uc>=0xDC00 && uc<=0xDFFF) || uc==0)	break;	/* check for invalid.	*/

					if (uc>=0xD800 && uc<=0xDBFF)	/* UTF16 surrogate pairs.	*/
					{
						if (ptr[1]!='\\' || ptr[2]!='u')	break;	/* missing second-half of surrogate.	*/
						uc2=parse_hex4(ptr+3);ptr+=6;
						if (uc2<0xDC00 || uc2>0xDFFF)		break;	/* invalid second-half of surrogate.	*/
						uc=0x10000 + (((uc&0x3FF)<<10) | (uc2&0x3FF));
					}

					len=4;if (uc<0x80) len=1;else if (uc<0x800) len=2;else if (uc<0x10000) len=3; ptr2+=len;
					
					switch (len) {
						case 4: *--ptr2 =((uc | 0x80) & 0xBF); uc >>= 6;
						case 3: *--ptr2 =((uc | 0x80) & 0xBF); uc >>= 6;
						case 2: *--ptr2 =((uc | 0x80) & 0xBF); uc >>= 6;
						case 1: *--ptr2 =(uc | firstByteMark[len]);
					}
					ptr2+=len;
					break;
				default:  *ptr2++=*ptr; break;
			}
			ptr++;
		}
	}
	*ptr2=0;
	if (*ptr=='\"') ptr++;
	item->valuestring=out;
	item->type=cJSON_String;
	return ptr;
}

/* Render the cstring provided to an escaped version that can be printed. */
static char *print_string_ptr(const char *str,printbuffer *p)
{
	const char *ptr;char *ptr2,*out;int len=0,flag=0;unsigned char token;
	
	for (ptr=str;*ptr;ptr++) flag|=((*ptr>0 && *ptr<32)||(*ptr=='\"')||(*ptr=='\\'))?1:0;
	if (!flag)
	{
		len=ptr-str;
		if (p) out=ensure(p,len+3);
		else		out=(char*)cJSON_malloc(len+3);
		if (!out) return 0;
		ptr2=out;*ptr2++='\"';
		strcpy(ptr2,str);
		ptr2[len]='\"';
		ptr2[len+1]=0;
		return out;
	}
	
	if (!str)
	{
		if (p)	out=ensure(p,3);
		else	out=(char*)cJSON_malloc(3);
		if (!out) return 0;
		strcpy(out,"\"\"");
		return out;
	}
	ptr=str;while ((token=*ptr) && ++len) {if (strchr("\"\\\b\f\n\r\t",token)) len++; else if (token<32) len+=5;ptr++;}
	
	if (p)	out=ensure(p,len+3);
	else	out=(char*)cJSON_malloc(len+3);
	if (!out) return 0;

	ptr2=out;ptr=str;
	*ptr2++='\"';
	while (*ptr)
	{
		if ((unsigned char)*ptr>31 && *ptr!='\"' && *ptr!='\\') *ptr2++=*ptr++;
		else
		{
			*ptr2++='\\';
			switch (token=*ptr++)
			{
				case '\\':	*ptr2++='\\';	break;
				case '\"':	*ptr2++='\"';	break;
				case '\b':	*ptr2++='b';	break;
				case '\f':	*ptr2++='f';	break;
				case '\n':	*ptr2++='n';	break;
				case '\r':	*ptr2++='r';	break;
				case '\t':	*ptr2++='t';	break;
				default: sprintf(ptr2,"u%04x",token);ptr2+=5;	break;	/* escape and print */
			}
		}
	}
	*ptr2++='\"';*ptr2++=0;
	return out;
}
/* Invote print_string_ptr (which is useful) on an item. */
static char *print_string(cJSON *item,printbuffer *p)	{return print_string_ptr(item->valuestring,p);}

/* Predeclare these prototypes. */
static const char *parse_value(cJSON *item,const char *value);
static char *print_value(cJSON *item,int depth,int fmt,printbuffer *p);
static const char *parse_array(cJSON *item,const char *value);
static char *print_array(cJSON *item,int depth,int fmt,printbuffer *p);
static const char *parse_object(cJSON *item,const char *value);
static char *print_object(cJSON *item,int depth,int fmt,printbuffer *p);

/* Utility to jump whitespace and cr/lf */
static const char *skip(const char *in) {while (in && *in && (unsigned char)*in<=32) in++; return in;}

/* Parse an object - create a new root, and populate. */
cJSON *cJSON_ParseWithOpts(const char *value,const char **return_parse_end,int require_null_terminated)
{
	const char *end=0;
	cJSON *c=cJSON_New_Item();
	ep=0;
	if (!c) return 0;       /* memory fail */

	end=parse_value(c,skip(value));
	if (!end)	{cJSON_Delete(c);return 0;}	/* parse failure. ep is set. */

	/* if we require null-terminated JSON without appended garbage, skip and then check for a null terminator */
	if (require_null_terminated) {end=skip(end);if (*end) {cJSON_Delete(c);ep=end;return 0;}}
	if (return_parse_end) *return_parse_end=end;
	return c;
}
/* Default options for cJSON_Parse */
cJSON *cJSON_Parse(const char *value) {return cJSON_ParseWithOpts(value,0,0);}

/* Render a cJSON item/entity/structure to text. */
char *cJSON_Print(cJSON *item)				{return print_value(item,0,1,0);}
char *cJSON_PrintUnformatted(cJSON *item)	{return print_value(item,0,0,0);}

char *cJSON_PrintBuffered(cJSON *item,int prebuffer,int fmt)
{
	printbuffer p;
	p.buffer=(char*)cJSON_malloc(prebuffer);
	p.length=prebuffer;
	p.offset=0;
	return print_value(item,0,fmt,&p);
	return p.buffer;
}


/* Parser core - when encountering text, process appropriately. */
static const char *parse_value(cJSON *item,const char *value)
{
	if (!value)						return 0;	/* Fail on null. */
	if (!strncmp(value,"null",4))	{ item->type=cJSON_NULL;  return value+4; }
	if (!strncmp(value,"false",5))	{ item->type=cJSON_False; return value+5; }
	if (!strncmp(value,"true",4))	{ item->type=cJSON_True; item->valueint=1;	return value+4; }
	if (*value=='\"')				{ return parse_string(item,value); }
	if (*value=='-' || (*value>='0' && *value<='9'))	{ return parse_number(item,value); }
	if (*value=='[')				{ return parse_array(item,value); }
	if (*value=='{')				{ return parse_object(item,value); }

	ep=value;return 0;	/* failure. */
}

/* Render a value to text. */
static char *print_value(cJSON *item,int depth,int fmt,printbuffer *p)
{
	char *out=0;
	if (!item) return 0;
	if (p)
	{
		switch ((item->type)&255)
		{
			case cJSON_NULL:	{out=ensure(p,5);	if (out) strcpy(out,"null");	break;}
			case cJSON_False:	{out=ensure(p,6);	if (out) strcpy(out,"false");	break;}
			case cJSON_True:	{out=ensure(p,5);	if (out) strcpy(out,"true");	break;}
			case cJSON_Number:	out=print_number(item,p);break;
			case cJSON_String:	out=print_string(item,p);break;
			case cJSON_Array:	out=print_array(item,depth,fmt,p);break;
			case cJSON_Object:	out=print_object(item,depth,fmt,p);break;
		}
	}
	else
	{
		switch ((item->type)&255)
		{
			case cJSON_NULL:	out=cJSON_strdup("null");	break;
			case cJSON_False:	out=cJSON_strdup("false");break;
			case cJSON_True:	out=cJSON_strdup("true"); break;
			case cJSON_Number:	out=print_number(item,0);break;
			case cJSON_String:	out=print_string(item,0);break;
			case cJSON_Array:	out=print_array(item,depth,fmt,0);break;
			case cJSON_Object:	out=print_object(item,depth,fmt,0);break;
		}
	}
	return out;
}

/* Build an array from input text. */
static const char *parse_array(cJSON *item,const char *value)
{
	cJSON *child;
	if (*value!='[')	{ep=value;return 0;}	/* not an array! */

	item->type=cJSON_Array;
	value=skip(value+1);
	if (*value==']') return value+1;	/* empty array. */

	item->child=child=cJSON_New_Item();
	if (!item->child) return 0;		 /* memory fail */
	value=skip(parse_value(child,skip(value)));	/* skip any spacing, get the value. */
	if (!value) return 0;

	while (*value==',')
	{
		cJSON *new_item;
		if (!(new_item=cJSON_New_Item())) return 0; 	/* memory fail */
		child->next=new_item;new_item->prev=child;child=new_item;
		value=skip(parse_value(child,skip(value+1)));
		if (!value) return 0;	/* memory fail */
	}

	if (*value==']') return value+1;	/* end of array */
	ep=value;return 0;	/* malformed. */
}

/* Render an array to text */
static char *print_array(cJSON *item,int depth,int fmt,printbuffer *p)
{
	char **entries;
	char *out=0,*ptr,*ret;int len=5;
	cJSON *child=item->child;
	int numentries=0,i=0,fail=0;
	size_t tmplen=0;
	
	/* How many entries in the array? */
	while (child) numentries++,child=child->next;
	/* Explicitly handle numentries==0 */
	if (!numentries)
	{
		if (p)	out=ensure(p,3);
		else	out=(char*)cJSON_malloc(3);
		if (out) strcpy(out,"[]");
		return out;
	}

	if (p)
	{
		/* Compose the output array. */
		i=p->offset;
		ptr=ensure(p,1);if (!ptr) return 0;	*ptr='[';	p->offset++;
		child=item->child;
		while (child && !fail)
		{
			print_value(child,depth+1,fmt,p);
			p->offset=update(p);
			if (child->next) {len=fmt?2:1;ptr=ensure(p,len+1);if (!ptr) return 0;*ptr++=',';if(fmt)*ptr++=' ';*ptr=0;p->offset+=len;}
			child=child->next;
		}
		ptr=ensure(p,2);if (!ptr) return 0;	*ptr++=']';*ptr=0;
		out=(p->buffer)+i;
	}
	else
	{
		/* Allocate an array to hold the values for each */
		entries=(char**)cJSON_malloc(numentries*sizeof(char*));
		if (!entries) return 0;
		memset(entries,0,numentries*sizeof(char*));
		/* Retrieve all the results: */
		child=item->child;
		while (child && !fail)
		{
			ret=print_value(child,depth+1,fmt,0);
			entries[i++]=ret;
			if (ret) len+=strlen(ret)+2+(fmt?1:0); else fail=1;
			child=child->next;
		}
		
		/* If we didn't fail, try to malloc the output string */
		if (!fail)	out=(char*)cJSON_malloc(len);
		/* If that fails, we fail. */
		if (!out) fail=1;

		/* Handle failure. */
		if (fail)
		{
			for (i=0;i<numentries;i++) if (entries[i]) cJSON_free(entries[i]);
			cJSON_free(entries);
			return 0;
		}
		
		/* Compose the output array. */
		*out='[';
		ptr=out+1;*ptr=0;
		for (i=0;i<numentries;i++)
		{
			tmplen=strlen(entries[i]);memcpy(ptr,entries[i],tmplen);ptr+=tmplen;
			if (i!=numentries-1) {*ptr++=',';if(fmt)*ptr++=' ';*ptr=0;}
			cJSON_free(entries[i]);
		}
		cJSON_free(entries);
		*ptr++=']';*ptr++=0;
	}
	return out;	
}

/* Build an object from the text. */
static const char *parse_object(cJSON *item,const char *value)
{
	cJSON *child;
	if (*value!='{')	{ep=value;return 0;}	/* not an object! */
	
	item->type=cJSON_Object;
	value=skip(value+1);
	if (*value=='}') return value+1;	/* empty array. */
	
	item->child=child=cJSON_New_Item();
	if (!item->child) return 0;
	value=skip(parse_string(child,skip(value)));
	if (!value) return 0;
	child->string=child->valuestring;child->valuestring=0;
	if (*value!=':') {ep=value;return 0;}	/* fail! */
	value=skip(parse_value(child,skip(value+1)));	/* skip any spacing, get the value. */
	if (!value) return 0;
	
	while (*value==',')
	{
		cJSON *new_item;
		if (!(new_item=cJSON_New_Item()))	return 0; /* memory fail */
		child->next=new_item;new_item->prev=child;child=new_item;
		value=skip(parse_string(child,skip(value+1)));
		if (!value) return 0;
		child->string=child->valuestring;child->valuestring=0;
		if (*value!=':') {ep=value;return 0;}	/* fail! */
		value=skip(parse_value(child,skip(value+1)));	/* skip any spacing, get the value. */
		if (!value) return 0;
	}
	
	if (*value=='}') return value+1;	/* end of array */
	ep=value;return 0;	/* malformed. */
}

/* Render an object to text. */
static char *print_object(cJSON *item,int depth,int fmt,printbuffer *p)
{
	char **entries=0,**names=0;
	char *out=0,*ptr,*ret,*str;int len=7,i=0,j;
	cJSON *child=item->child;
	int numentries=0,fail=0;
	size_t tmplen=0;
	/* Count the number of entries. */
	while (child) numentries++,child=child->next;
	/* Explicitly handle empty object case */
	if (!numentries)
	{
		if (p) out=ensure(p,fmt?depth+4:3);
		else	out=(char*)cJSON_malloc(fmt?depth+4:3);
		if (!out)	return 0;
		ptr=out;*ptr++='{';
		if (fmt) {*ptr++='\n';for (i=0;i<depth-1;i++) *ptr++='\t';}
		*ptr++='}';*ptr++=0;
		return out;
	}
	if (p)
	{
		/* Compose the output: */
		i=p->offset;
		len=fmt?2:1;	ptr=ensure(p,len+1);	if (!ptr) return 0;
		*ptr++='{';	if (fmt) *ptr++='\n';	*ptr=0;	p->offset+=len;
		child=item->child;depth++;
		while (child)
		{
			if (fmt)
			{
				ptr=ensure(p,depth);	if (!ptr) return 0;
				for (j=0;j<depth;j++) *ptr++='\t';
				p->offset+=depth;
			}
			print_string_ptr(child->string,p);
			p->offset=update(p);
			
			len=fmt?2:1;
			ptr=ensure(p,len);	if (!ptr) return 0;
			*ptr++=':';if (fmt) *ptr++='\t';
			p->offset+=len;
			
			print_value(child,depth,fmt,p);
			p->offset=update(p);

			len=(fmt?1:0)+(child->next?1:0);
			ptr=ensure(p,len+1); if (!ptr) return 0;
			if (child->next) *ptr++=',';
			if (fmt) *ptr++='\n';*ptr=0;
			p->offset+=len;
			child=child->next;
		}
		ptr=ensure(p,fmt?(depth+1):2);	 if (!ptr) return 0;
		if (fmt)	for (i=0;i<depth-1;i++) *ptr++='\t';
		*ptr++='}';*ptr=0;
		out=(p->buffer)+i;
	}
	else
	{
		/* Allocate space for the names and the objects */
		entries=(char**)cJSON_malloc(numentries*sizeof(char*));
		if (!entries) return 0;
		names=(char**)cJSON_malloc(numentries*sizeof(char*));
		if (!names) {cJSON_free(entries);return 0;}
		memset(entries,0,sizeof(char*)*numentries);
		memset(names,0,sizeof(char*)*numentries);

		/* Collect all the results into our arrays: */
		child=item->child;depth++;if (fmt) len+=depth;
		while (child)
		{
			names[i]=str=print_string_ptr(child->string,0);
			entries[i++]=ret=print_value(child,depth,fmt,0);
			if (str && ret) len+=strlen(ret)+strlen(str)+2+(fmt?2+depth:0); else fail=1;
			child=child->next;
		}
		
		/* Try to allocate the output string */
		if (!fail)	out=(char*)cJSON_malloc(len);
		if (!out) fail=1;

		/* Handle failure */
		if (fail)
		{
			for (i=0;i<numentries;i++) {if (names[i]) cJSON_free(names[i]);if (entries[i]) cJSON_free(entries[i]);}
			cJSON_free(names);cJSON_free(entries);
			return 0;
		}
		
		/* Compose the output: */
		*out='{';ptr=out+1;if (fmt)*ptr++='\n';*ptr=0;
		for (i=0;i<numentries;i++)
		{
			if (fmt) for (j=0;j<depth;j++) *ptr++='\t';
			tmplen=strlen(names[i]);memcpy(ptr,names[i],tmplen);ptr+=tmplen;
			*ptr++=':';if (fmt) *ptr++='\t';
			strcpy(ptr,entries[i]);ptr+=strlen(entries[i]);
			if (i!=numentries-1) *ptr++=',';
			if (fmt) *ptr++='\n';*ptr=0;
			cJSON_free(names[i]);cJSON_free(entries[i]);
		}
		
		cJSON_free(names);cJSON_free(entries);
		if (fmt) for (i=0;i<depth-1;i++) *ptr++='\t';
		*ptr++='}';*ptr++=0;
	}
	return out;	
}

/* Get Array size/item / object item. */
int    cJSON_GetArraySize(cJSON *array)							{cJSON *c=array->child;int i=0;while(c)i++,c=c->next;return i;}
cJSON *cJSON_GetArrayItem(cJSON *array,int item)				{cJSON *c=array->child;  while (c && item>0) item--,c=c->next; return c;}
cJSON *cJSON_GetObjectItem(cJSON *object,const char *string)	{cJSON *c=object->child; while (c && cJSON_strcasecmp(c->string,string)) c=c->next; return c;}

/* Utility for array list handling. */
static void suffix_object(cJSON *prev,cJSON *item) {prev->next=item;item->prev=prev;}
/* Utility for handling references. */
static cJSON *create_reference(cJSON *item) {cJSON *ref=cJSON_New_Item();if (!ref) return 0;memcpy(ref,item,sizeof(cJSON));ref->string=0;ref->type|=cJSON_IsReference;ref->next=ref->prev=0;return ref;}

/* Add item to array/object. */
void   cJSON_AddItemToArray(cJSON *array, cJSON *item)						{cJSON *c=array->child;if (!item) return; if (!c) {array->child=item;} else {while (c && c->next) c=c->next; suffix_object(c,item);}}
void   cJSON_AddItemToObject(cJSON *object,const char *string,cJSON *item)	{if (!item) return; if (item->string) cJSON_free(item->string);item->string=cJSON_strdup(string);cJSON_AddItemToArray(object,item);}
void   cJSON_AddItemToObjectCS(cJSON *object,const char *string,cJSON *item)	{if (!item) return; if (!(item->type&cJSON_StringIsConst) && item->string) cJSON_free(item->string);item->string=(char*)string;item->type|=cJSON_StringIsConst;cJSON_AddItemToArray(object,item);}
void	cJSON_AddItemReferenceToArray(cJSON *array, cJSON *item)						{cJSON_AddItemToArray(array,create_reference(item));}
void	cJSON_AddItemReferenceToObject(cJSON *object,const char *string,cJSON *item)	{cJSON_AddItemToObject(object,string,create_reference(item));}

cJSON *cJSON_DetachItemFromArray(cJSON *array,int which)			{cJSON *c=array->child;while (c && which>0) c=c->next,which--;if (!c) return 0;
	if (c->prev) c->prev->next=c->next;if (c->next) c->next->prev=c->prev;if (c==array->child) array->child=c->next;c->prev=c->next=0;return c;}
void   cJSON_DeleteItemFromArray(cJSON *array,int which)			{cJSON_Delete(cJSON_DetachItemFromArray(array,which));}
cJSON *cJSON_DetachItemFromObject(cJSON *object,const char *string) {int i=0;cJSON *c=object->child;while (c && cJSON_strcasecmp(c->string,string)) i++,c=c->next;if (c) return cJSON_DetachItemFromArray(object,i);return 0;}
void   cJSON_DeleteItemFromObject(cJSON *object,const char *string) {cJSON_Delete(cJSON_DetachItemFromObject(object,string));}

/* Replace array/object items with new ones. */
void   cJSON_InsertItemInArray(cJSON *array,int which,cJSON *newitem)		{cJSON *c=array->child;while (c && which>0) c=c->next,which--;if (!c) {cJSON_AddItemToArray(array,newitem);return;}
	newitem->next=c;newitem->prev=c->prev;c->prev=newitem;if (c==array->child) array->child=newitem; else newitem->prev->next=newitem;}
void   cJSON_ReplaceItemInArray(cJSON *array,int which,cJSON *newitem)		{cJSON *c=array->child;while (c && which>0) c=c->next,which--;if (!c) return;
	newitem->next=c->next;newitem->prev=c->prev;if (newitem->next) newitem->next->prev=newitem;
	if (c==array->child) array->child=newitem; else newitem->prev->next=newitem;c->next=c->prev=0;cJSON_Delete(c);}
void   cJSON_ReplaceItemInObject(cJSON *object,const char *string,cJSON *newitem){int i=0;cJSON *c=object->child;while(c && cJSON_strcasecmp(c->string,string))i++,c=c->next;if(c){newitem->string=cJSON_strdup(string);cJSON_ReplaceItemInArray(object,i,newitem);}}

/* Create basic types: */
cJSON *cJSON_CreateNull(void)					{cJSON *item=cJSON_New_Item();if(item)item->type=cJSON_NULL;return item;}
cJSON *cJSON_CreateTrue(void)					{cJSON *item=cJSON_New_Item();if(item)item->type=cJSON_True;return item;}
cJSON *cJSON_CreateFalse(void)					{cJSON *item=cJSON_New_Item();if(item)item->type=cJSON_False;return item;}
cJSON *cJSON_CreateBool(int b)					{cJSON *item=cJSON_New_Item();if(item)item->type=b?cJSON_True:cJSON_False;return item;}
cJSON *cJSON_CreateNumber(double num)			{cJSON *item=cJSON_New_Item();if(item){item->type=cJSON_Number;item->valuedouble=num;item->valueint=(int)num;}return item;}
cJSON *cJSON_CreateString(const char *string)	{cJSON *item=cJSON_New_Item();if(item){item->type=cJSON_String;item->valuestring=cJSON_strdup(string);}return item;}
cJSON *cJSON_CreateArray(void)					{cJSON *item=cJSON_New_Item();if(item)item->type=cJSON_Array;return item;}
cJSON *cJSON_CreateObject(void)					{cJSON *item=cJSON_New_Item();if(item)item->type=cJSON_Object;return item;}

/* Create Arrays: */
cJSON *cJSON_CreateIntArray(const int *numbers,int count)		{int i;cJSON *n=0,*p=0,*a=cJSON_CreateArray();for(i=0;a && i<count;i++){n=cJSON_CreateNumber(numbers[i]);if(!i)a->child=n;else suffix_object(p,n);p=n;}return a;}
cJSON *cJSON_CreateFloatArray(const float *numbers,int count)	{int i;cJSON *n=0,*p=0,*a=cJSON_CreateArray();for(i=0;a && i<count;i++){n=cJSON_CreateNumber(numbers[i]);if(!i)a->child=n;else suffix_object(p,n);p=n;}return a;}
cJSON *cJSON_CreateDoubleArray(const double *numbers,int count)	{int i;cJSON *n=0,*p=0,*a=cJSON_CreateArray();for(i=0;a && i<count;i++){n=cJSON_CreateNumber(numbers[i]);if(!i)a->child=n;else suffix_object(p,n);p=n;}return a;}
cJSON *cJSON_CreateStringArray(const char **strings,int count)	{int i;cJSON *n=0,*p=0,*a=cJSON_CreateArray();for(i=0;a && i<count;i++){n=cJSON_CreateString(strings[i]);if(!i)a->child=n;else suffix_object(p,n);p=n;}return a;}

/* Duplication */
cJSON *cJSON_Duplicate(cJSON *item,int recurse)
{
	cJSON *newitem,*cptr,*nptr=0,*newchild;
	/* Bail on bad ptr */
	if (!item) return 0;
	/* Create new item */
	newitem=cJSON_New_Item();
	if (!newitem) return 0;
	/* Copy over all vars */
	newitem->type=item->type&(~cJSON_IsReference),newitem->valueint=item->valueint,newitem->valuedouble=item->valuedouble;
	if (item->valuestring)	{newitem->valuestring=cJSON_strdup(item->valuestring);	if (!newitem->valuestring)	{cJSON_Delete(newitem);return 0;}}
	if (item->string)		{newitem->string=cJSON_strdup(item->string);			if (!newitem->string)		{cJSON_Delete(newitem);return 0;}}
	/* If non-recursive, then we're done! */
	if (!recurse) return newitem;
	/* Walk the ->next chain for the child. */
	cptr=item->child;
	while (cptr)
	{
		newchild=cJSON_Duplicate(cptr,1);		/* Duplicate (with recurse) each item in the ->next chain */
		if (!newchild) {cJSON_Delete(newitem);return 0;}
		if (nptr)	{nptr->next=newchild,newchild->prev=nptr;nptr=newchild;}	/* If newitem->child already set, then crosswire ->prev and ->next and move on */
		else		{newitem->child=newchild;nptr=newchild;}					/* Set newitem->child and move to it */
		cptr=cptr->next;
	}
	return newitem;
}

void cJSON_Minify(char *json)
{
	char *into=json;
	while (*json)
	{
		if (*json==' ') json++;
		else if (*json=='\t') json++;	/* Whitespace characters. */
		else if (*json=='\r') json++;
		else if (*json=='\n') json++;
		else if (*json=='/' && json[1]=='/')  while (*json && *json!='\n') json++;	/* double-slash comments, to end of line. */
		else if (*json=='/' && json[1]=='*') {while (*json && !(*json=='*' && json[1]=='/')) json++;json+=2;}	/* multiline comments. */
		else if (*json=='\"'){*into++=*json++;while (*json && *json!='\"'){if (*json=='\\') *into++=*json++;*into++=*json++;}*into++=*json++;} /* string literals, which are \" sensitive. */
		else *into++=*json++;			/* All other characters. */
	}
	*into=0;	/* and null-terminate. */
}

================
File: Raspberry_Pi/cJSON.h
================
/*
  Copyright (c) 2009 Dave Gamble
 
  Permission is hereby granted, free of charge, to any person obtaining a copy
  of this software and associated documentation files (the "Software"), to deal
  in the Software without restriction, including without limitation the rights
  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
  copies of the Software, and to permit persons to whom the Software is
  furnished to do so, subject to the following conditions:
 
  The above copyright notice and this permission notice shall be included in
  all copies or substantial portions of the Software.
 
  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
  THE SOFTWARE.
*/

#ifndef cJSON__h
#define cJSON__h

#ifdef __cplusplus
extern "C"
{
#endif

/* cJSON Types: */
#define cJSON_False 0
#define cJSON_True 1
#define cJSON_NULL 2
#define cJSON_Number 3
#define cJSON_String 4
#define cJSON_Array 5
#define cJSON_Object 6
	
#define cJSON_IsReference 256
#define cJSON_StringIsConst 512

/* The cJSON structure: */
typedef struct cJSON {
	struct cJSON *next,*prev;	/* next/prev allow you to walk array/object chains. Alternatively, use GetArraySize/GetArrayItem/GetObjectItem */
	struct cJSON *child;		/* An array or object item will have a child pointer pointing to a chain of the items in the array/object. */

	int type;					/* The type of the item, as above. */

	char *valuestring;			/* The item's string, if type==cJSON_String */
	int valueint;				/* The item's number, if type==cJSON_Number */
	double valuedouble;			/* The item's number, if type==cJSON_Number */

	char *string;				/* The item's name string, if this item is the child of, or is in the list of subitems of an object. */
} cJSON;

typedef struct cJSON_Hooks {
      void *(*malloc_fn)(size_t sz);
      void (*free_fn)(void *ptr);
} cJSON_Hooks;

/* Supply malloc, realloc and free functions to cJSON */
extern void cJSON_InitHooks(cJSON_Hooks* hooks);


/* Supply a block of JSON, and this returns a cJSON object you can interrogate. Call cJSON_Delete when finished. */
extern cJSON *cJSON_Parse(const char *value);
/* Render a cJSON entity to text for transfer/storage. Free the char* when finished. */
extern char  *cJSON_Print(cJSON *item);
/* Render a cJSON entity to text for transfer/storage without any formatting. Free the char* when finished. */
extern char  *cJSON_PrintUnformatted(cJSON *item);
/* Render a cJSON entity to text using a buffered strategy. prebuffer is a guess at the final size. guessing well reduces reallocation. fmt=0 gives unformatted, =1 gives formatted */
extern char *cJSON_PrintBuffered(cJSON *item,int prebuffer,int fmt);
/* Delete a cJSON entity and all subentities. */
extern void   cJSON_Delete(cJSON *c);

/* Returns the number of items in an array (or object). */
extern int	  cJSON_GetArraySize(cJSON *array);
/* Retrieve item number "item" from array "array". Returns NULL if unsuccessful. */
extern cJSON *cJSON_GetArrayItem(cJSON *array,int item);
/* Get item "string" from object. Case insensitive. */
extern cJSON *cJSON_GetObjectItem(cJSON *object,const char *string);

/* For analysing failed parses. This returns a pointer to the parse error. You'll probably need to look a few chars back to make sense of it. Defined when cJSON_Parse() returns 0. 0 when cJSON_Parse() succeeds. */
extern const char *cJSON_GetErrorPtr(void);
	
/* These calls create a cJSON item of the appropriate type. */
extern cJSON *cJSON_CreateNull(void);
extern cJSON *cJSON_CreateTrue(void);
extern cJSON *cJSON_CreateFalse(void);
extern cJSON *cJSON_CreateBool(int b);
extern cJSON *cJSON_CreateNumber(double num);
extern cJSON *cJSON_CreateString(const char *string);
extern cJSON *cJSON_CreateArray(void);
extern cJSON *cJSON_CreateObject(void);

/* These utilities create an Array of count items. */
extern cJSON *cJSON_CreateIntArray(const int *numbers,int count);
extern cJSON *cJSON_CreateFloatArray(const float *numbers,int count);
extern cJSON *cJSON_CreateDoubleArray(const double *numbers,int count);
extern cJSON *cJSON_CreateStringArray(const char **strings,int count);

/* Append item to the specified array/object. */
extern void cJSON_AddItemToArray(cJSON *array, cJSON *item);
extern void	cJSON_AddItemToObject(cJSON *object,const char *string,cJSON *item);
extern void	cJSON_AddItemToObjectCS(cJSON *object,const char *string,cJSON *item);	/* Use this when string is definitely const (i.e. a literal, or as good as), and will definitely survive the cJSON object */
/* Append reference to item to the specified array/object. Use this when you want to add an existing cJSON to a new cJSON, but don't want to corrupt your existing cJSON. */
extern void cJSON_AddItemReferenceToArray(cJSON *array, cJSON *item);
extern void	cJSON_AddItemReferenceToObject(cJSON *object,const char *string,cJSON *item);

/* Remove/Detatch items from Arrays/Objects. */
extern cJSON *cJSON_DetachItemFromArray(cJSON *array,int which);
extern void   cJSON_DeleteItemFromArray(cJSON *array,int which);
extern cJSON *cJSON_DetachItemFromObject(cJSON *object,const char *string);
extern void   cJSON_DeleteItemFromObject(cJSON *object,const char *string);
	
/* Update array items. */
extern void cJSON_InsertItemInArray(cJSON *array,int which,cJSON *newitem);	/* Shifts pre-existing items to the right. */
extern void cJSON_ReplaceItemInArray(cJSON *array,int which,cJSON *newitem);
extern void cJSON_ReplaceItemInObject(cJSON *object,const char *string,cJSON *newitem);

/* Duplicate a cJSON item */
extern cJSON *cJSON_Duplicate(cJSON *item,int recurse);
/* Duplicate will create a new, identical cJSON item to the one you pass, in new memory that will
need to be released. With recurse!=0, it will duplicate any children connected to the item.
The item->next and ->prev pointers are always zero on return from Duplicate. */

/* ParseWithOpts allows you to require (and check) that the JSON is null terminated, and to retrieve the pointer to the final byte parsed. */
extern cJSON *cJSON_ParseWithOpts(const char *value,const char **return_parse_end,int require_null_terminated);

extern void cJSON_Minify(char *json);

/* Macros for creating things quickly. */
#define cJSON_AddNullToObject(object,name)		cJSON_AddItemToObject(object, name, cJSON_CreateNull())
#define cJSON_AddTrueToObject(object,name)		cJSON_AddItemToObject(object, name, cJSON_CreateTrue())
#define cJSON_AddFalseToObject(object,name)		cJSON_AddItemToObject(object, name, cJSON_CreateFalse())
#define cJSON_AddBoolToObject(object,name,b)	cJSON_AddItemToObject(object, name, cJSON_CreateBool(b))
#define cJSON_AddNumberToObject(object,name,n)	cJSON_AddItemToObject(object, name, cJSON_CreateNumber(n))
#define cJSON_AddStringToObject(object,name,s)	cJSON_AddItemToObject(object, name, cJSON_CreateString(s))

/* When assigning an integer value, it needs to be propagated to valuedouble too. */
#define cJSON_SetIntValue(object,val)			((object)?(object)->valueint=(object)->valuedouble=(val):(val))
#define cJSON_SetNumberValue(object,val)		((object)?(object)->valueint=(object)->valuedouble=(val):(val))

#ifdef __cplusplus
}
#endif

#endif

================
File: Raspberry_Pi/Raspberry_Pi.c
================
#include "Raspberry_Pi.h"

//树莓派缓存区
static RASPBERRY raspberry_temp;

void Raspberry_modedataIN(MODE mode)
{
    raspberry_temp.mode = mode; //设置模式
}

void Raspberry_getmodedata(RASPBERRY *raspberry)
{
    raspberry->mode = raspberry_temp.mode; //获取模式
}

void Raspberry_modedata_updateIN(int status)
{
    raspberry_temp.status.modedata_update = status; //更新模式数据状态
}

void Raspberry_getmodedata_update(RASPBERRY *raspberry)
{
    raspberry->status.modedata_update = raspberry_temp.status.modedata_update; //获取模式数据更新状态)
    //置位才清零标志位
    if(raspberry_temp.status.modedata_update == 1)
    {
        raspberry_temp.status.modedata_update = 0; //清零标志位
    }
}


void Raspberry_runIN(int run)
{
    raspberry_temp.status.run = run; //更新运行状态
}

void Raspberry_getrun(RASPBERRY *raspberry)
{
    raspberry->status.run = raspberry_temp.status.run; //获取运行状态
    //置位才清零标志位
    if(raspberry_temp.status.run == 1)
    {
        raspberry_temp.status.run = 0; //清零标志位
    }
}


void Raspberry_startIN(int start)
{
    raspberry_temp.status.start = start; //更新开始状态
}

void Raspberry_getstart(RASPBERRY *raspberry)
{
    raspberry->status.start = raspberry_temp.status.start; //获取开始状态
    //置位才清零标志位
    if(raspberry_temp.status.start == 1)
    {
        raspberry_temp.status.start = 0; //清零标志位
    }
}

================
File: Raspberry_Pi/Raspberry_Pi.h
================
#ifndef _RASPBERRY_PI_H
#define _RASPBERRY_PI_H

#include "string.h"

typedef struct{
     int modedata_update;
     int run;   //运行指令
     int start; //开始指令
}RASPBERRY_STATUS;

typedef struct{
     char park;
     int target;
}MODE;

typedef struct
{
    MODE mode; // 模式
	volatile RASPBERRY_STATUS status;
}RASPBERRY;

//获得模式数据
void Raspberry_modedataIN(MODE mode);
void Raspberry_getmodedata(RASPBERRY *raspberry);
void Raspberry_modedata_updateIN(int status);
void Raspberry_getmodedata_update(RASPBERRY *raspberry);

//获取运行指令
void Raspberry_runIN(int run);
void Raspberry_getrun(RASPBERRY *raspberry);

//获取开始指令
void Raspberry_startIN(int start);
void Raspberry_getstart(RASPBERRY *raspberry);

#endif

================
File: Raspberry_Pi/Raspberry_uart.c
================
#include "Raspberry_uart.h"

#define BUFFER_SIZE 1000
unsigned char raspberry_cmd_buffer[BUFFER_SIZE]; //命令缓冲区
char raspberry_cmd[1000];


//树莓派串口中断初始化
void Raspberry_uartinit(void)
{
   usart_rx_it_start(Raspberry_Pi_UART_INST_INT_IRQN);
}

void Raspberry_Pi_UART_INST_IRQHandler(void)
{
			static int i = 0;
            uint8_t raspberry_uctemp = usart_receivebyte(Raspberry_UART);

	  if (raspberry_uctemp != '\n' && i < BUFFER_SIZE - 1) {
            raspberry_cmd_buffer[i++] = raspberry_uctemp;
        }
		 
	 else 
		{
					raspberry_cmd_buffer[i] = '\0'; // 完成字符串
					i = 0; // 重置索引
			
		   cJSON *json = cJSON_Parse((char *)raspberry_cmd_buffer);
		
		  if (json) {
				 cJSON *json_command = cJSON_GetObjectItem(json, "cmd");
		
			   if (json_command && json_command->type == cJSON_String) 
	  			{
            strcpy(raspberry_cmd, json_command->valuestring); // 更新全局变量cmd
  				if(strcmp(raspberry_cmd,"ping") == 0)
				 {
					// 发送响应
					Raspberry_printf("{\"cmd\":\"ping\",\"result\":true}\n");
				}
				else if(strcmp(raspberry_cmd,"mode") == 0)
				{ 
				  MODE mode;
				  cJSON *park_json = cJSON_GetObjectItem(json, "park");
			       mode.park = park_json->valuestring[0];
  
				  cJSON *target_json = cJSON_GetObjectItem(json, "target");
				   mode.target = target_json->valueint;

				  Raspberry_modedataIN(mode);
				  Raspberry_modedata_updateIN(1); //更新模式数据状态
			
				}
				else if(strcmp(raspberry_cmd,"run") == 0)
				{ 
			      Raspberry_runIN(1); //更新运行状态
				}
				else if(strcmp(raspberry_cmd,"start") == 0)
				{ 
				  Raspberry_startIN(1); //更新开始状态
				}



				memset(raspberry_cmd_buffer,'\0',sizeof(raspberry_cmd_buffer));
				memset(raspberry_cmd,'\0',sizeof(raspberry_cmd));
		     }
        }
	      cJSON_Delete(json);	
      }
}

================
File: Raspberry_Pi/Raspberry_uart.h
================
#ifndef _RASPBERRY_UART_H 
#define _RASPBERRY_UART_H

#include "serial.h"
#include "cJSON.h"
#include "string.h"
#include "stdio.h"
#include "stdlib.h"
#include "Raspberry_Pi.h"
#include "ti_msp_dl_config.h"

#define Raspberry_UART  Raspberry_Pi_UART_INST
#define Raspberry_printf(fmt, ...)  usart_printf(Raspberry_UART, fmt, ##__VA_ARGS__)

void Raspberry_uartinit(void);


#endif

================
File: README.html
================
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
  <meta http-equiv="Content-Style-Type" content="text/css" />
  <meta name="generator" content="pandoc" />
  <title>Readme</title>
  <style type="text/css">code{white-space: pre;}</style>
  <link href="data:text/css;charset=utf-8,%0A%0A%0A%0A%40font%2Dface%20%7B%0Afont%2Dfamily%3A%20%27Open%20Sans%27%3B%0Afont%2Dstyle%3A%20normal%3B%0Afont%2Dweight%3A%20400%3B%0Asrc%3A%20url%28%27data%3Afont%2Fwoff2%3Bbase64%2Cd09GMgABAAAAADzUABIAAAAAhjgAADxwAAEZmgAAAAAAAAAAAAAAAAAAAAAAAAAAGhYbDBx0BmAAgUwIgSIJjzQREAqBpESBjUIBNgIkA4ZsE70QC4M8AAQgBYIyB4QoDIIJG8J3CQg7WxX5j0PthLRbJVvedpUoKlTzFUWwcUCG52fZ%2F%2F%2F%2F%2F3lJxxAlWAMiaNd12%2F9PqJmJKW5iyEExieloQ9KxVuZAQ07T1g7vfgVloomBA%2FUEiuEMCGVsPBsLc9rD3dPKhTisOejgNULCLyjxoeYlBGuZsjRKads6GS6b8QRDIttvKSa68bAbLrwP31TZsuGVyrv7lPcTS4bG9tKpUh76wlIon84X%2FsDUs5lHxlTP%2Fif%2BNs2eosU%2Fnf%2FBfw%2FriGqqb%2BffLOvzVA9JiiYPkV3xr7qrZ%2Fbum4pAxULkIPkZgBBQJu%2F2AG2zs1GxcgYq2FMQpj1RETESsbAKmzJyopiJzNnDKkTX5pwurDm2%2Fl%2BkLvK%2F%2Bx%2FAP6A2ZgrZRvjS1KSQBer9XuGyk3Iw3zfX%2B1eWZFmG4CQDj7CYnr8CXBV4ueyfuup7tsiSJbYtuxH%2FjmfaSz7qPupZoCCZ%2BkF0QXRpQIvhcQTov6omea3KKY0pFP4oK73IomFDl%2BISgLSDg2T3m9LqWHnZhsdUX6Zbs2x9S8bARE7Ay%2By7Qf%2FnllVniRftubDauc4suapKNQPzE8citiadRhUeQAB2Or6gcE01zLrqvv3azJyYfdvFLJRBRNN%2BrORtiKb4r90jEQolkS9CXdeapUUtovJYdjvKac7KcpzMaA1l%2FuGrT4aVVrGvMVAuLrBgPpJTtAv0AsQv4mpVYhTdrISsR3HVOUDRuJh4nIdPy752XK3pgwsJHaOiCfRBCMYnBZa2NQIs0MJBCLKQcLAUFiLHsSb1NBwDuVM%2B%2BS0pbMpCb4wnNT80UzMTE9QxNEqUXUj%2BXtWyBRikfCGFLhWNnelMh67A%2Bx%2BBHyAogRS0C1I6L0lJt9RGUJGUzgZAjQekU04ENxHSBYHaRMdLMVd257vKTeW69pbnoi9NTzZ4puUyQp2QCOOWBcHlBVHZINQPsqpeQjArJqPxaQKweFrTR1P%2Fk%2BXq%2B%2FE66DKZ2KGI2ZjJZNOIfxEploB4nMfYbCEuPnLbpwkSihwCCsbniQTAguiPVErkU4mUNL%2BUgcJFiymBc06kZQAgwjK%2Bx5hwzplJMQDIJhWEDSTOGJKlWpoIMEUadBm6RwiOj8PFkZ74BMmB3NPHvuQZdmtwhPKxaCIC1O5pSECsQvXqWxLjy0SwLDAMtWW45JcEf9qVQU4AAOvKcpvthncBrrn3f6P2TFH5pL6ErAoIPAgbyH0bD2BVQtHJQvXeU9iytiHI6oIFw3FX7KYd%2Fws48OV6eVger6oIUYdoQXQh%2BhBbCAZCg0ws5P%2F%2F30%2BhOw99btm1DAYcrQBRhWi8jM0FaH419ud9hVS%2F0ut62vSv6Q%2FT11%2BiySYajVNbtUV%2Fb5%2FexPSeyXTDklT41IpZiv4R2m3Dfcp9KWoG9CMAOmZLgoOTwv9t%2FXjG7O9no%2FSNV51dlkUn2AXcpNQTLI0adKlSGjJgNWg3YlhoCCEQH%2BDv5%2Bvj7eXp4Y5zw7piXJyd0I6nHeztbG2srSxPIeDmZidNDQ30YVA9XR1tprpw1uhWsieLKhwIhGlDCFAphITMFTNSlJXCvFS7BnGYV1RMYWUSk86rwpJKpWQBZbBSCbm2Z1laCiZ6RfcBbuU87snz7Dx7R5L4WZIjvKrod%2BrtYCMx9O8mwhLRGcX3ibFESNJCqbD2cGBXU%2FncuJtPLlOhOxfmmcPUG5mPZuIouu1w9CKPimlUnXUEk4VEgpJLUlkHBxWtYuH7JsyXkXXj7AS4sDsaU8uIxeWw2Z6h9iA3uWnrBnnWSoOFDnWyWxohn666Da3a54egEGCM4tGe%2Fq6VLupikmKFCY7LkmodtkTc48IxKTyS9g%2BEon9%2FU0Gfmor%2F91YEWgYeaf9eEUU9e7fPaySLVll%2FZPSApEe2n04%2F31YHDfx09bMcma9lC2vvLpFPB%2FysabdbsZqgVGlqkCjKQZaCw9RL5J8Wfq78fbpRRBgkAAxoN%2B77EOTWB8wGH4agD%2FWBsmqI94A%2BFBiQym357qjcbDkjVNVS8mFxqGkbhEW5Q0rbxes%2B9DWsbK1TFiIP2X%2Fhky3m5JlDhoxIiRi5oUREAgQUJuwkwnKXsPYD82bP2nAFm5nLbZFniAVCw4pU%2Bqg9HOyqPE6GeWwEVpAL1OD4ReXMWGnlZg8RK1l6TAzjjnw3zNBtlCkyLGpSVg1rGp%2BrMhHlAiC6HaUwo4ZUViqrXkR1biihit4A5P8VJcWHBXYcMDHm%2BVEtaISkshedHnqp6MBKe1ILH2yAviHdNTbXS94mvwv%2FXjJusom6TmqUVBr6dCPYTMTqM4WFYrEPaeGMiEBczEg9JsYNFvESiiy%2BaBSdP6UREzNPxAMb5yCrnRydl5oLRghNYHpYqm5Mgj6bGcLtSEgUSpzEqZvZQFUoCd%2F491qYH9vIUigQkxnUr0rZ1DjE2gzGWOAk0qO4y%2BJrS01dMjSQ4BtaLQQN1jAHBNY3Z6by%2BicjUAwNoFPEHxGQX4a1QACbwPpnIaq0UdSymS9t3E1qlrFMKJ%2FBEWWA%2FWb4dE4kRd6bmY5kiLfD64zt8%2BWeHB%2BcZTDDLXesW9PnCSGUaC%2FE0%2Fg8RZElPKlHYd4R7O5c%2FqbimL%2BpNfRGnjFI1Yl%2BT0jLaWSclz9Gb1iMoXN8hCL0wWchLqS69sXHGrHBDM6USOEEjrLDEcJdS7xNCJA%2Fn3BSiMbMyQ2EY0xIu4G4X%2BP7uAO45rs8N8kzl2cvL4xlqOUwSd5HLl85EA942MMMthyFVM0aP%2BLaJViU0jrK0n3ILadidX5Df0hDFXwCIWJ0r4T58QM6uleTuOxYSd5zM7DK9LQcKM%2BQeJzGwd2LDM6BRtSKpoM5txsh5UZ5vkuBS74pKpYGVnlVvQ5o%2BQbwNE%2B9qX3yYO35Jmz%2Bn5HIpUfJ2vyfcGnkNDFvIWM3%2Bl0SAJ48tws8taOvAL%2BPojsDoRsZILghY5rGbIwyhURLrWp55YC9KERyteUrrJvBxgK83RyXPcVHMCoV1zkeyAymKLA4qBuCE17rUFLPeFWiZKX9NFIPkWfjuZHm4voKGHuz5gt7xXpTvCZPhpARHTMjea8%2FwnPKhOSEpZhhrY3kuKgm88Euz4ZRsxiLqrUUXDCM2Sh%2FKjJmOI83BylGUktaOGk4F61UfJ35fCC5yHDGsBjkhYxBFaw8KhGxVNLhVakk7yq4dSzlWFZijCc1zkeTkYwYnyJoLlobOWOUa2uxks1KRCtDLiVjk7zikMsiyxS%2FO%2BRxwCZCqTBKXOZTycx5EuMsI%2Fy25wHe4lzgXyOx2rgm%2FVNMKc6TRgCgiHfgRiM%2FFYcSvBA7nUJ2UqhAvL6znIECFAsKRIF0WBJkLQgKX9nAKe6KytVSyscM%2FYoBzpAcZ0LQDwAHwYTaxCTnK7Eg7dJpjEys%2BmX%2BymSpJybTABwIUK3FISB%2BvfEPpaYfX6dhYCS%2FArvbXpMxAOujddHcKCy9oAuosBwO%2Fd66aodBZ6D7bZbgOVjxhKzQcG9DNEl3hATNHPFDklxcc4NylfRkG88t2VfSoUwj1nL97IcKprRrU0xLaftUQLvKqBE0YCLFJ3XjQTVlx5kKoTYQIvTnMDpYqQumFfIquUaT3%2BTlFnBAUcDaS6Ykgm4D6mHZ3T5LS7ASqCHVNII69RkiqGYX8m%2BKFuRyLBfKpASn%2BovFuh8NjOEFNgt3km%2FK1AYKDnTQbKHVKfxpUg74CJVZ%2FQzVmPSrAGHPRrKIU8EQJywFPBHiZyoRp9ZiqatfCUYZAy10RUjDNhY0ApFk%2FRCyRru7v1GbH2EdpTUYrJNxdP9Ib3%2BKy%2BLdDlcvu7brITIlW20bGBWyvH0bbUTBXw42%2BLKEajBc93Xyvzg460i8KDqQpbI8P3hvRfdjuH3yYpVuP7ea3AJpxwwZtyHxnXa%2FnKVrKjEQL0ouoeIxVpsuMrmtKoWLpgAemjUmg13xepWbjuhaStVsQCvFIriQZRKfAWu5xpjxjqLR%2B92hNWoQUpec70wOSdjJSPAalndek2pgvd9VjXFyCq44wwNIpqzRTtwaEINuYuVywyQb9DmkDnaB%2BQq%2FKBrBntgVwLySNWNI3LTiTgU3U4wpJTHRMn%2BLtfsYleDP1XfFrU2cbdHOGW1GMxq7WE17UZzrbpJsXeX1zvkSyQmmvmRPyMTrQqFtbSYuvTlGSycJKvDElm2kcqatiRtM%2BXAOliz6XR6Ql9bpw5unABUyOZmgUjozRPHLFnqBm%2FwT1OcWK8qbpMEwmn6fkxQEFdGYoZxDwFdZbaHVC%2FztMekCVCMn9lawhkKL7TRk45pkUC%2B5tZSrFzs5CgqwTej3T7yWhaE5gLHwn%2B0h%2B1rVeqVTATVL7Tx7iWvUzv%2FJv4Af1N%2B6fX3rQ6vzx0zd7AM9pZGZ08pB7ixFyHMPMxRekmvk8%2B3fknvFVjbKAAscRdHPQn3bUdqk4DItx4uAP4uJoEdaEbR9%2BhVL1jrs8QEmOsah78uflhUlTGTIDO74%2BgLrewWOW3kkDAFWPFFoTSDBczNkV%2BTIpFW0FdcpU7qk8OkJ36V4143X8%2FRiB6b0k02n%2BPhuQfsjDBbaNp6O24mTETI5ypKMLGM%2BSlrrls1SDdfGMEMfrBVHTthLvtRiagZGJqAA2xWj%2FLQSS0wDnrjYqKDWY%2FRsARcIH4dVTFwMoU%2Bztku1jDMPKPHUi0CfPBUERXHmkBwha9YGGWoT4OvQAnlRhh0FcT9RN9eB9p2k9lUBEL4Kdj9SqUBb3XloMCJaYYQk4unEKTGtoGNjJ0UjPt%2BF0WKcKYdukt4QMO73z5xqVuff5E9rtA%2FfYyz%2FMnjX2wNnKQ6l27H9CWD%2BRO1%2B1pn9i7z%2FJfyrHBDGtR4e3FSyagyypIf%2BrO7UH43VZHiezC5WmiLqWU%2BxfgZqHdvoYE0uUczILmJXnvYQMuvrM9eFXgB8GyglGRDci42j%2F97nBN%2Fc2w9KTWDMBTid2ylcc0NoRoKMCdY%2B9XNfyvR1x19xfBrMibf6RUaTKowUrS5N7Dy3sl8q6yweBdOJHvfOYiQnu8iCUlX75Ez%2ByPPLUvSO5cXrlTFVGP2yqazi%2BDhaRUHVMTJzYyZcq0nRnU9ws8xROWtlaAxirS8Tbqt4mbE2nUu2ExdSdJ1Dt2%2FjOykL4PKLdSEIpa8QNypx84hVFSRca1604waGkUD0TyhAH%2FRT2vxpWMp0yEZk9toonGknwSgn97RBT1ampeL6tJ%2FCfGT4kdwVLcjyqvbqO67OKxmgbJzJWVBM5mqTNsYBERk3uj8adjIxDI%2BZHZM8eh835zUILIO2%2BSXKwJp9UIGbuKzbWJZ2NadauiyPJhjjgDOiMrQMWYVi8Vc2bUH2U%2BrnIASPySLy%2B6FkoLOAyxMMvE85z04IXu4pv%2BjPSofeKtXzYo3loMlVucEoR1aBZtgFt7Uk1A8CTZfhJlFQSN9GQQcIfRJ%2F0WFcWY1XK0BA4YkZuXRbkev7njNeq0XSet7ub29Cdc6t6TT5P6n%2FDEquLSQhlN6OtJJXVa7taVdntCPWBuVy2kThB89AhmQoY9JUclVtB3yZE%2F5EKRI%2FWR31zf0nq3wnRUu1XfBKJSb%2B87VxAAI%2FX7ErAZUgZgPNnfDmXeiVlaqbMzzlt6XPsvZ0nbW6A6D3zUKXbqGHxqvKtoc5crxS7qLwGAbJaLPtkpjrRpyNdM8fjceFhJSYMO9r6iLFvEKJGYZlsTIJ4YkyUMEx91H8UGDAEN59eGv0JettWx37%2BNmLtlctzWeP1eNg4%2B4jgYG%2BnMlx36HAQPeh7bEXxQc1sI6fag097394Tlss8Fq3N2tXtZetrm6FQcFnPOKL8d6J0UGhGVHi3LgvPV3c4QwXYohJghOdXYX9k1GzOZ8QGGkfo0ey6Vgbnh64wGlPreR2h3dUFDlzlGNHXDSrWo11Xy3N0knfiB38owN%2FfZ1biv5wcfbt5smBxuWm298%2Ft27VXO5rGe3a0JCEi7E3mof7ai61bn%2F%2B%2FvdtpXF5oGWq646GkbKicU19htpCodYv1%2FGIaVIvaTrii2uulsZCRYZxDdzwQKW7pnusdoxdw56oNYw4fq0WFwNCkYvUk9AIMFEOf5%2F1gSXXSXKxx9jYojEuTk6uNkjn06onF3i6SjzO5v9mKzjvPyn4SP959KOYUnxM%2Fv7xZyniS4Zju%2B4Qp03fzq4NyhlqhxjeHJBniFExDgfjwWSGcR0UttJ4hjE9m9lp1Yin11cVEwfs4nyCs7aGP955tz9Xe1bmcMfRGvTZ5PTLyLru2UZN0LTS6HzLns5vkrRl3TCTnkize%2FDoAiOJgabGlvHNjorUlrzi6FFkmis%2BMxT73o9x%2BGHVBdvv98Cv12%2Bz2STuyQz%2FQe7rRvF5kHlUz41qe92Dojegl5svIAL%2F%2FSr16XM13bFImFk9f84iJ6pHg2BpOc7vcofyKMq2tKxpnzEcGS3f6KUa9%2BEXVNIGnD7%2BceP58a2XfwjffSEe%2BH6zoXtutLn5fHNYu3tIKTbJd7YlCaMJe6Wp2XWbCUtAaEOZN2%2B8uzCUxpxtwc0Gtl8s4P17%2F8n7v29d%2FhtRW%2B2dw83qfX9ZjBaWy2F2tp%2BvzY8527GCbXNkshUGk4rqc%2BLD6WU9Tg122dXhCU3Z3s54bBiL5qLQ6KuW%2BPm7oYQF2DJgIYiy%2BuLN7sv%2FxHbbn7JyoB%2FMG88uDjU1DrUSWe7BJViS%2F2xLgpP51lyqzC6ofLfu9CHFj5U5JdVs7V11nZu%2B2stxYmfls3b479R2wimJUcOqB6ptdbpO6xknVcG%2FYCn09kLAeMFzlCAtlnS3jhh8JQVLDUhkZBT4tkOj4bYVl2PvXDu4NO6un%2BEZW5QeT0CTo3RmDX3DSy6bVMaDhuAPvaXJQfQkCT%2BQQVBbTGLHyK2ZWx%2F%2BW8aMq2KUVA%2BV55hE8r2JhVYZ2ZbZZ%2B5Lk0G%2FI5zczPd%2FJzCv4b%2BnNjUkCh%2B21z4F%2BD5cnhe6P%2Fy%2FtR05aylhNwUCo2XeNXph12N%2BdwIKu9yo9%2BMymzS6DiHoFipFGVLG123A7bxzekKTlxlNIzWqEl7WsHXQo4%2F%2FSQxiVLnnsioKptOW%2F8rUQ8zOVbVU8UouuSMXkF%2BU0SraYOs%2Fu9Ys2zutn7lEVpKej%2BBPL95%2FPY53az7vrU9gvEupKia3AyK8ZUJe3nyIlpbOiV9NO3CEseEf5jkbNe9k8iM7ItWZttSxj5eTSmRnpAVq9b8vm1ToJ1iPF7km%2FiUvKJj75v0Wwal9A78oaeKgbghBqLKadFfdbP0%2FA2MzgjMVGxjLEMwYQ0qeiQxrxip4xyXmkDOY2eDI1Wu7mu9uKK6zKh1IZh123N3yzDfeKnLRYLK1%2FbRFZEFSXXcHzqFTAhrfeSBNFO%2B%2FxqYGpK6AtF2lLfCfgVXE95sgGT7XkeBcXkbcvQ5Sl4JqufWaEZ8%2FiYpttneJrElOiKrC2MU04vaijf6x%2BPLtF8LY4Cf867dvDUNsOfip2Uf1Ccf63Qqg3192Pd9q7m%2B%2BUr91FVX5wa72O%2FW2E5H0S8M9hkcGRYmKvrquNksBt3d0YQl1TVsxUfDmd9zhhsbmsZIrT3BoHeaKCv%2BzcK3zUCjswCR5bPwM1cs%2BusG%2FGXkTN7XZP%2Frv5t5Dni%2Bqles5XtlJTfKyii73q4K%2F8p%2B4hKplu0vT3unEde5A%2Fdt5c3%2Bd1ASBINr%2FTI1dXNxcW72wub60BENv8BYhP3gjkA0eV0lozmZAp0uv36ZPPdwPGJGnHiiikRtCSmXm3XIvbo%2BoEnhcaWql%2BRWlLnUeako2Lo8rhyw1Z0NW5etRN6XjmFxox0oVo5HBffX3%2BoXLKc7pzgvr83r2D5kPl7TKSqwmzLWolRchjsdMeDnrc9e1s8dOLZMMly1A9K%2Bteh1A5JkORPI8T%2FdUKKZEEhYLSam%2B6KUEBK5%2FQo8dp3nAZlHfer9Vtem36ynrkUNAH2SgkbPXipVuamPIXK5CAOQsyD9xAJc%2FuDR81kte5oIIpjQjP796Am9R7GeyjIhZvzy5fPSFdnZmtCvuvOiG6FQaNSwtws34Zdj9j%2FrS0p%2BN76XO%2BNj5g3XrcgBRRU5%2BiVg8iDp4s2asffXNm67rY13tT%2Ffute9hEhQ%2BCkPBCiCTH77ndK5b1CWUalj4jG0P8PuqG21b0631bfpaxSmcV%2FyPMBmZTyb3nmX3S4n6CHld5bD8H6EyJnuMtXRH7x37%2BlgL%2B%2FnOftehc7HCN1UDMXFhq8d3Pkk%2FJX0TXl7aHJmdcG8LhnVDxNdelXePS3U6nKvl2Bm92FTZ5Gyue67ZObTFBNN0jcujtDCRoYU1bio2Loo40rbKnEmWW%2F%2Bja8uIYZIV4aS7cdjq3NX2Rp7eVVX%2B296W%2BJJmqlqLte8pe8dQjFGgbspwGpe%2Fej0Io6D1AwhtJ9bt3ShMDU3HsDbJRakig%2FbUUjrt29Gvn%2FSiooyejYq8MsZkz6V7Dkr8e3L4hBwJuA83jLZ14%2BruTWQQB8eZN7ShGRu2W1t3GBpn6xl%2FiBqpxCi4%2BOACg%2F%2FhfMZIukVsPJni4RPBsTHZG5f2H9K2GCKFqeyhzdghGysximUQ9%2FmUY%2F2ArbJMRvbZ1tkL8Zy3vzinu%2BnioSMHV6neDjLzHQtNEfC5AIITLsTlXFy6un8T28Dhid4L9zD0Fn6LIeTrm%2FkXIgKrCwNLmX5sfVFdIDAJljT%2B%2BFoagUKI7A8%2FGhwceXiwN3L%2F%2FOD5Q8NJBRdIS0YFrTXBBVWp3A5yDB31zXh4ZCRlI8XSL16MtF8Q2IZZREMNfa%2B2b%2Fc9dPTO5nTOCu%2FDXp%2FdGjWppx3W%2FcKau8dGklKfTt77PXdUXKW9jM8dnnMYL%2BEqReFgjDHh7meVu1ykUczL%2FH4vDq5afhtknzJONbZCmHS9OH%2FnYR6G7WPAPRnIqA0goDPC%2BhxY1mcCT6d6VjxgX50dcbOtGHKpyM5xdzK9HWdVj1rFVjVaytFM%2FcHZJRPJssanfevO%2BXVjXN9F%2F3e69DQzLoKEUlzHbQJzQM%2BlQ%2FQB1Sot4s1wCbQb16%2Fs3Ub1qQvj5j5U%2B76QcgEN0bxums8lLlVV8xsMY%2BQuyGBKM%2FLOmWV5Lm6K1J0xLeYBGoFzFW%2FQuGs0q3EFGgip23710YT8d5zpIrxQ%2BQpkUHvwEsfr1tAEv2xx6dSly7oAFDf3KcvnUD4StBrw81XBnCbtN9eli%2BwqL3dZZipmHHfN%2Fiw0%2FQQZFheEKH1TCn2BjTB5KJlII2YJ1F0R2BllmycXheTWlwpQidEWZ%2FnjvNpXIisG%2FKf64Hbmm2q9VqwHQML1yuKn15syWHkuUru0P9llEUMPKxWozy8KSTbvujV2RaAuw%2FU8TzSipOdkKZj63zhV7EzojEtrwmSdCIE5nYhRN7cscQzpSEhvwBVB3LQ9tENVoA%2FHB%2F8%2BnVxlnr0d9r011xk3G6Sro4n9zOfkUy0iN5h3trWXZf%2F6p9ZhonLIQ7AeIgqvLbdIn%2Bjff3C3Z3u4vt72tPH5raujePvyLq%2FGgsKCOgNOCedJPLryZeJrO1uk%2FpbZ92fXS67bzz27hVvcz3dPqaiNIFaUJ%2BEYJQm4qvJIIrPaPSu7zD2RUUEkVpUnYEsq4nAV5URieaV7ypmCrO5eGu1cD5nS20%2BhdQ9C3J7m35tSFxIULXEYc5gTgofA9iX2Y3mA2rzgXBBHt2lQ%2Fbd68XooaN4oiFDlDXU3wGcQ8u7UbET2aETroxgx%2BhXqXjSqLdo%2BH99lecGlvSM1zL%2FO3ZDl11L3jnX3YQm6zRu6YhpQUefpZvZnqg3FuB7JDHUiN8d4lyVz7AWrfDPxLZlL1i7ygXEuCgQyyhumn46yiNaHoQsRaz4YBbvhaVnd1SuqmGSPFPeXBRWaFn6LP4Fd3fl8f%2B%2Fxj2tn6HY29FQLy2bcjc2IiK3tGxGbWxHbGyuhETu7OxF3VkOTNyYnTU0nJqaMJqcMZ6YmjQynZvb%2BkxWr46KjgidG10VlxCYmdiUPidCEDJht8UkWxlFkKyajKjlvffpSfNYWFxEjlCmUaG3lr0%2FoyMZAIiCR2VhCR416cAcNoxWhFUnDBncYObeqyFQzrWtO7P%2BZ5hcdgPYkoCNSZiv9AvO9NI9rRu7EVMa2FYhw2KXOcnabee5EoBMVwSVgObHvrQzuAoOxwC0L9G9oxgcyuPMURgCN7O9HyXrelrOyAvAUsk6de3jyh1chBP9oiKclxhfjiIqBYRBOwYwMVnlLaZZfSEdL9eTQkp4B6o2ff6KL8rTZwJnFhhEW1aqgxaXgYKD5DT01JynWB%2BPg6%2BLinGlMwYQe1Z6KrOrOtlFt%2B%2FpvxrQ2elvJBD155VumAqFQ9L%2Fxnst3e4f5qtRaJDI4rzqCiRLi%2BD50P%2BjAOYUVEKYAojOHuScqci%2Fw%2Fvaffws%2F%2BPftSYPOfWcHjHViHnS%2BtqnMQ2JYpA7kjZRNO18%2FA0sTH1SabPBshiVlXh%2BqBOM1pjFdiCKhhPCKSOcoiMnLzKExXkfLyIX%2BwWFuJ2toQaA%2FPywvmUTMyy8g0klJ0jBbBrhxZmG1IrUiaJjgphJKl7WeuJi49zgy36M1Gp9LsvdQ9bKOL8vK92uHxZjbVqxHXb%2FKvzCG1U12DAnxj4wPRlMjtOeNK%2FPsHDDOaCes1WNacQJlf5pEsizwcU%2Fw%2Be6MyXneVieGr9mhqY7xWNm%2FupDtY4oGDoQbZlazO9idc%2F4F2Vwi2uaNcEFHwc%2BrscEgqiJhu86Kio2KiYhaXUwkMTI%2BdjUhKi4%2BOlYtvez90PqrqC7HJ7VrdiM9PfS41x0RXZHjS2q9tjWfIpveZSzEpfjPpIqODs3GovFdRgfTJNzIkBEHnwlya5V9YXasvZR%2B3qjHAL6a0h14rPLI862GofYr1du3LJ3avlY2UIJdrZx1IKNYa2%2BL2siE7oS%2BlbH5yykY9uuzZjg%2BzzMgJd212D8qP9ARQ8KiPKwdQ0%2F5VQaWKD7jcubmHl18eue3bjYKJSLM%2Bn%2FN%2FSu2mEzdIKn5OU0DeGSxu%2BF1VCxjKMgwEhU8FpWx%2FEbiaeoVsRpbYrcuXr%2BNAGuDJOgUvvUrXidVDC6NTnZEpYSENA%2BPsOPOiV4QG0yz27fIqzkvcU6su2Q4pj6QX%2FlYXaSa8MlfT5XBz1%2BLijx%2BHpdLtT68dVWajUt9W050iIBjaGdxCR7H1Z4pd7I7G4bqh1Va50e7%2FZOHp3gD0303PO75ZzOprmalxl%2FFfsIS1WNrM41E3fleyMgEoCY7E4Onkb0jGGc6gTTAI5vqic%2BmeUaXF3ei4H%2BOoxJ2mR4oSirg0HEwZBG3y8BakAcIkmec56NSGdcpZNQnhf%2FJRBL82fTe07w%2BMELMy%2FEmBwABnH2USKib%2BkjnosANo7N88xl%2B6%2B5pidTov65yRhYAdBXC3aKrUpKJTHRiqLJ0pzffoMNA3dtu%2FdyfANzACLD4lRUEoQdp4kOjFWGF7x2ou9nVzyThIHERkw9lt7IdyDaZ13KLt45Bz0kPxKo8Ivt0g%2FTbgvU7tb2%2F2hx0PhweZN3de8K%2Be57Txsdk3S9pGpQ8B%2BkpGyTIrn8urkwoSeaEppUXlqrkBFuWMyqZAUiqqsXhXGx%2BdmJCDi02NpcSn1CQnRph7WSPRM5lYW192QaFttdCYB6Z%2BEN9THFQXQuTx7HgXEoV0YwA9TZ1g0IQfx3HgXOzqqD%2B91nhLDm59fRlgCUniF9ZUAqNkbTKLXD6F%2FpTXoHAezU5Xy%2FfVUObL%2F99DCuvrO7liRVoUmwh4GijW74i9RcDg0OVsChxq7witTgnJDhcHTL4IS%2BrKI1ELSjIoZxJSSUzFPrxT1PXkNwyFKgb%2FuBZ03mN%2BRWmgFg45ejT8l8pWBWtsVN6DTq%2FvT7WzXLqaEaPH0PAJwFOKUvNVMCXVTqkL6ynd7w1FI2tOU8gP6T%2BKiUTF8Wi7ebtloRO51pkkfRahYiHZ%2Fbjx33DP%2BxHofEc2GOLtY8LsAxkAWVt0gCjPcD0EgZ2ShnA2vI7sNHdqjld1AQcfV%2FvSa0%2Bq%2FTR%2FgH0fc%2FYUenZog9aOt65r0ZAOB0zfJle%2BCrh%2FUisKEeusFHKQEjlFcFoZUPv%2FsWgod2Rwpf733uTyMvwUP5WP%2BJTneUhnB4S4cu44avYe5McylYe7FiE0%2B0w7EXYm4Ql21n5EbTLuoHzrTgLoW8QsvxhyOqzIaSvO1b%2Birpy1BnYqJtH26MUQj84ZPmvDtJ89Eo9PmXm7zyc3iHhy7PhvUmzxahfVL6F%2Ff4f4vyuCKEfbV82h6z%2B0kFawR%2F8Ic6vIIR%2BYcjy4h2k1aJE2BYHIdUzNZCJ7ARbgP%2B2NVMOYB1yRZ6XlFzCWrGEK4V7Fp7fh1rnw8qM%2BaO1dE2rD7IXBwyXtd1nTypsUPk%2B7MYlhv0SGJFdZbJpZdWx%2BL9vP%2Fw058WPYbhNLhAYD4pjIUsmkOvlGk9Ae6vxmAHaJ6pAHTCs1rbQ19IWHakImgdhbqKKZoq5027aAtS%2FbeYAH8yh7TKaK%2BpH7SrmAN60J8xFWm0OwKGVvJqoyK%2Bh3h50qLs9kQ8wnYk6U6y1GY6hpLxNaSpoB%2F0hIE6mI0YBZXOlz4M%2Bij6KrEJnBpB7%2Bka2cqyLteJNIMgQaJvSAkAEOSSiwALKzo6zPyLdR2qzPwsXC7H6izblK01ArjhoLwILdg%2FvBF5ub68UiQDi1pEq5siO2vsmdSbSLab049%2FvbP01kQZhA9pT2yXN1Pl4d3txEfcg0g9JUkONP5BVivDf%2Beg89HXrfNK7rnO3c9aATViSx2BsTnb%2FOP0N9jEuj%2FdsOipxwZ2UPhldJM%2BhqMYThuMeJzjimpC4o%2BIGDSKqRT2bZ%2B%2Ftq%2FKdUaKuwDr7qdaU7r2W%2FLASNVbDJAYkFFt37nzft%2B3Dn%2Bu6o4NIOIUDkwi8ASkf%2Bxyv%2Bk4nAVs26jy%2Fb916HDF%2BWShyA9AQx8nbdq1o%2Bwai9%2Fqg3zA%2BHEfF6C3xUNCHMaQisLUik74%2FxR%2FqulPCJyJId6%2B6TjNeW7BErLvRYnGzE7eWnjqkro7qweX2jt7WzbphgcF%2F3Uo6M0WVBS6c%2Fi6jU6hgTJeH483x0VJvmnHFnz7r5Eu6YLaP9C1pUbNBh8Os9TP%2BihmG%2F45Q81rRxt43MpiZWf5XlUWDoaL%2F6EbY11IZskC6vjxFZedYU3Eu%2BcnQ9ZnlKc5LEBGyf1x30PsBC2qh1pZNYuqA819OQlH9QLq9DmBx1drYkv0ETKKE7QE%2B3qVmfm7gWYFWOtInTlBABRTsFrgoFJDN%2BQe8ghZKvWLvUkCUOUyNhGN914OMiMeal6%2FhjPvtQ42Gyo4tacDkQIlKFTcjj3SALhlsfY%2BBogaDOmEzBJ3IaWjFayxLDm%2FA41m1xPrtEAJj4HWh6PMexarqvCZGsV5PXrNmYlybaAIaVPhsqv535p7wEIoxWHkuEjKRN3Bjk0cssmwm54t1LuNcGHQssiIifD6EenIAdCnl%2FMlLSusXaK2GGhfTDFw%2BnwPQEW3WMu8u3nKcuh0q4muKBmX9o5xRlvfOz%2BpxvoQoAlvi8BVEseIFQLzIKZpN8R0ac85xLAzdbqnbz2raa%2FZ7CfVkhWxguR8FGDgV%2B8FRWA%2FdQggAy6pt9STWF1qHXVGjPVhqFdKWfgbfH6%2FPybWUVqCKOrxHW4virYMPdNXNRDV134XcvmewdVqU6iQMJVF4BGhbi6%2FrsVQQ4En0JzjB6TVJgs33LaD1lj4nEQqoGhpZyead99yzOcBI46cdwMquJu9ZVVa8xGKlLPZN1Mubp%2FqHrBgC7At9Qy4v9fPn%2BMeZyx9%2BxHF6QpujH%2F0y35%2B6wMOjCyFPdUmkYBiLyWB0%2BEROuk6UIROcO%2FczqMD518X0AY%2BFOTZaiHVys8jMoeq8wpgO3fEV2kPcjxWQ9fOGcUV6xzXvaw8v8TiPdVcIQw0R1NXYIZgCUZ8hSLpFkln38GYKKjIJEklt0T9BKYWgn0gR6fJjTHyfuL9iCkg4EedSyTaNjGbinSqKrEnT7izD52MYvgSA1Dq%2BRGLd78dIQj1Lj3hCSCIKbTXxJ7JMc2RSsEmHjDGLX6jlKXW9M%2BTpgwVbIbSLHp%2BMhpJ5RYKXc7O%2FOZmOAByNgMfLeBY1HGZEY%2Bm6FtuuTMSIaDHuELcIfcTYy6R5nN48lr6HYfQ5sj4xmVgzoTFMUy8pTH16ZUGJhQxQ5%2FMIcyHwZ4SIZtMrGIodYeuHQmFiRQWAOd84IWXt%2BBKFbTYCYajnb8i0b%2BtUE6H6yPKczYOskSs0fEapwCxfFqESFJmb%2FeKdezIJElAHgh82coKqyha%2BvMLI21YBusHRhkSJObmx7GLYyoQwC%2BUulk2Ekc3eZUga4jiVdUDVUhKpJTGEmVruJjPYn6nZiOGg1Fr94AQiNwlGwiRbZGOqJSNajU9egUDxozGwBjX2DCVjFcBJWCfIEjaYkOSiEl9OEKWeZnS9BSgJCMk1cKSnWoxqfOavNZnaD9QR6DdMDntCmPEfxUUCtqQBErC1Ldd91kgonepcgrXZL7Lk%2BAthG%2Fxjs5hukeWXk6bxGXrYJGm5vOfMX7CU5kppyeAKqaDskrmPhZ5rEaMx9QJJvp4rqIt3wlGItBT99uIKWAf40K5eYvH9wsEgXjg6RKoo9rTgK1ch0Gs1phF0N1I3m%2FvSABKq7C7kAG5ReCNRxUZLLGoRc8SjQOfDmF%2BJEWjciXt5bQpYLHLJCinnNDVWXioBT00BpKbvCczwAS9SDP0Y1vHOQ7wzj2PzfC2nPyZ3IQkkfbkYTdeN%2BNnbyDypqleyH94jFtnBZLHeejik9%2Fz07s57wM5WN2o1bI7Qpt9J3bbO9%2F2xJ9aPtEzJsfIq1ppPHtuStwLAFzh3Zw%2FAax5FxCqqjYkGp9hHVNqTIuX%2FnPY9%2BCHPW0rHQWVfUF0kg1bLIFeFAdlflFgtcikpiiYZvQRYm2VsZUGm55B2HT03O9Y3YIYERKIBgoWw7rkpnfMZxx33S7Raj6qy9A1WRwcpmjY2GI5JJbnT%2FE%2FsfF%2B33VeMZAgFIAU7XpWSDzam7KtkIHJyAyiDnRpRmfjTLbJuZRh4%2F5iyybFZuvKZXyxxjr5frhjLTTqDkSvZzt5P0Dk7aE5qxxUaDBrbVB0MoxlPJpUKgcUBwSp4n5U1c%2BsFFPecw%2Bhz05AXkwTsh%2Fv%2Bu0w09dG7k0BdT7cUecveW3vjNbFFwXOfED5EEWy4R19MwxoWZB8%2B%2BEc4gHgJURKYrHkWZSVVG7LC6Lu%2Fyj1Jf%2BfDrwD3TDnJtalTH2x6ugD%2B3Lh8OJ7ESiuWJunkuUFagviyrgvk%2BRYjEaRfm35SSmXBSX9EVQt4jVihTdBqwwyK7adx0dqbUx8owyxySevNjnjNYJBHAGM7hKzwxSR8hzTOM%2FHuPkgpsyifAVj3c%2BSVREw%2BbWA81vpI0OW03FJEbZir1rOQOTRefgB5QyOuLVHYjmDrv7R%2FOUK1wRQLu%2FcDAKq%2FbbwDFi285lWmmLNgsDjj83FD0lmo8DBFiskRvrN%2Fls51y%2BYXxb4OXLVT5dJ8DWQylXVTv4M3TYBg3xBqIF%2B%2B3pi%2Fx3HRc6mNYKGhe95Py3LNYOu6dnQ7t3avWSmDJB6c606XLNZCd9bHySOYSxOmITVzjZPJQuXBu6CfTvos%2F4NI6UV%2Fzkxp5EG73IUraubALTXq5tzoTxDoYfK8aSaS4o7%2B5FyiHz4dPaJzPt%2FeMy%2B53Q%2FhoFzlOLcHmvutTuDrxqCFw%2Fbr0c4N24jMNp0W3OzJs%2BdUYjLySqaYrE8xNXl4XIZuiC2Y%2FT2okht7i9JIhyKhtR%2F%2FM6%2FnIyGmpgI0oJTbNIVz9%2F%2BH9fi%2BVR9izUG0o5%2FPUtylRen6qomwdW0nf9WUhKKp%2FISkIcw64Za66sA5j3kLdlbxOkX67Lm0FkDP2mfB%2BKlPYbYh9aHm1hIkV%2BVuFLNevIxedIV57pw3sOIPK2Ly4YO%2F69LBYiEmSTcD9tpr7TQms7lSS7w4akMUPE0EvV%2F7B%2BdXTvrGSfJ5GNIQssF8qrKbLyCRhzQsQ3%2FNlzmci%2FxKzJ0ai4nIaYAQiqyoIy1NMVRpuI5xH2c77%2Fn1dtiYEEAKDy7LlHuln%2FvKWhnPQaaAquw%2FQLAdA0W%2B6XQO6N9K7oN2LkMDtH8%2FmRX2J9ZTMOc6ytcULn0b5sv%2FwqO3JZ2Awh1ZB%2BlY%2BEf4ywOMD2TOJYAtZI9uwTiVmh9rOtVwfvLk98UqKPtfvSAvdVZMlsnIjJYF3h9gnEi%2BGLvNZvaejXX5S9yyR%2Fj07%2F8fWvOmPhZLNnB88rHUonwssp9qer%2BvPbmsvcCixgRSpYGQhRQ80PASi0YRSkVE%2Fagksk6JHoyzW7TIMRMOWlWPT%2B4GPoYKoUap%2FIPhTyW5CeXl4soyww0ImMqhKSiLd8XBsP%2FYb2L%2FsmfWpPfZTNyHV3Akyxidu5tWs6nsPw0M1NKo4Lx8U4Y7HXxz3yTmTE61JRzb%2F5puraZxgud11xMFgDdQK%2FdQTeaNmr%2FE%2BIwIDwrz2LCfolHhV%2Fybj%2F3ME57jGPwYgQV5qGIzNgJPqY%2Fhr9wuqeKqcQSKNSp81%2BGgV%2FGS44SVY9wq6fzz6v2BjJcQpcSFO5C7k%2FeHm5vNlRs4lGkUnzyVeAaIfZh0bZx8o8q7MlDnnw5WgWf95XqAlbvdpl%2Bs%2BLav6%2BltDvr3j4ePto%2BuNHf47p7nq63DuLvdVk8ynd5TaAuJPU5cuRlJy0aM%2Bm3i0McychfySsX2GxJ4N%2FAxiFYNRap3nMrHDfyXWeZUno8A6qbSLljKn3Z8eiVHq2u00R3nvC8SdD8oRVF9Rh%2F7Z%2F8GP8YkAnmggovybRkiC7ytcQkrIQacCg0I8kNIWGs0qwdH%2BB74lLZz%2FYDczXf%2BRNNRUYhRe9u9uR5o0fz6Kq%2F%2BvqtyXMyDsXTofuk6p66pYkaHhbWOutXSgxvKiiO%2FvMIrFDkxTzitx4HgK%2FAKjztUlSmPAPe9pmYOY1DjmJLrufFdJ21QSj%2Bi5mj2hj77FA%2FhmSTzOM0054UPvW3TTIe1WrdlOVpn%2BLfuuMt3D3QYYTyXKenK2xviclsvyOIKkLW9Eb9ffrzgjnQXiWEwuyWS3Ve7QXIB50Oqp7KP1%2FiCbrbYTcIN%2BrpxQCqW0vKkZv%2F7KzTs%2FMGnFdHXJKyvTf4SJDnklRZ02taSdrWev8WwJUzNZXCQcX0FTYraWryRyugVGdii5W9n9jXA%2FtfUR%2BGb2XxVqjbny2E85uCTJ19eG%2BFeP2F3lvcZB44hJlPCtj38aWQECQjatV%2B1IHMt3ABj55%2FGcVpVgzw1O60cFqdIt7s81vEdWU3Gk%2FFVPZ2YyXTSThDnw6QKw2IBb1iw8JLaZwgNTNLRbq30q2jGMcE7odKxOL70RUFyY9aLYabhrBOi3u%2BmRVoUSNsVmo2h7Q9pLd%2BmJ8fYeSDcopo%2FQo%2BmLpHGP7Wp8g2dy7WtAAQAYrl7ur8Qd39v7P8AiX9fXfbNrRC16qx%2BXFn5mz09nBuYxALMfZNNtQBMbpmOAOYe%2BqdtVmD9zXxHfZS3rYzmkoCSN7sGVj2F2Uwgs1XZ0CG58ZFjA7NECljkHDJFkN49OX5yLK0Ciw5W%2BUyxShKJvkzH05G0Cc2U6WU6WUqxHdThCDFHLbJmOjEi5DVZQNvEVgMraoehJDUnOkQfUG9OUPR6dL7rTQNto037AFpjpyj3BPW1IOOlZDp5ey8Xcw0wnuFE9gDl1YC8I35tACdWoiK8IzMIonb0f6QnqpMqMt%2BYqTuoiz2oWVRQeDQzlkG4Dc0UUQNFtDcnshidGclmdIk8tBVn7JWKcSV79dMOaFNzQykIGLajkggGCSJYnxNQQRwyOT4qEVdvnnMoyNUccUIXiNpmJXXEQj1xahgRXw5h618C7IFzVD1VAv%2F%2FxelKtE2IXNKpR%2F53M80Bmed07IHpcl4VAHZ37fUbEM%2BcNiPqnEtIvktRZvi%2Fvwkw%2F0YaaZvMObcEamqkEO8mgTH2G1v5lxmOS1Hb8ARThSIcUET7Q8UoyDzWHeUGMueWQO0JKcS7SQBw84DCzeYUq2isRs7LAeaKZJIOlIDDJ%2FnBEU4Nte3kbWporw5OgoYGLFbJFLCY6BcSsytzqQ0nL9PEKcomxZFOs62lOxQ7W0TM9015QkAAVr7ZpS21LADMD9cRAe3kxUtcS0as2Vw7incZj6nrw%2BQXuCFrEpKldNJlCtlypBAJEwWBiIH2QlaiyoGrCFU1dY2aVAvaOrp6%2BgaGRo46jqsTOHX25wYA3AAAAAAAAAAAAAAAAH%2FrgH3t1NJ7bPjslz%2BXQ742%2FGfH4OBq0ZwEMoVKs9mWc9uwY7c9H%2Bf6v2ucKYgCAIAFAAAAAAAAAPDZeoZMxu57fJ%2Fv1%2BlX0R%2FEma%2FdVA5sLGdbGouxcizGgjYW7dm6Tvf0TPq3axrD7HuLcTlr1%2B6II6cuV5EbkUoUCYKIgfasMrw%2BS7bXzz788sciiUyh0mxu7DFeRERERERERET829HX5puaxiSz73U%2BNuRAUAIRAxkOz0KqPRERERERfc6eCYex3lf6DL%2F8wT2bGNkFx3VZs0hKBoVKs9mWc9uwY7c9Hz9ioR%2Bzc8MwMzMzMzMzM%2FPn1vT%2Fhdn7Fnu9jvU3xlaiRCBiIMPtWShRi4iIiIiIDGwhIl2t6ffVTGF229ThHhn3PX6fpV%2F%2BxJmvxxYPz2eVnwSEbgJbshSVLmRkywWrgJDXMCnim4srQmgCEgUGWkSSJFOoNJuVbCvHXoVU1dQ1alrVgraOrp6%2BgaGRo45r1gmcOuscXaMb9FDLHimDlWfh62ka3%2Bx96whBCUQMZNj%2B38Ju09gwu0177G8K4x1hLMZiLPI45AO%2FQCFDCUiWQulCRrYcKiASJioJRAy0aJUEMoVKs1kpQGWoqKqpa2hqaevo6ukbGBo56jhYJ3DqzHU36NKbjL5timPYAAAAAAAAABQJ9UmSqvNLklRdLj1f%2BjyOa4sF8JEHG%2Fkkv0Ahw6bOHIvFscXieFNY%2FNacQyRYVBKIGGjRKglkCpVms1KYylBRVVPX0NTS1tHV0zcwNHK0STbwC6%2FdiAw8SzYdwBgzLJLIFCrN5rnupe%2Bf3zNHMEY%2FZquz4772CMOK%2BOYMztOLdfvy%2FOOTMEY%2FZgF%2FAAAAAHDeNw9j9DEKwzfoaxt7AsTY7WOHjx0ydjZERERExNidOuEdx%2BnqXNclShwQERFRdmNmZmbmL79vBz%2BzvsvrwXz8AoWsShVlSElZRVVNXUNTS1tHV0%2FfwNDIkZv06J6J8u1IXl4%2BVA8olORBob4n5BxKzkI%2BQila2AGGYRiGYbgiQyKFG5FSbxERERER6R8dHo%2FH4%2FF4fP%2B78SGXjKy877HPO%2FlEVBEEQVRVVRVRJBoeRc1QMxRFUTMzM0MNZUeSJEmSJEmSJNu2bdu2bdu2AQAAAACACgAAAAAAAAAAAACghQl%2Fi4GZIZm%2BSZJMr52nlqUVq611VGvjvsW%2FnLVrd8SRU5eryI1IJYoEQcRAe1YZXp8lk8KQSCIiIiIiAwMLIZHJZFVVVVXVgYGFkikUipmZmZnZwMDCKHhUKhUAAAAYGFiASqPRSJIkyYGBBWnOWlVVVVVVVVVV9XwfHzDeEdw9PL28ffrZ%2Fvlj42yMMcYYY4wfkyRJkmTbtm37uCztTrrJDwAAAAAAAAAAAEDAnyMU8SLee%2B%2B9VFBKaV3rtDHGWGutc8557z0QyT0AAEg3kiRJkgcAAAAAQEREREQkIiIiImJmZmZmFhERERFRVVVVVT3vsTRGP2bzZ2ZmZmZ9EwYz58595ty6COacc8455%2FzuLl363aV3nSTxM1MHBAA%2BU0N5YrdpQbLMhQNiYX%2F8umRyFLY6Q84RIA841ARJH7I4Vog9iF3YfKwIVeHHipJFuyClBSrnK0uCDBB4MTJQBUiQhC5NDAonVHEHJF7mKCBO5iUcNAjnA0KCPh4EAnwpBVmvoiLJtEshmGl5R%2F5AS0ZbHpnFlrk%2FJ2cmRlZO4gwkoZTLRJGEwTSkWGiqG5U5L%2B5cuPKBl5NPsmAG%2FgtSy3uiKpkNfQaIX2VaSJgIUWJAxEmQ%2FNb%2BO540GbLkyFOgSIkyFarUqDtBgyYt2iB06NIDBaPPgCEjxkycZMYcHIIFJJRTLFmxZsOWHXsOTnOE5sSZCwxXWG6%2FFnqd8%2BDJizcfvvz4C4AXiCBIsBChwhCFixApSrQYEwaVY7qiw1sVGtQ6Z9RQCKkJYROyO4yvvqnXqcqap77oMeaH734aMGnLpimx4jSJd1OCG7a9k%2BjArj3TknzW7J67DiX74Fi1FCSp0qXJ0CcTWVYTX3%2FpaLLleC9XvjwFihRa0q9EsTNKHfnoIr4Zs%2B574oE583gWreNasKHSuKuuuRwiPoVojDGJuV9fOJ%2BY2nHLbXcy49K0NDH6eSQ43AkjnnlZAoUal0lJEHa9lJJ50zDWGY5QZ2EBTjyfTqHSsxIopEzKmYzEIlCCiaehu1xnXwgBIqB1lDZOaM4NLQGZlXfRmp4IeR%2Bgr%2B3lidT2xMK09VGyBBgSSlBT%2BF%2FbhKMtCuU%2BuyO13fUOCkh5gohAPSqRjpTQTtRd6nQV2mdvNe0Pfq63hS5BA3mCoIxUIshZftSiyPu0RWQOWURwlUV2zh6LLNLXH0ogBNL5dz5QYtonwhO1KOM37OCTOOCf7qQWBMkoZo4SJA6awEeImlzJlQaij6aA0Ghqh%2FhuXr69gfO%2BBPM1DWufSXB7NW9%2Bn6uyyNy7FwSr9%2B4%2FCLLe%2B8GnLABej%2B9aBQA%3D%27%29%20format%28%27woff2%27%29%3B%0Aunicode%2Drange%3A%20U%2B0000%2D00FF%2C%20U%2B0131%2C%20U%2B0152%2D0153%2C%20U%2B02C6%2C%20U%2B02DA%2C%20U%2B02DC%2C%20U%2B2000%2D206F%2C%20U%2B2074%2C%20U%2B20AC%2C%20U%2B2212%2C%20U%2B2215%3B%0A%7D%0A%0A%40font%2Dface%20%7B%0Afont%2Dfamily%3A%20%27Open%20Sans%27%3B%0Afont%2Dstyle%3A%20normal%3B%0Afont%2Dweight%3A%20600%3B%0Asrc%3A%20url%28%27data%3Afont%2Fwoff2%3Bbase64%2Cd09GMgABAAAAAD8kABIAAAAAiowAAD7AAAEZmgAAAAAAAAAAAAAAAAAAAAAAAAAAGhYbDBx0BmAAgUwIgSYJjzQRDAqBrFiBlGQBNgIkA4ZsE70QC4M8AAQgBYJoB4QoDIIYG6l7Z9BbO0QSerOUWMD9%2F1cTRZXq2KKIMQ6wzSjJ%2Fv%2F%2F%2F7TkRIYSYiG1VafTff%2BDiA2TMhx6R6GCiKKipNXRGIIlEUHG3ELP2MRhdzx4LfCiOw5RpfZw4irWRaVroe2CMIx3WUxkQNxk6z461hFuVKenMJLHnEzY2FGtGIcST7Sp1cxTYd8E50vso%2FyPErfe33BNR2HDauKu3AktsDKFzxgVf7HfsTCZGph8ip%2F4Uwt9iS3xxX%2Fjfik50%2BuSSvluohaoxGhW%2BQffZ0VxQ%2FGM8sOOfD3skKRo8vC8f%2F27ju6d9yKpcgWhygSeSCgqcvLLdBLvHsBtzrwRdYwKMEHBAIxCG6PBxMBITIzIX70341Y99elDvde3%2F30frfnvzA4t8N0FHiQ%2FnyhlhYpTFKZKttIVlLGFqAtdnOXCPfh%2Fppp%2F5s%2FMptmdsGE2YZeAAAIiCELEKsEJcKJwJ%2FKynfnO1bVyn4tOV3TO9YVUOtHOcq59RemitP%2BpqmCq3alMuiDl8%2F5IMr1QhE46pskVkHI%2B0pVKL2OFsw0Pdt%2ByZtn6Fo%2BZb26vHjKL5K9xJojdAa1M3xoi2sTMDYexavi4tFLAtdy6hn5NhRHIvdLOsRxnVwW7mrbd%2FdLaMceF1hxqKaWqy1M0wnGOUpUjcZlXCIOSPyiwgRYekEwk0wQSeYETiachON3GSksRmej5eOx5AgFckz8qFxU4sFuBDwh2aNMare3AjGQ4P3L7FXIFJNjEd3EIjsBrNet%2Fjg%2FqRyg6IBQYDvgdMlk3NkNNgB%2BqwG7TqarbF%2FI8LPB7hDBogrwqc%2B2nJJCrmTE6e%2FO3AQw9WXmJicB2G0w%2BCQKLMusyiTVt%2B7VeBVQSlulYqexUqapgXzGwx058eVSam5Ez%2F%2BqsWpG8bIipC1c0vuzbiq7kJ8HXR3gQZsaCScAk2ZMEttfCnh1JcHeCS9i7uQq5uxgQkxCzfoeYlIwvhVCl0IVcNN12t9cdPdngmZbLCHVCIoxbFgSXF0Rlg1A%2FyKp6CYHaWA%2Bi8bm1dBjU8NCvvWp%2Bi8tPihQN4Xy4MWSPrDmG2TSlyfUr8c9%2BGtZUM29n7LsMByrIY8kQ1PSvN5MwN7xjeYm%2BZ6Fjs63IOyxLAcXRh0WHA3Sqhv%2FAGHf0OMAboONkkhqh6SqMber2rJnbwoSAyHiIyrZsPBhdDfcIJb1nz97ZXbZD3r3ZFlX9JDujMWp3NHVAWo4OtbwMm74D8lx9V0Y15%2FoRyh%2B3InYAAFhd436DrdGmAGD5%2BNuJDlyQOSrMzssDFPcaaerubRRgeZJJFtd9djWV1yY2p3ObD5ylFJt2%2FadoQueV%2FDg%2FXT4TExATEQOJSYnpiZmJRYvdAHH8%2Fy%2BjtWSl2ZY9ZgB1bSrGJybUT%2FcDGJ8qjlexgDmei4II%2Ff%2FX39P%2FTz7C0c2jG0c9R51H5Uf5R14frfzfuZJeMY2qWxgvm6qGecX0LG078j3V3XHJBsQFAKcMC4MEe%2F7%2FyuP9kBhfhu4hm%2F7KaGIj0k6NG9SmfP41vG3Zrkm1SRWSNuu%2Fe%2Faao7dacorBO2u0EiaE6x12ujLc4K%2FPVqeL%2BfFsemsy7svMaJWUFIM3FSaHwOESCaBWCCiq1AtWXDTiiFS1TONIcT2HKAj3o0GLG41VDRcQOcGCtdgk52DWC7r180lc4Pl0QVx4gd6WCT%2BHaQMvW%2FrMvV1qCH3fTjJoJZ5UIggyI4IgoVpSWH1R2pWcPCfPJeJLXJvrm4iEiydOtD%2BeimF%2B5HD4kheX0rA65wh6RJWAyj1SxSz2W1qlMghMHDWRluntJCyhuxbhJUQk6uLtGl6EG%2F9mC7ysmM7DgVmeLW5rBOxijW1gxT4%2FOLkQI5yW%2FObPgeqSOYxzqjBW4pJspA5LVt3PxUNI%2BUz2D1Dz1r8%2FAZsLS%2F%2BdSkBLwEMdfCVknc3u7fMqU91qa2%2F4psvks3WTyec7tZBhX%2Befc8PvvTSw%2BvUC2bz05k2zneojGQqtjgapOpXFH7C442UOzsig8vzVuvWICkgAMIC5UhBAoCx6LLoXq2AO9IITTeQS8OHQgPTdvu9TSuN9JpJXzjmAxWZUWyeomrOsmF26aMN0IYo7XNkd%2B0j%2FywvbfIXOHjbZKBEUpnQJIQsgUMCQOo2gNUva6kX4jXdyX9qbSmUPnWUUMFmtWOU%2F8ouymnsMxRHWQylQjjU4PaS4EFZWuenDmRNFvkx2U05uhSl%2BhCIngoU45VV3VKcnecajWAPomTiDKaVTeVJWHwS16yrjlt6EOf8jaZBcnhMnwKQpF6Jc0whYyp7PzqOTy1mIfJ60DMAGaBvWc0bmFrHf6R8y%2BGJGTXYwprNRzlptfQYLfBOierCgUijOYy3tEVKIqh7S2xrbTSrq%2F0pQ%2FSBzcmGbRUT1rKkPNroDpXZicoG01xAZAQ7hXE1qLs0Cr40IwceagKo1ShLC79OButaQgQm%2B5DjaNhGpUpCZ9iSLVeM2FwBTuQeEAv2GbBSqEt%2BcNM%2Bx4ZLAtzRdEBrEYAIEYjcRU%2FXYlR6oMBkw8IhfQiAfhtVQApvE2nUkrrX%2BqG%2BjkGxUZqMWschJoQCpJkB%2Bc3ymIn8LXmsOZ7RA%2FRmKctblKy1ZKs8hmCKbs1aO6gsZgS2R38s3086QF5m3NZbEkSNInPQ%2BHzg%2B3B219WZWCPF4rJcIaSlPjBu8X6Q3hRB8x0swhhdeAUuhI5E3WmzkJgswT1jwF4rzVxsIn33RIIKffNmksyqRWdBdfzDOGT1Bf9Rn0JfkAK52V%2FpC3MO9PEApajj8TZdihx6CiDFYTmIKG64AG7k11kPjxlg%2B9ZghNsRaTqpVnbT1chLyoC2oREi%2BEnHkPgCnF2km0ayUFLwzpdWmpSlQdkj9TPKA8pIAHQCLZuGkE5dzCRIyuee97L%2FsDXORLLDs5VUbh5ZuAbdtxjo6YB9i73dps1tCohcGpb3N%2Fo2lChSykdkIjUYjvG9OTk8f6PeAeeZl4RsBoOwLyHOz%2FE0A5RAStnLRutoJ1uwgiYXLr%2BE0HccEPK%2FCdjBLBFKtnFrhVBQxFIHMI0VgGb0ci4Z3ZZbMgg9AZQaF9dd6qiT1BRASK6uXNStArgxCupzRTBgjKtNNyxe1MAojJoOOa6Kkt6kTKaP2VfKjQzFXSlVy5E3XjHlt%2Bip6X4dQBZNhk4sS%2BXzgfAY6h3jmZ3nMIfSZ77GwTWveLWWz3fuSCs6xVGy6lrA75Hw83W35lLf4yOfNDUanh7xnPst5ddz7IZonglh3LlIy9zwee55J3vPavK7JvI%2BDu6%2FissBTOysy5%2BmULZZbAVsOD9ilPSn%2FQWZz%2Fr8P7Ttkj9mdcGtYwrZodSLJQ%2B6QwW7EqQrd1qYCeIoNvJiJBj%2BHUloE21dP0OZOArKgmfeqoENgiIYReCWDTpT3sjOR42oe2bZzNvekQiDdTIY3kYWQzzZk2y20TNXjMTKEmU3WNYvOQe5npVEGnBXPzeRCNNRrmWtXTDiJ88ey%2BfTQkOtB3lcYBvue6kmMQ4aBJt%2B36ZyanpCTqW7MmpnJNc5EgRIBPME5l%2BLH0xqsAgYEiMWH66keclCIIam%2F%2FSlPGhZigOzVcLRjPnRSL1G9ypYipsukjrlHnZRQYQ%2F1l%2BnjnCxKkrKsdUYHsv5BhLzFBAtlZmmEeKFj0Mll2z0B%2BekC3QSnu183K1BOP4rN5ytSUDSVUl3jTyPDYKaLA4SqRMwyq0H8nLLp%2BgGD4ox9qVaOSYG%2Bzjm7njrpFQUJ%2B1SV0oMszjTQ8aQY%2F5N8fzYDLlAVQFoyilNy7kI2Wqb%2BlNg2s7D9sWSAdYnbu5Nl0Lo%2F9IDx8VOdA0hzsrzyuCbBM8yrFPJ548FJ5PEePHVGyIDEOssj1SnSiX7r2XDD%2FMqVq0%2BWU7QiW518PVzmZGrFAUh5cSzHbuepYnJUzfVe8vUXBJ0XGSUDJPQo2vZM%2Biz3MTpUq9oasCSV9WKB51W2UnR4SP%2BLPDnkaUDV1hS4xVK5iJaKlRJNiHSbJDYpy53lq%2FKmczRL4rQkS2MVqBGwD3NZZLSejKXO8HJsWS6lfDLy8oBVIgjXlM4zrUqIalKrbIJnWX7gxPZPoMZAU%2B56EbNGQMA5VPDU9ApfLcGKKov0G0MhorJE%2FbCv%2BDhndWCyI7k7jtgtazSSe8pCs9TCNmXeXxnj9WTbvB0ue9Nd0eJTUzdGVYzG7kHcuM5Xl%2FnaqlhZE8u2preKWGqL%2BgYmvy7HDm4F8EzYDNtKWM5Exps5DwBXl7Mqq9kQ7mXC%2B3ugpiQPEueMNhYXt3YjM9kucrbbT1q1vUaJlpLcXUBRpSOyfb%2FYss49aSU3Nhj43W0xAoqiwLaKx2l0uhuryEPut4BaROoDlOFSDDjXRmkjQrB8BEeRpRyMrBsDwoL8lZzd2K6QykvH%2BeSp0XwamLEbvLa1LkVft6S40qV1LFXOis34riXFSJmcOE6T7ZOXtrN2GrO2b9K1z4L5Fb4oE%2BVLSLHVl5YeJzWNaQKVjtwu8zyRiRpCAyQw%2BoFkpUUWDFbBlnWNHkqmL2VhxHShTTlPC922JexLPaXgzXpFJv5eCp14MTrbvUH%2BWI9gica0DOFbhQxEEMO4o21dAx87XIWKzBgCAbwYEcVYWqlY8z5XGhNt2uQVRdOkVn0qTGJPbuR%2Fp8XLm2LTW%2F7KJ0A1gxMNAFRuno%2BLh4l34i2hZ6DH%2FkAyplaVVm30WOpw60ZGug0V5yDJJfjtiFcQQosvxpncSRafyoaFXT5o1l01obLuYI3uMcZsQeGYfBIM4GhoUsbpJuoQs853zYBh6HTjaJ9TxoIB6aZQU7oCGxYrDRkpjM2O0UYx7CKjpM9JJTWgm6Q2wSgZiLNrtEy5IQIJWTBvwxmtkqURTNaCVU4cg5oirAdlYdnCdoMICCI9xaug%2Fh7myP0D%2Bd8Og5yRteexX3IbNBKgHWp1zHoa8p4Lu%2FPA5P0TpFPDDmCZ1V%2BnlYzBmrgTlgQNkJLp1lxS8wtycW6XtlgwGrw2%2FejN5HICJzHBUdH19Tx0A6vb9mMEyxBSFM%2BzGsR11sUN%2FkuOKndSCrsd9OyB8XJ01p4zD%2Bm%2FeLsjFuN9Av52cimX1Bgq71KNL7WnKRlazHD057DpoZFGEydpIXfh3A%2Bqvxi0oaq%2Bl31YMubDz6WeIxmqmhb12Hm9tGgWpnfCPkzjTplElR457RnWkMKJ1QJP0da7wnxblLCrHCkho1J3mX96gA6ITIfWkGIOSPM6BZY4bGuhJGbTjm69Txi2c2WDG4MNnQH0Doni%2Fpa%2BeVjXCYjsj4RYg4hvMQJjON4RJm3cyBjWEQJIoOxDO836oQNqX2gbM9LCZEiUlCIYyiDPBkAZdX7ANZzMv92vn3b0jTZFbY1kvrV0RsV5Kv2ktHK19mfBLbd09PIflDaaRshdSal4TSIvmLGT6QKCRa%2Bz1dBisAY2CVimm%2FGQ7deOsxOK%2B%2BbpXJFBzIQy0OR3JJFFI7wClRCkxAJ4w1b%2BZ9fDyCMlugBY0ogh5xqhXIFZsFcMuYek9fyILz3Nxgb1JM7eH0J7Jzazqp67Msis1by9KNuIHsf2KSgK0SEdCvBLQHiLuQn4pdbI6DJmJkJktySDcJJxbsWarFGROOsYd3ewtXnG%2BX3APWoJ0NQ8BQQknCSI4Kb6qUx%2FcXNw61pZI2BQuC0UikBZQG1sZXkejMqwVibDbxuKGt7DagmydCvbtgzhrlr0w1t%2BdQvqCNJ1S9p2DAf3h%2FZH67r%2Fy186PptJJlHL5HtTq9yHWfd%2BUDVC7znIHuu4ArE2kTajyv400sNbYxzdWR0btCNWsNF6w1rGULjQDIzccp6hZ2flAQIPCBy80rWAu0to2zKiLQPYo4EKXbJJprR0psn5sVgoPWk%2Faanu%2FPB8HdzQfSHqK1WhV2aSISuZYaJXvFB%2B0nHcVN118WIdUtt7zlF2XW1kdHH9ZeokpJEINomYjQS7hpsbO1rDbN3t6O3px9KCU%2BKDTG1jET4kQvpWBnGx09Mj3KwaVX0wMHZrvZeMy55ocHextgvW3PliLlgzpABSLi%2FxR56gCk5oDu0Z9FXLhVShr90m39wmTZXdvbwsW88d3yztqVkW1VK5VrtM7trMmyxdvfxWtkea3i7tr9kRlaPlkklODRE8CBA611oJ7kCWI7eCT7T8hUAHcSEyyYLv44uGiqqHq4uHiiuHFeoeKk8QJW6aMV8%2FPRWBzq9RrnFnJlnCrWESdhbCmm8YDI7kUzkeBdGMPgdxjwqZlj5Jvoz6c%2Fk7OSrjMvz3t9%2FEL1HyhP85OUlU0lJJtOf%2FbQgUMkzngz3XfAJMdGdrY8pvIu9c130xFE%2Fo7A0tUk2G%2BcZGBdnXG2LtUmoTsMcO6Vvf7g%2F7Wtwqne5t%2FvuNYVQVIoHNbxkvFaUb4B7oJ9%2BTfcP5tdNm311xV9Wrtys5M2YibJU4l%2BbxxSPBPw5doxRoimtbK2N49mPG1GIfvAw%2BBtePyC6tHI8v90bcoU%2BiEzTWxwSzwiTayM8ozjbeSdCyfMu3eWCnuK%2Fq2tRRmEdro5zHoR9oqL1%2BtS8rFiTpx6qHCXedCoez3YFz%2B52f%2F6bnZlKy63HGrz77un8ChM8bTiuTxP5%2BS0ivI6cQihMRRIhlpH5h9bwZICFxfLX7tV38G5ukRNb63ufZ5pfMmX0OJTMxI%2FSHrz%2FQbE4Rchfr4Fm2Ubcimn5OU%2FvZBJJxyWlFsVhkRlaWzlaGLp7Edg%2Fsl%2BDjoCGPRJv4KsVp%2BETbOBB8tE3xFoNuPR5ZTcvOfK4fzv5jZ9Jz6bSNXHz2%2Bd4xkDyvP61KxqglIa2xJDm%2BKDGupdDTxaw2cTfn42hjVTncsh3Cq7UyBe9PeD8T9Ob%2BJDVTtmeG7P0J1eHbpadOT5WkaH3Bt5duG6gWDy0NKXq23OSnTksPwMOPUb%2BUwBQk3Jbsax2LMQuA2Ue4BHm2aCIk0QMbkW%2FvHM%2F1wOWjnYNC7d1hRp5IxQujqjIY3AZWx9ccFAq3Mw559brY5aI1I8QWj%2BaEMqlYF1u7tk3u3975AbyMGBeA8nLv8TUH2rpvNvblU1Lkdz3QG%2BiwOABpaoOefXRp33f4gWso8qd5UVnw6Pch6vYkAmLscja2wC7B%2BOEIllrUg0CQK5SLKv6ANKep1047vrmFpxp9VQIEdXJGkra9%2BhweUmIamE3N6EnkZqgRKuktXeZ4%2Fo2N5avrSWWeBy6g3K1113H3X2U1LglXF9ZkqXb5b%2BdcnIL5FecjzE0JjNB2H%2BSxsVNm8JtOB%2F2RB0czGIcVS1C7hpSjz1mwcripAdroHUxG3G935vNdyV42mT%2F6f2z1NxBF0mvSmwjD%2FvdzTje6%2FvwYSOuo4vkFnmfIfREvRATkYr0rivyOt5zQK7eQQ%2B9YJf%2FLlzwn0RlCCcp69mLAJ1rLPubr7KNjq%2BMn9WtVPsZ862guoztXQMv7VLtJO7p%2FIYrcA%2FKNigKceKo2k95xXuGku2wpCx2zmgsTh7OQbVFdgcxlOjbWD6uHf7RIfr98WgGJfNS5%2B5N7YQwYDTrB6CUjZxVAUuGykI4awjxRe%2FXvJw6kcD%2BHlodRDPnviRpG7Zm%2FXz4U7pMbHOyXAbfwzTNfwLIc8jx8cMDJzvyQ%2B8Gjx9wysLI%2Fx%2FJfuavxaNvBwfbi4Iw43kfMTalJbOvM%2F8POsBGyYImJN%2BGESpfSVl%2BQiqWzqyKRkNQS0tbYDivrv4sGQdZ7D9kF8fXZbBioGWShcIn%2F2dVVA%2BKVr9KRpndRdogbKjFqwXrVrm23dIxq%2F8ndXTf44iKyJjrOD62rbBcGLdJrNqnAm5M1Jj%2Be9W%2FDt%2Fsl0SOjQ62kL7TpY2yKon%2F6PzWMdPX1o3zrJCGSo1diNKN%2FRI9Hv3NyFvJCNLeimOCaq6xyXl4ANWtG4JXyQ8smhc2XrOJ%2B1NNP5g4vmTntVba46hns5ffZISyvHd%2BzmrqCYqUuWIp0njJTob5AvnOGOUQ6AG%2B%2BLc8xIGXmJ4JybUlT8rWgSy21CJ6o%2FUlZBJ1DreDM06nEZbq9%2FaFbycz4SifS9BEgfj0aBNzWAMuxmGbvs6Ra6e%2FEgw8ePXs%2FEBXiETTtShBBdy26j6iNSGurguNy4tjlJQ7N1O%2Fe%2BcnNLmmePjLEz%2BmuVENn69cCI7aNDrT0%2Fb1JdW2WRj%2FYJzDQoU4Veh3e5aL0QMXz3sOx5TOaptTaojSvQpoOmkofrJWTnaXifezuiTwr25nS3l18JZtc%2BiDQcZ3jZK%2B1cDNEtNfPFSV1UiyxbRCHycmpy1MJEH%2FO39QSHLxs8pQD%2BRCL6XJdb9HkyaJJUkO%2B9fabIlEpIc7dU1TcO%2B3jqGYmtljzsovZ%2FyjjMiWMke21M%2BSMVorR6%2Fs5A%2BSkrLXJ8bR5CImTEqRAx8qsefHkL%2F0Z8SV1c9uNCp9uCS%2B5OQeZgev0S2uR2YVMOd8pcokFUEX1Zpbmi%2BbR8BEo7M7Y9ExSnIzhLUdBWzuYjy%2BMRd%2FsDSptGlR63V%2B373xpV7MLrgSWspD0XBibqSub1tyUfPW%2BqRybSsILvDZwVjUydzCTdZAI7owcfrV8VxnLVCni9w%2BRi0yanwpzg2ENCob8Yz1o0dDA4Ai%2FrcehftEB2EA8LuaiOxWbHFlOGtyTPGdSx%2FmejCGsyra9TrjSCvWyc9T5lQTYzBRiVDcBG5iZGUF%2BtbS0zoPN%2BSZN2aGVvffOX%2FcNDVAH%2BD53Y0qCZnZY%2B7JOPz6I5fJ5kxqUeIa46OwH4329sio%2B9DyIi16iZxI2N2VwR%2FocNS5WwqRo0%2B8Q9B%2FVbCrIW274leHV7f3zXqJXEjYvpfeWBZarK%2FIGdrP2UtVmzCGyqEIVeleelVv5qu59PpHmJjOn4u9PvBpqSFqiIB8xUaA8c0nmgFMJFBbmfJHlakuNZlP4opnCup4qSDPWd8psGZMFqW3D4srQS0LG6sRk%2BiwY01We2ntTcjvzdnlKxupU4uLU9qkCC8u5ym5gOwLiRMdfsoTE9cUDhWvesswB7RDFciz0kOexoFZh%2F1iZCWGfyyKLTFo%2Bg3hxnc%2F6rec3nj7LMtlcdOk%2BzJD7EabvLTlrmV0WW%2FSmfnnppg18cMiSMBms4QVtNcrVSHTSx2mY9jg6CNzyIvCY2HjZVwW2ONiekb%2FrD%2BnbOdjbGQ43uq0KYtgpen15dfPe%2B15iQEoE5zqSvkCptAuYoa6O0nVbGH3p6KAGM9dzwl8CfigZ9SIqfqSpHL0u8%2FXIUgpqTj%2FUpwIx5XXOYlp6mMz0hy5zylbzI4V1bToWgtbTIrELzkyUUYMGTojpd%2FrfdAa8ULYGA1sDawODOgo4wqllscXQZSvXH9f%2BEy4%2FTnVWtLFkm4Sb9ZrdkQlQz4eSQV%2BZmYe520E%2F1XW0RCYZ5nLSXTHa9Qelh6NR1FgUSnb1jRTTG%2FF1eZQ%2FGkcxdkKxUd1nLlzJNgz0n4e5djjrV8iPKcY8gCDGnTYhKIPAxfRGalUW5YoKox59sVjdL%2BqXgk6eS0y19ze3vK1G0N%2Ba8wmpMonhd5JI13LRSDKsmQ0MJxsniaBBKVqQ%2Bcx%2BKvWrYF%2FRsbKytnLvzyqW5nA0DIawkzEc%2FBCrR6JerF%2FbEVnl%2FfVvTXhbtLextYo63cB8iqwXWJo%2Fs7BYfIsEzxZ2lLCSl1xfHEbCR1osCNtPLgtvFI66GRNtFS53WZa8hTEZkePTN6aBZ1%2Fdc5i4GwYOyMyMj01P9TXC470hmenx0emZRr74OCPv1NTY2MxUHwNcirNBekrs88lgny68T06mh3dxPguR443JzdGTyBCGVF8W%2FXhdxV%2FLX8N%2F%2BfJSsEawVrDqKO%2FHdzeQvkEFhqeGhYYl6Dil7RDpMDkyqjrtMXnCreO6j6xpC141jt9wMUwrzCZHrd%2B0oj7sFsmZZFtcdN6%2Bdz%2FL4jZCek4NeZ4hX%2BGr6SVZoJXmbhA95qWobB5qmq8dCgmAJ2IbNTzNXK05HOKMTLRUNN9ra%2F5fqpjo5updqv5qaxkbqSefdSLa9xki4pqLykIaErWThe834tTilw8%2BPX%2F45PsdUo45pChIS7tFeW0Vg1nfWMOsrmM2lhdcMLt7u5idRRfCcm83SLyru1e8t1Osp7tbQqLr9VEX6%2BgTtwCpswh5PYzRhEZFBgYHdoV30QRTwcyg5q5x2pq4YvNCUl5S8hyFvgVFKFjV2cvNDYmS10Wq%2BA50Yfinxq3Ly7d%2Fgd9vFRUAon%2Bw%2BvXLmrIDQwmiQ%2FviSkuU5lZwc2MYTMfWtDqpr9rwouDenIur60wObX9Ljgm7PqY9x0CwXEztTOy099NyZhbzSTNzpPy56VznakenqmpnC%2F8AKyt%2FLBQR4A%2BDBQSIvq%2Fq35xbNVz1jVhIMbQ%2FpN1hic85PoqOgATpa3xTx4Q4YeJJsb25lRk4tFtlbgoptVBaxv413M7DRgrD5RFmTZzIu1meYNhQYpN8Oyd5FZ8VNJ6mYaato%2BslnYmO2ibr%2BWTXE3R52g%2F5dczj%2BxTYuQ125i00OEs7%2FjwuzbMNXYxdL2VWRhWhAwtsXKjlaW9JQEyhzbk%2BNIo6D%2BiIc%2BufW576vv3Bxs%2Ff1Id%2F35opZt711D87eHuYn6uahOdhzLWOFB2G%2BNAd1TJOtlwuHoqclpNAxlK7UpzHODtF8O11gRQu%2Fdr7ZxoqB2bbegYnaqoHpj92RFiHOTvLRkRZh%2B5dhUqacPBi%2B7u8BNwEMF0Y7MAiv%2F%2FV2fxu%2FP%2BR%2FAck6a%2FRkzLBwcgKf9tEb0NvuE0IJsS1SwspiRx6Era1ezrbYykb5RAQ5YKBG3rZKn4Aa3gCRvd1mAz0YSqAfOXVVMV3Of9R5Q39Iq41rk19BLmmMS3R%2F%2BHhO7w6CySnEsgRpWulxFm3jPjfbtRXdJfLY%2Bpr6p3NHFC6qAHD2l1z86QUqDmsGxBglmZQQhLM3PSTShLyNZs%2BKLPD5BZgvIunlhI8RZertUiX1EI3n%2FzFlb8RL21zJNpQXvr5XqOt5kv2U%2Bt0idsoN7380FGwQdyEzpKT7rX4V%2B5u1eUX%2FMevy0ysL47eZU31JRcQ6wg32i2g94%2BtEJnGai5mLkIii1keYDdDRw%2F5CGjHg76t2VDIanmLiul8laGZU7xlLCwg0R5sGmihYaUFtleHZdlFELNCggrPyQvAXz%2B%2BpOoypqV3DC4GN77cuLo2RYNYXC%2FsQFp2OCntqfh%2B9qmNq32185XpDXGN3lZ8vM82YPmA9l4PLzgINQnDJM1jyB2Tt7%2FW1nUmFZcQvbJpammKvfRM2CPTSXSkw%2FToMvwSrL8YoHe1eTnUf58Lsx6f0jA9fegYjjecbq%2F7WeGUuRnroGcnhybnG8XYneQ5pU5FVuU3Jn7kIVZWZFRltTXWlLXklWeN2IGe8IzXlF%2BhACqIkQXEEAwFg00tdQ1MLP5cixoeQNOSIB14aLYLMrqwlt4PcFcSZWTmm%2BNmHZJdpYYEciTQ2UqjTuHAttRGE8SQ6TJ2jny2xC4cv%2FqCgUOrTfDOqSIz21ul7Sfh5SzXoDRu6%2BeAD5z30%2BbJ8QkUpbYNSfoIhf%2FSZgmTxgye0XMGnqhBYGN%2FzjCIa25woFMWGI%2Fh0duAFAmuCW5CIBKaew%2B4mZnv8e6loUGALeLocsTFT1rIWGC64NWkZ2OX%2B5aw6W3smb5w9ey%2Ft8RXDG3lPbXYHglPuTm0dD8IXgqeSV8oLUyfnZ7PmCUXp84Yl2yFZ5MYSJ%2Bzk4sjNPwOCbDAYCw2AdHIP7tsFEhtFDY%2Fzy%2BjPjKNTU8JDSUmYf1TksICsxMz%2FdXGlZTH1YJDlEblVDIP5exA1nKWIBBSEEdgJKWTsfLIXxzMyVYAl8yYlVaphlyZdZ9l3w7HzAPnH5kSvTDCifLn14zqBf%2BvL3l5zEePNfYIzL1mYiL3eEdrflrBjEcaG0mcvWbSIltnN7kL3HgG4tVsTp8OcJ%2B7u2HGcv34FJT9UOtBPN0NYyrxz28HeFDh6FdZNv2clFFMSMgs0XjzcrLK4uOzSjhHD%2B6RAvRXDeXu4QF8GB4TM698Mt9GN8kandf8xaiA6uW%2Fwoe7hHvWah8JPeCprskBaysUVxhuphv0fzaa4t%2B3PcvlkqSAXFZbKflL9fHL2t1O6MkaeJR87jn%2F%2FZ%2FJD84P5hLzTabVkw2HvGl8NwrQLDsw6teCtbCAlB1R7swPsJrd3AmwKsJXKHqvFff%2FxywD%2FgzvO%2BefVFrZFX%2F4fin7bZZonTwL5FVJiG%2FaJt4k1FXoRG%2FolH7oHIoXjlkonRf3PmYadmtA7%2FTMgigj7RsLyFhtEDqNn%2BeOUYsqmXxDPtX7byMOoZMkHTo1GTpH%2F7ljm6K2gFUboRMfwqz5OHesWtRn%2BZyZaZ0rtrkd8AMmOw6YfjVgzmcDxr%2Bf8uK8MXONTk1%2BMaig5QEaMDl0wBQbJ8Zm6rjfgLQUOgm10Okwce54WIzZFeVdwYes2%2BaZqwGT4wZM5x4wJ04ZL%2BhzOmObJ6A2dfmCddMV6JTxaj63%2FpOLxi8BGEyDh%2ByQT1333%2Fnc1cBA%2FK7abqD%2Fzv4%2BmokH2rCS50s8gNVyKcx6F2HRp6o0k7L%2BnH%2B%2Fnv5Yh%2FIWsNlpACwtZKucxwDQbdBGKQG6bZ1HO3tEW0ePpW3f4xGABYyc6J0%2BcPFu27QAKP9xKoDXKNEuTFUS4qLdowqIj51tZNijXwFQ7kR9ljjXx1CpuxXo9PaH%2BB0m3wU7cNFwxQKgupzypGkXMQVI99NV9YB8gRDw3AOfE7qvlNINqBNpyBWTU8wdHwOGNsITVt4AUEBDagVkwHKxOKBe3onCf8bp%2FQn%2Bw4PdGi3iFyB91OPdBuTb4%2BQYoU%2FAQ9H4xN7IH3f3MiNx5Hyw4AZw3awHY8l2awYznN%2FZWyEyOTc0IcVRsb%2FEKeyWUO7sdv2g08yQVTyG2fcUvDojgu%2BGZxuJj8rD79ucZYGRMkyVJI5LmhWjzmO6ZwSOrORcVxFesHZYhuXR2GfsHkh8Bq2r3MRtA%2B5SDGXCbohCu92u12bYcny4R9uizqGMGeu2HZoPbTYGFPHR2snMjWYngrFcYG6A%2B1Hx9RkXu71mD67bJ%2FEUT06Em0mR%2F4DiXZs5127bdLBeGhjMUK6HsWAzratL%2FWyZGcNBrkCLtzEP09XJ8rTu8xkPoYe6n52civVZ%2B%2BM5mc9X%2BK2b%2FL9vu5T3Kzy1nmXlJO3fJGEHafb6N5itdVEejsDnh3h8urT5fCHG0CzzZrzgd4dZsjphp3Oclqhedae2Cx7r2B156Q6fMK9EA4ZJiaXndz4CImHHMdgEtq3DRkVOFA0icArejq8FGXOPuMixh2%2BfI9WQSWj%2FUTs1tO4nAN%2FdVAluu3YFxpgSeio5oMO%2FiTUlDmjFgCLCJLvN5qiBkHij7%2FOl%2FIeiphD%2FdYC5LCAkOfgN4Qq8BaZZSQAgzdFfgoZHaPmZZAR0DoSJ3ITdTi1b2xakKhzLIL8i8Kh1CiumGbJ0oQPzgRFzYsOgeABesW35qMndh15WU1rXho1aE14xHr0j5O4F0q1fGgvb0vrcwdep1wCwlf1ELOboytK9SFmG02l3xdQLe1tCIvKwLdc7Q35XnYBgTcaTcwZaU8Inp6Ct%2BPMlavaWWovKlMgUBrWa8RlYHDY0DPM%2F9UzhXY7%2BVrJuBOYKAN0V1QsUQuTfCAJ0tXdUNWYShgAy8HgWZklyepHjh3ul1P5AvbW8IiMfzfbGFIACTsgbHJD%2BDkV6QyUHkaBf1%2BVYbM65GY%2BXywjg%2BYuApbuoEaGPDSJByvbHqyZSwoMFMXF%2BLNWm%2BhdRira8uiL30P8h6EpIk2yjHFvDwSXZyyRatfgVr6yuI%2BmhKhstloF28aZiIQ0trU8%2Fbf369%2Fr3DSpwOQFkmh0a4Xf4ZD2l%2FxEjsAB8FlhmK%2BYBcfAsf2MEoW0UuZIX55PJMN0dBlDq3y%2Fbl0K4E0X3IuufYTFuG%2FAWSJaWLebMOQ3wXOvwMc2m3ctMU0CYtaKG5QewbeCT2Se84n5y6wyStVicic%2F%2BfvSNMZvy4UMWpXf9Bo%2BXsB6UThiKgF2VhZUvx10qeAYjRsfmc7OhFb0JaLwAT8nJ3OtVDqxg9a4y1kW6rhXzqfGziV9pXWFvpxXA4RKgdlfCq28Fi2e%2FSFShbVhXKVxKmdQb%2BQ%2BB69fLjlkAhm64vOHI5YZZIzElZ6AxIhi43ygaboRA5%2BSGIsYbYlsSgaEUANmQYsrHqbGJVB3O3BHHC6To%2BZY2WUlTn%2Fq7mIkUNNkWQFLql0RMdoS%2BmmnrPeDAZywBEQRy8XTj%2BxKV0M1a1pSR9Co1JLOakgJGS%2BCZnsa2IhmJI4lQogqc5CqcfL2VPEta1nbst1MRBEyRgJb9ZmxL22HaKKllhcB5EdVQaJdTG6AmI6j6aZbwqgWTA%2FUk6RowmnkPi0Xpe4DoPYlI4yKZf71sKSYIOFRBfknAqN1gyulcoCBho8CWRQzqtxeZTi%2B9xOOTATq4tOWMdAc6BNboJrYRV5fETIysCJzIBgZtnnUnz56SyuZMZym4T21Pc%2BYKG0BXrwHIa2SlL7OkSjYks8Pg6l3sIwmPllsH7OVMjjDPJeXhOcNA20zYdjBBE%2BYipeBxesh0w5BAy65t%2FBSGJpH3uFgToFR1qxo%2B9s5GGgCFkQPVEgiYaDoms5Z99AWBQxj0PONNG0vJvWx5N9K8xPA%2Bk4iRc2ZyRH6gBGoJhGhKzMkt1MfkS3Y0RFUscmP0q%2BEQ6g2YxYlRDCBoJKRZbFfk4HkHjo1TNBYR%2FHiOziN6%2FY509ibuuqnCQBEheEVpzTUGf%2FtNlykCEfopFysImA4eeGCejzOhWqUBqBNNCzDq2Z5tmKr5ALljdFCMkSI7%2FdDHFOU%2FgGv9zIuaj1aSc99MfX9tcDGnfC%2BPnkdK2UPu9AGnedt1vPAuY0bKawMPNwtKg%2FEpO0uJLke%2BEZAhbZBdAF00bRXFYaJrh9ijsrNjJD%2FRFSJKKWvQuWrvzLJdoV2AOddHTGq4KDAg8m0Tdfr%2BaSVRtlOFJXYNKQ4ctWV0IMvVhGosSxC6HUqYkfxYKbSgRvOLZiVpnGUedQS%2Bsi8wjwh9hggEV3LgZQq%2BG1qM3q8RrW2bx9OSzj7DtzPZb9LTCvhS9TPxxTPx%2Fa%2Bfx%2Fd3i%2Fa%2BUl9doNTVYvHZx9cWekmfs1TFuuuKhjITF4eO5hYAeyonGBBoJYQIcV%2BocEn5hVRHgHGD3bBT2YhNBPODK0NgQBw67r21R%2F%2BpJ%2FWD%2BpG9ZR%2Fb%2F2zIrmExuvMyqp4NC3vUT8OwEJndVcVe071e6xf11%2FWn%2Bkf67%2FqFpk%2Bo%2BwqqFoEGyFQsh0PGLdUZRZWaCd0nYrEoXSXemKNL4JoSW8tYfrSiwjwv7ICoyFCgsGqbFACbbo%2FxHmfTLA5HpB6m8hE3eKxwRgtq8TDIS2R4h0tgflEFIqx5DPM8BqMjBR6KbezYG%2BDBzoXquDLUqPousQgehNLh29rJeGY8wQhq1RWaMOghdg%2BNIlt2Zposk8OQ96C6Auu6CtVRTcZ141RfSGu9C1ZLiCopw%2FXb0ryQooJO001cnCZS73jj0GG32W2tkDYK4d6AGIXPBcD7HrKsekSm0f%2BpMWYdSC5TcglPfqFxMFfE6vu2UrV5QCkFI5A3MJghtbEneGAeMSaL%2FNUvcspnoGDjyQ%2FWh9hmPczUIl5AvUtG6WfmmsDWBF4P%2BCw9KkbgUst8q%2FdtGHCo%2B5b3HcR79LegYTgVfOeGn%2FIOxjH0PRaHMQGKWtJa3k2UGJtP25vbMAuZDwjAofEuZ1nuQ8uDJ%2F7mwYbdYD9RJwPieIi4n3yK%2B%2BlFzD9Ynai0NLEtb2nZYjcylDb6dz2lt%2BiX9HcSRPFQRaETgQNDQweX3pptsuVHFEmYAHr4BOnfRo1lLvEMgO%2FxqJdNo%2BofhE%2Frt%2Bpf1n%2Bvaes6ZTjTf6TBCLPrWuG%2BSAQNE70ChjY0oCH2ObB5XnEWO%2FEkmUJJgIZ2AujyRq%2B4p%2B2ajEZHNDRAGZciwyuzyLaX0ORk53Pf24FtllN3nA27TnMzpHxMUk2jNyup2eC7Z9cb%2BNnvzLqhj4ymvRjXfpT2KqVBT10p%2Bi4qq%2FJFfHUkER0rCyCl3tkWZdULbOkf6VyFybAbS7VdM0laACch1xIL6vD2IpAHLeX%2BnM%2BUdzawMhqw74E3G17eTlmA1zFKuZjjzL3SCZvalwBqS4%2Fh%2FtCSyjxMWv2Tp1rGTchXAGROCDIkeOyqkY5UhDl44pm1e4AiaLxN39PtfHjXHTdnYPimeoBAkvZVM%2FY%2F%2BQn8bpFtTkTn%2B%2B1nPjlN29rZA%2FPxJzj7ue1lOQVMqEqFWwDXscMPXxfVtZ%2B7QK2u5w8fAExtqbWNUPksf5Qx52dDw5a30sFK7evxM9iG7CJyGbvG84bD%2F1GmVRQtIwLAnVGuCzM6%2FOf6Zowx072rLBSxOKUQuCjXlsUjXEVhqtdz6wQITJGZ%2FrZmhHvmlpshzEULFiRthq7NWXdcCG2fRtGJB%2FcVwIzV6A01pvYb90ZONjU7mVBkRpyu7od%2FAIJBXZu9kooYFO4qHRTYvOoblrL0RVyD3NAnGVrGkZL2hVz%2FH%2Bn8LPzZnSVMTmkeBStdkJxpnpMjIE5vtcDcVeZAC9C0dCheTDFN%2B4z8bJ1lQT3uk%2BDSpKpf4A9C0dvncAhJyMUPyPOi8OvKRInuVbAVTUKdYsQVlunHgXi%2FHQIsIImGJtz7KpV%2BlcDVTBjJZeLoYZCCiGOKaOnWUzICSKbFSvX9lfy0VTV3XwIeZBnf0jqwnmUTzMkCPmHBqZF81yS4idq0IBVU0acAdaS0BWKpvk66MaOAHZC5GLQ2j5hF4izrpM35nfeQjhJ29%2B69S%2FU%2B%2Fx4ldt35vm0n0Hhp2kzw9oI5B41uaET3a8xs1r%2FMbJyn5sSbNR3jeTvv0Yofw%2FLePtD6yvz7SF8k9B4epzzHf4v9WqSpMWFS0QOLAOZueZ6F8U0Yona8pDURMoNUpJcIxPpCBA8oyUCCf02hC1oJSaeRPLInpJxHyeXPcd%2FEMP2iYMC6srrKhac31vM4hHFJgLx7dQPrMXv9jD%2F89Wx0vA9M40cg%2BD8U7jVCYsET2MkVXh8O4Li%2BHplbkFHhup5lbQZtCOJjkxdT1xU9G1fK%2BpyplMtYwCx0HIqbjtwjE73sPdI0nN%2FHOwD8rzLvEXso2jcG4vCKQtoXLzPsIfSAZgpBrXBlby9WI52w24FO%2BjbG0P9PZwbiXCWnK0jWfsXv3a1m5nyVny8uOAfjDpjBoKnns%2Bo9escAxu8DQ2ptADz1awOO%2Fre931%2FGqmCru0WxupfPAeJWr%2Fj2oRpPY%2FbheRh7Ht8tnuPu3Wlszg%2FEHgG7j3VXPmJ6%2B0A3LWA3LEOqquWwiOxe5Xa57D06w4nfxxe4%2BT9d%2Bh6J70YmKW2YLh5x7n4g2xYmArSnJb%2B9KCqTaO6UWhm%2By%2FMjgoD2GcEXj4Ll%2BO%2FZTu3MZEwDillsyajV7wOTeEee%2F92e7MNChwyIOxu1XnxM43TcOLMmZMT4HRoYhnI9rO0WG6vmdW3WQvZIU0xvJcHjxQM1joctFUUYI90%2BNTYTIlj%2BrsO%2B7IWcec1U61q8rtfmAQ7QDRZVDOtg1K9W0H%2FH%2FUMdOr6%2F9wJaF5MY2pKOSgE6Rmx8pOzLZRlTMjxDEb7gC%2BKykqTYdB3amioZqUWznp1i%2BnyVZdOztPO8pZ6yzXlMOX7IDshVu6IaVysWtrcDnLPC%2BEobanCPAGbovGy5gcHkGXXOVC7R9E9obwa%2Bg8ziJFMtLvwnANdN%2FWwTrHTrSphCwMGpbzdp4RysAwwrLmpcdzAOvk09f%2FFdoYEn%2BN7%2Bv9%2FTlKY%2F9OFa%2F%2FWa%2FCnWejOwp3%2BAIAwI1w3lVnayF4iZBA98PhFPtAJRZW%2Bsm%2Fr9Pq2BHKqq5BTf%2B9W9GIQkFe5KVBfPK%2Bs%2BayVPRsfGzK1GOlVQ%2FXu8AFe%2FFZPHET88c1gH17Ogbb2utFIA5APOpo3C8z7SOJ%2Fh78xmw8sREdXxiZenCML15uCUSkQAx6GXReGktYLOHehj5FHoZvLRvkv0ftdjw8NRNqOpt5iLUTd6CVSnvlt3v%2BxYQCcXlK58CYl7kqFz6WQCVyZemvSsafXJLg4HlcFfy%2BZLTnSvl5h8MlX%2F7kCeSps8IJiMh4CqoovVXDQMUjd4%2BCTxhjZAyQcMgzmtCMfCh4%2B4mOAoJvw4OC0W3qU0x6lHvhdAAACPxahdZ7c292Q1%2BEZH%2F4OS%2BRPiXTLN9RYR%2F9v%2B7ywDL51m4gcw81NTjRKjq%2F%2BvA2aX%2BRMcEs1%2FOvOat%2Bu2hZG6MCB3V20iqyS7bvKUK1lEd8y%2BXfBKX2TlPKiRYlh9WIUbeWVx4FwGltUjW0SxrVNn8tR6XD2OHmlPjMdDtIoJjtxc1gVOBxCwrsPSjK1XFtGsAG1bC41DQnsRiRrXcSabtV0JHaWbZL%2Fwa8KLqqNg73NyZ7YeIaFeAIXdYPnVHMLtk%2BH6C9BfjwnNqeuzgHoHk9yutlQA9%2BoVQbhExJ86nYJrO9f6R3f5DjsKF1ffMp8Sr3i8jUt31lcb%2BcipZX64u%2B8EQ8n6mit08xMFn6o%2B5lMkSeNQGysM0F2Oqwbir1aA8iqzwkuxBqbDfOWghkRz4GlnJ8L0Ejji2UrppLK0kl03v%2FyFbhkMxQeaw%2FXnqUD8KmHC5FPqnaBYR0kT1t0MRemcTZOAkGJfmGxOil3XzqDzKFFtzZm23uUo1%2B8Y%2F54DpL%2Be1rRDypqbIlfJMhzU3UAI9Le0jL1ujcuZYM%2BPTI16AL3pFHnqIW06rU9gNTcFfD2x17GqRspXK8DzAxx63pRKCX0%2FV73pdW1MXqS6qIDdR90lKR%2F%2FZlkSuChCUAbJF8q61IWy8qAOeTB2p6fhRvk1nGsGmAAaj%2FQRAwOCbXc7OcqPf3Si139duThdJdsiBxG7cxQkZF%2Fifll%2B%2FN5%2F46LRf%2FHIQiAvHUtMzFlCrNk8ew7iSsyTBDKFSiuZswyVzVzOyCsoKlWmKlBVU9fQ1NLW0atfVgMYGv1ZhIo2AAAAAAAAAAAAAADA3xqjh84Oz8Pw2idf7iB0h8EbYRib1uI5hFR6i5bJrWBt01bi3P33NIigCABgAAAAAAAAfC5nEUWu7%2FPA6%2Fs26ZPvCxrE7yjSGFvKuZbGYqyVYzEWY9GW666d0DvSv40HGB69pxh3EHdHUeMmoaa%2BGcK1CLEhlLVltRd9J9tdn3v45IvGhVR6iy09yyVJkiRJkuTfHm%2F90PMgssij97gbm3NAhAll7RPeCaV6ERERERH5vM7CHa57vtZr%2BOSLwRua0cgY32mcxgtIpbdomdwK1jZtJX6UYneOzZ4ZVVVVVVVVVVX9fB4M33h0n4ZXdKzcGLsWESaUtU97J7SizczMzMzMBl2YWf%2Br6ffvofdoX1Nn8IT7POi19cmXBvFrbtB44awIQqKvKcychbJ6NvYc2XIhIBokbp68ZSUSKRkphkpLRz7LLyAoJFKGW7b0ciSvoKhUmVUFqmrqGppa2jp69StrAEOjxmiOFmhTZVvqoMo742t5D3xeJEokkSlUWgfu%2F8%2BBw3sYPve5PT8vGK8Yi7EYi9CEcCCQ0ZFMYM6CrJ6NPQdyITFPkiVTqLR0Vj7wCwgKiTT0zNCC7biez89CKiCB5Obg7tl6wNPL2Rt9FX1%2FSmNcAQAAAAAAALKi%2B5EEAKH3AwAAhD4XP%2FjCRx6c%2F%2FULRPwQGka4RSCjIzt0xsPF4nD94vAFi9%2FkTUjMlmTJFCotnZUP%2FAKCQiJl8pSFnLyCopKyiqqauoamlraO3g6yEfEXdW1hOuCdbdcDLMsadD5%2BAUEhkTPvHL5%2FvtsoPNmfU3fIPS4IQG6evBHj9n7Tvjz%2FkDWe7M8pUo6IiIiIzvsS4cl%2BjBj4hv1y8wcBc%2B73ucfnHpl7GzMzMzNz7k9NfmNMO2TbtkjRQERERGqaqqqqqn75v01%2F2n23Fw3gCGQ0K4vPRjKycvIKikrKKqpq6hqaWto6ehbti3sn5HwdcXJyBuoAAoM8jB89geTA4CxKBIZoKQEEiUCQwLY%2FUAiAQBsAgroBAAAAAAAAdcXpdDodj06n63s%2FPngF197nw%2Bvd%2B4QQQgghhBBCCCGEUX6EEEIIIYQQQgghhBBCGGOMMcYYY4wxxhhjjDEhhBBCCCGEEEIIIYQQQimllFJKKaWUUkoppZQyxhhjjDHGGGOMMcYYY%2F3c469l1mo5tZq0pmmaptVE%2ByXUb%2BuPv%2F3rqf6N%2B3Tcwe6OVuMmoaa%2BGcK1CLEhlLVltRd9J5vn4ZxzzjnnnPNB2YJzIYQQQgghhBCDsoUQUkoppZRSSikHZQsplVJKKaWUUkoNyhZKAdfr9QAAAMCgbAG9hYUFSZIkSZIWZ%2FmAR%2BMVEGFCWXvun1OgZEmSJMm2bdu2iSciIiIiosNVlvZLOvZ%2BAAAAAAAAAAAAAAAAAAAAAAD0GKFhaBiqajRhmqZltUKWbdu24ziO67qu53kecx7cMzMzc5EmhBBCCCGklFJKKaVUSimllFJKa6211lprhwQAAAAAICIiIiISEREREZ3jYV18zi%2FLMTMzM3PZYxARERGp2VRVVVXVzMzMzDoHSdCxaDdS4H0kPJzQyOanzB2Qis8u%2F5ru7T%2Ffos5IVgbM5GzeGcb1xc7UrDV%2BfbO41Os7K6re03ntaZKtSP7CiUHzFg4%2Fd%2FIXJoiPCKH8oK7kADEmTMYxnjFfPvWzCo4YRbzcErIYk6kY5GVVKi1zTB%2FFCxKRmFGlFOSl%2BOkLVpQDRbdXR9Kj7ItTlHiL7KhvhPovKRFwArAsVFC5HrwTnjIES6bM2UDbiYrUKFG5MNxwYM2yzar3Aelia89QNZ3eyIxZv8HxjTev%2BcyPHQdOXLjx4MWHnwBBQoSJECXmOhBxEiRJkSZDlhx5ipQoU6FKjToNmrRo06FLjz4DhoyAQRgzYcqMOQvQiwB%2FzlmBQ7Bmw5YdJBQ0ew4cOXHmwpUbdxgePHnxdkObTFlmVHorW5F8DXq0JypXJGr7cd8wvviqUJVcS577rFGvby591%2Bqmdav6%2BfBVws8mf2s2nMG6Z8%2B%2BAQE%2BIXvovgcCnXsvT7AgIcKECtcsQpTIZ%2F3zN0a0WHHeiUeQIFGyJONaEKVIlebCB5MeGXTLgWcODblt1Jg7ho1YlqPPrDnTicaPiTb1aZRmfktlgaxt15ZtOzV8Ehp6LebYIBUVYzP6iFP8cXjfCJw%2FtfkEF7FptYWJiqqbQ40Je1wMDh8T6Y8LisBdiepw1qB8b2%2B8sf9FXw5HXzoi3Zf6QzcfHVHdrnvrhC9etP0LV01%2FdVH3x3f1l2bTQ1%2Bl%2F8%2BMRVCxg9vjtn980fTpYL%2FEEb%2FE5qJlj0ThDt9C%2BgvzhDlnlpqmWL%2Bw%2FSN09twFkYfJl9qh%2BVIx5F8yRH1JD7Hy7%2B%2BpzxZKffweCkWYEMK4N2fhHop78QW%2Foiq8vOztRA8%2F3ePRMMw2In4zxPY7wEdHjdp13Goj%2FDgkOGl3tEN8v%2Fjw9gaL%2BzPMjmqI%2FSbD9Z%2B22f2uLBLz9GkYTj199ixsgIk%2BhT0PdCtVpwAA%27%29%20format%28%27woff2%27%29%3B%0Aunicode%2Drange%3A%20U%2B0000%2D00FF%2C%20U%2B0131%2C%20U%2B0152%2D0153%2C%20U%2B02C6%2C%20U%2B02DA%2C%20U%2B02DC%2C%20U%2B2000%2D206F%2C%20U%2B2074%2C%20U%2B20AC%2C%20U%2B2212%2C%20U%2B2215%3B%0A%7D%0A%0Ahtml%2C%20body%2C%20div%2C%20span%2C%20applet%2C%20object%2C%20iframe%2C%20h1%2C%20h2%2C%20h3%2C%20h4%2C%20h5%2C%20h6%2C%20p%2C%20blockquote%2C%20pre%2C%20a%2C%20abbr%2C%20acronym%2C%20address%2C%20big%2C%20cite%2C%20code%2C%20del%2C%20dfn%2C%20em%2C%20img%2C%20ins%2C%20kbd%2C%20q%2C%20s%2C%20samp%2C%20small%2C%20strike%2C%20strong%2C%20sub%2C%20sup%2C%20tt%2C%20var%2C%20b%2C%20u%2C%20i%2C%20center%2C%20dl%2C%20dt%2C%20dd%2C%20ol%2C%20ul%2C%20li%2C%20fieldset%2C%20form%2C%20label%2C%20legend%2C%20table%2C%20caption%2C%20tbody%2C%20tfoot%2C%20thead%2C%20tr%2C%20th%2C%20td%2C%20article%2C%20aside%2C%20canvas%2C%20details%2C%20embed%2C%20figure%2C%20figcaption%2C%20footer%2C%20header%2C%20hgroup%2C%20menu%2C%20nav%2C%20output%2C%20ruby%2C%20section%2C%20summary%2C%20time%2C%20mark%2C%20audio%2C%20video%20%7B%0Amargin%3A%200%3B%0Apadding%3A%200%3B%0Aborder%3A%200%3B%0A%7D%0A%0A%23tiHeader%20ul%20%7B%0Alist%2Dstyle%2Dtype%3A%20none%3B%0A%7D%0A%23tiHeader%20%2Enav%20%7B%0Abackground%3A%20%23c00%3B%0Aheight%3A%2041%2E375px%3B%0A%7D%0A%23tiHeader%20%23top%5Flogo%20%7B%0Aheight%3A%2036px%3B%0A%7D%0A%23content%20%7B%0Apadding%3A%201em%3B%0Amax%2Dwidth%3A%201200px%3B%0Aoverflow%3A%20auto%3B%0Amargin%3A%200%20auto%3B%0A%7D%0A%23tiFooter%20%7B%0Aclear%3A%20both%3B%0Acolor%3A%20%23b0b0b0%3B%0Afont%2Dsize%3A%20%2E9em%3B%0Apadding%3A%201em%202em%3B%0Apadding%3A%201em%202rem%3B%0Aborder%2Dtop%3A%201px%20solid%20%23e0e0e0%3B%0Abackground%3A%20%23fff%3B%0A%7D%0A%23tiFooter%20p%20%7B%0Amax%2Dwidth%3A%2060em%3B%0A%7D%0A%23tiFooter%20a%20%7B%0Acolor%3A%20%23b0b0b0%3B%0A%7D%0A%23tiFooter%20a%3Ahover%20%7B%0Acolor%3A%20%23c00%3B%0A%7D%0A%0Abody%20%7B%0Afont%2Dfamily%3A%20%27Open%20Sans%27%2C%20sans%2Dserif%3B%0Afont%2Dsize%3A%2014px%3B%0Aline%2Dheight%3A%201%2E6%3B%0Acolor%3A%20%23555%3B%0Abackground%2Dcolor%3A%20%23fff%3B%0Amargin%3A%200%20auto%3B%0A%7D%0Abody%3E%2A%3Afirst%2Dchild%20%7B%0Amargin%2Dtop%3A%200%20%21important%3B%0A%7D%0Abody%3E%2A%3Alast%2Dchild%20%7B%0Amargin%2Dbottom%3A%200%20%21important%3B%0A%7D%0A%0Ap%2C%20blockquote%2C%20ul%2C%20ol%2C%20dl%2C%20table%2C%20pre%20%7B%0Amargin%3A%2015px%200%3B%0A%7D%0A%0Ah1%2C%20h2%2C%20h3%2C%20h4%2C%20h5%2C%20h6%20%7B%0Amargin%3A%200%200%20%2E5em%200%3B%0Apadding%3A%200%3B%0Afont%2Dweight%3A%20600%3B%0Acolor%3A%20%23333%3B%0A%2Dwebkit%2Dfont%2Dsmoothing%3A%20antialiased%3B%0A%7D%0Ah1%20tt%2C%20h1%20code%2C%20h2%20tt%2C%20h2%20code%2C%20h3%20tt%2C%20h3%20code%2C%20h4%20tt%2C%20h4%20code%2C%20h5%20tt%2C%20h5%20code%2C%20h6%20tt%2C%20h6%20code%20%7B%0Afont%2Dsize%3A%20inherit%3B%0A%7D%0Ah1%20%7B%0Afont%2Dsize%3A%202em%3B%0A%7D%0Ah2%20%7B%0Afont%2Dsize%3A%201%2E6em%3B%0Aborder%2Dbottom%3A%201px%20solid%20%23ccc%3B%0A%7D%0Ah3%20%7B%0Afont%2Dsize%3A%201%2E4em%3B%0A%7D%0Ah4%20%7B%0Afont%2Dsize%3A%201%2E2em%3B%0A%7D%0Ah5%20%7B%0Afont%2Dsize%3A%201em%3B%0A%7D%0Ah6%20%7B%0Afont%2Dsize%3A%201em%3B%0A%7D%0Abody%3Eh2%3Afirst%2Dchild%2C%20body%3Eh1%3Afirst%2Dchild%2C%20body%3Eh1%3Afirst%2Dchild%2Bh2%2C%20body%3Eh3%3Afirst%2Dchild%2C%20body%3Eh4%3Afirst%2Dchild%2C%20body%3Eh5%3Afirst%2Dchild%2C%20body%3Eh6%3Afirst%2Dchild%20%7B%0Amargin%2Dtop%3A%200%3B%0Apadding%2Dtop%3A%200%3B%0A%7D%0Aa%3Afirst%2Dchild%20h1%2C%20a%3Afirst%2Dchild%20h2%2C%20a%3Afirst%2Dchild%20h3%2C%20a%3Afirst%2Dchild%20h4%2C%20a%3Afirst%2Dchild%20h5%2C%20a%3Afirst%2Dchild%20h6%20%7B%0Amargin%2Dtop%3A%200%3B%0Apadding%2Dtop%3A%200%3B%0A%7D%0Ah1%2Bp%2C%20h2%2Bp%2C%20h3%2Bp%2C%20h4%2Bp%2C%20h5%2Bp%2C%20h6%2Bp%20%7B%0Amargin%2Dtop%3A%2010px%3B%0A%7D%0A%0Aa%20%7B%0Acolor%3A%20%23189%3B%0Atext%2Ddecoration%3A%20none%3B%0A%7D%0Aa%3Ahover%20%7B%0Atext%2Ddecoration%3A%20underline%3B%0A%7D%0A%0Aul%2C%20ol%20%7B%0Apadding%2Dleft%3A%2030px%3B%0A%7D%0Aul%20li%20%3E%20%3Afirst%2Dchild%2C%0Aol%20li%20%3E%20%3Afirst%2Dchild%2C%0Aul%20li%20ul%3Afirst%2Dof%2Dtype%2C%0Aol%20li%20ol%3Afirst%2Dof%2Dtype%2C%0Aul%20li%20ol%3Afirst%2Dof%2Dtype%2C%0Aol%20li%20ul%3Afirst%2Dof%2Dtype%20%7B%0Amargin%2Dtop%3A%200px%3B%0A%7D%0Aul%20ul%2C%20ul%20ol%2C%20ol%20ol%2C%20ol%20ul%20%7B%0Amargin%2Dbottom%3A%200%3B%0A%7D%0Adl%20%7B%0Apadding%3A%200%3B%0A%7D%0Adl%20dt%20%7B%0Afont%2Dsize%3A%2014px%3B%0Afont%2Dweight%3A%20bold%3B%0Afont%2Dstyle%3A%20italic%3B%0Apadding%3A%200%3B%0Amargin%3A%2015px%200%205px%3B%0A%7D%0Adl%20dt%3Afirst%2Dchild%20%7B%0Apadding%3A%200%3B%0A%7D%0Adl%20dt%3E%3Afirst%2Dchild%20%7B%0Amargin%2Dtop%3A%200px%3B%0A%7D%0Adl%20dt%3E%3Alast%2Dchild%20%7B%0Amargin%2Dbottom%3A%200px%3B%0A%7D%0Adl%20dd%20%7B%0Amargin%3A%200%200%2015px%3B%0Apadding%3A%200%2015px%3B%0A%7D%0Adl%20dd%3E%3Afirst%2Dchild%20%7B%0Amargin%2Dtop%3A%200px%3B%0A%7D%0Adl%20dd%3E%3Alast%2Dchild%20%7B%0Amargin%2Dbottom%3A%200px%3B%0A%7D%0A%0Apre%2C%20code%2C%20tt%20%7B%0Afont%2Dsize%3A%2012px%3B%0Afont%2Dfamily%3A%20Consolas%2C%20%22Liberation%20Mono%22%2C%20Courier%2C%20monospace%3B%0A%7D%0Acode%2C%20tt%20%7B%0Amargin%3A%200%200px%3B%0Apadding%3A%200px%200px%3B%0Awhite%2Dspace%3A%20nowrap%3B%0Aborder%3A%201px%20solid%20%23eaeaea%3B%0Abackground%2Dcolor%3A%20%23f8f8f8%3B%0Aborder%2Dradius%3A%203px%3B%0A%7D%0Apre%3Ecode%20%7B%0Amargin%3A%200%3B%0Apadding%3A%200%3B%0Awhite%2Dspace%3A%20pre%3B%0Aborder%3A%20none%3B%0Abackground%3A%20transparent%3B%0A%7D%0Apre%20%7B%0Abackground%2Dcolor%3A%20%23f8f8f8%3B%0Aborder%3A%201px%20solid%20%23ccc%3B%0Afont%2Dsize%3A%2013px%3B%0Aline%2Dheight%3A%2019px%3B%0Aoverflow%3A%20auto%3B%0Apadding%3A%206px%2010px%3B%0Aborder%2Dradius%3A%203px%3B%0A%7D%0Apre%20code%2C%20pre%20tt%20%7B%0Abackground%2Dcolor%3A%20transparent%3B%0Aborder%3A%20none%3B%0A%7D%0Akbd%20%7B%0A%2Dmoz%2Dborder%2Dbottom%2Dcolors%3A%20none%3B%0A%2Dmoz%2Dborder%2Dleft%2Dcolors%3A%20none%3B%0A%2Dmoz%2Dborder%2Dright%2Dcolors%3A%20none%3B%0A%2Dmoz%2Dborder%2Dtop%2Dcolors%3A%20none%3B%0Abackground%2Dcolor%3A%20%23DDDDDD%3B%0Abackground%2Dimage%3A%20linear%2Dgradient%28%23F1F1F1%2C%20%23DDDDDD%29%3B%0Abackground%2Drepeat%3A%20repeat%2Dx%3B%0Aborder%2Dcolor%3A%20%23DDDDDD%20%23CCCCCC%20%23CCCCCC%20%23DDDDDD%3B%0Aborder%2Dimage%3A%20none%3B%0Aborder%2Dradius%3A%202px%202px%202px%202px%3B%0Aborder%2Dstyle%3A%20solid%3B%0Aborder%2Dwidth%3A%201px%3B%0Afont%2Dfamily%3A%20%22Helvetica%20Neue%22%2CHelvetica%2CArial%2Csans%2Dserif%3B%0Aline%2Dheight%3A%2010px%3B%0Apadding%3A%201px%204px%3B%0A%7D%0A%0Ablockquote%20%7B%0Aborder%2Dleft%3A%204px%20solid%20%23DDD%3B%0Apadding%3A%200%2015px%3B%0Acolor%3A%20%23777%3B%0Afont%2Dsize%3A%201em%3B%0A%7D%0Ablockquote%3E%3Afirst%2Dchild%20%7B%0Amargin%2Dtop%3A%200px%3B%0A%7D%0Ablockquote%3E%3Alast%2Dchild%20%7B%0Amargin%2Dbottom%3A%200px%3B%0A%7D%0A%0Ahr%20%7B%0Aclear%3A%20both%3B%0Amargin%3A%2015px%200%3B%0Aheight%3A%200px%3B%0Aoverflow%3A%20hidden%3B%0Aborder%3A%20none%3B%0Abackground%3A%20transparent%3B%0Aborder%2Dbottom%3A%201px%20dotted%20silver%3B%0Apadding%3A%200%3B%0A%7D%0A%0Atable%20%7B%0Aborder%2Dcollapse%3A%20collapse%3B%0Afont%2Dsize%3A%201em%3B%0A%7D%0Atable%20th%20%7B%0Abackground%3A%20%23F0F0F0%3B%0Acolor%3A%20%23555%3B%0Atext%2Dalign%3A%20left%3B%0Avertical%2Dalign%3A%20middle%3B%0A%7D%0Atable%20th%2C%20table%20td%20%7B%0Aborder%3A%201px%20solid%20%23ccc%3B%0Apadding%3A%206px%2013px%3B%0A%7D%0Atable%20tr%20%7B%0Aborder%2Dtop%3A%201px%20solid%20%23ccc%3B%0Abackground%2Dcolor%3A%20%23fff%3B%0A%7D%0Atable%20tr%3Anth%2Dchild%282n%29%20%7B%0Abackground%2Dcolor%3A%20%23f8f8f8%3B%0A%7D%0A%0Aimg%20%7B%0Amax%2Dwidth%3A%20100%25%0A%7D%0A%2Eplatform%20%7B%0Abackground%3A%20%23cc0000%3B%0Atext%2Dalign%3A%20right%3B%0A%7D%0A" rel="stylesheet" type="text/css" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <!--[if lt IE 9]>
    <script>
    /**
    * @preserve HTML5 Shiv 3.7.3 | @afarkas @jdalton @jon_neal @rem | MIT/GPL2 Licensed
    */
    !function(a,b){function c(a,b){var c=a.createElement("p"),d=a.getElementsByTagName("head")[0]||a.documentElement;return c.innerHTML="x<style>"+b+"</style>",d.insertBefore(c.lastChild,d.firstChild)}function d(){var a=t.elements;return"string"==typeof a?a.split(" "):a}function e(a,b){var c=t.elements;"string"!=typeof c&&(c=c.join(" ")),"string"!=typeof a&&(a=a.join(" ")),t.elements=c+" "+a,j(b)}function f(a){var b=s[a[q]];return b||(b={},r++,a[q]=r,s[r]=b),b}function g(a,c,d){if(c||(c=b),l)return c.createElement(a);d||(d=f(c));var e;return e=d.cache[a]?d.cache[a].cloneNode():p.test(a)?(d.cache[a]=d.createElem(a)).cloneNode():d.createElem(a),!e.canHaveChildren||o.test(a)||e.tagUrn?e:d.frag.appendChild(e)}function h(a,c){if(a||(a=b),l)return a.createDocumentFragment();c=c||f(a);for(var e=c.frag.cloneNode(),g=0,h=d(),i=h.length;i>g;g++)e.createElement(h[g]);return e}function i(a,b){b.cache||(b.cache={},b.createElem=a.createElement,b.createFrag=a.createDocumentFragment,b.frag=b.createFrag()),a.createElement=function(c){return t.shivMethods?g(c,a,b):b.createElem(c)},a.createDocumentFragment=Function("h,f","return function(){var n=f.cloneNode(),c=n.createElement;h.shivMethods&&("+d().join().replace(/[\w\-:]+/g,function(a){return b.createElem(a),b.frag.createElement(a),'c("'+a+'")'})+");return n}")(t,b.frag)}function j(a){a||(a=b);var d=f(a);return!t.shivCSS||k||d.hasCSS||(d.hasCSS=!!c(a,"article,aside,dialog,figcaption,figure,footer,header,hgroup,main,nav,section{display:block}mark{background:#FF0;color:#000}template{display:none}")),l||i(a,d),a}var k,l,m="3.7.3",n=a.html5||{},o=/^<|^(?:button|map|select|textarea|object|iframe|option|optgroup)$/i,p=/^(?:a|b|code|div|fieldset|h1|h2|h3|h4|h5|h6|i|label|li|ol|p|q|span|strong|style|table|tbody|td|th|tr|ul)$/i,q="_html5shiv",r=0,s={};!function(){try{var a=b.createElement("a");a.innerHTML="<xyz></xyz>",k="hidden"in a,l=1==a.childNodes.length||function(){b.createElement("a");var a=b.createDocumentFragment();return"undefined"==typeof a.cloneNode||"undefined"==typeof a.createDocumentFragment||"undefined"==typeof a.createElement}()}catch(c){k=!0,l=!0}}();var t={elements:n.elements||"abbr article aside audio bdi canvas data datalist details dialog figcaption figure footer header hgroup main mark meter nav output picture progress section summary template time video",version:m,shivCSS:n.shivCSS!==!1,supportsUnknownElements:l,shivMethods:n.shivMethods!==!1,type:"default",shivDocument:j,createElement:g,createDocumentFragment:h,addElements:e};a.html5=t,j(b),"object"==typeof module&&module.exports&&(module.exports=t)}("undefined"!=typeof window?window:this,document);
    </script>
  <![endif]-->
  <link href="data:image/x-icon;base64,AAABAAIAEBAQAAEABAAoAQAAJgAAABAQAAABAAgAaAUAAE4BAAAoAAAAEAAAACAAAAABAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAgAAAgAAAAICAAIAAAACAAIAAgIAAAMDAwACAgIAAAAD/AAD/AAAA//8A/wAAAP8A/wD//wAA////AAAAAAAHlwAAAAAAAHmXAAAAAAAHmZcAAAAAAHmZmXAAAAd3mZd5lwAACZmZf/eZcAB5mZn5l5mXB5mZmfmfmZl5mZmZ+Z+ZmZmZmZf5n3mXAACZl/efeZAAAJmZf/eZcAAAmZmfmQAAAACZmZCZAAAAAJmZcAAAAAAAmZkAAAAA/4/8/f8P/P3+D/z9/Af8/eAD/P3gAfz9wAD8/YAA/P0AAPz9AAD8/fAB/P3wAfz98A/8/fBP/P3wf/z98P/8/SgAAAAQAAAAIAAAAAEACAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAACAAACAAAAAgIAAgAAAAIAAgACAgAAAwMDAAMDcwADwyqYA1PD/ALHi/wCO1P8Aa8b/AEi4/wAlqv8AAKr/AACS3AAAerkAAGKWAABKcwAAMlAA1OP/ALHH/wCOq/8Aa4//AEhz/wAlV/8AAFX/AABJ3AAAPbkAADGWAAAlcwAAGVAA1NT/ALGx/wCOjv8Aa2v/AEhI/wAlJf8AAAD/AAAA3AAAALkAAACWAAAAcwAAAFAA49T/AMex/wCrjv8Aj2v/AHNI/wBXJf8AVQD/AEkA3AA9ALkAMQCWACUAcwAZAFAA8NT/AOKx/wDUjv8Axmv/ALhI/wCqJf8AqgD/AJIA3AB6ALkAYgCWAEoAcwAyAFAA/9T/AP+x/wD/jv8A/2v/AP9I/wD/Jf8A/wD/ANwA3AC5ALkAlgCWAHMAcwBQAFAA/9TwAP+x4gD/jtQA/2vGAP9IuAD/JaoA/wCqANwAkgC5AHoAlgBiAHMASgBQADIA/9TjAP+xxwD/jqsA/2uPAP9IcwD/JVcA/wBVANwASQC5AD0AlgAxAHMAJQBQABkA/9TUAP+xsQD/jo4A/2trAP9ISAD/JSUA/wAAANwAAAC5AAAAlgAAAHMAAABQAAAA/+PUAP/HsQD/q44A/49rAP9zSAD/VyUA/1UAANxJAAC5PQAAljEAAHMlAABQGQAA//DUAP/isQD/1I4A/8ZrAP+4SAD/qiUA/6oAANySAAC5egAAlmIAAHNKAABQMgAA///UAP//sQD//44A//9rAP//SAD//yUA//8AANzcAAC5uQAAlpYAAHNzAABQUAAA8P/UAOL/sQDU/44Axv9rALj/SACq/yUAqv8AAJLcAAB6uQAAYpYAAEpzAAAyUAAA4//UAMf/sQCr/44Aj/9rAHP/SABX/yUAVf8AAEncAAA9uQAAMZYAACVzAAAZUAAA1P/UALH/sQCO/44Aa/9rAEj/SAAl/yUAAP8AAADcAAAAuQAAAJYAAABzAAAAUAAA1P/jALH/xwCO/6sAa/+PAEj/cwAl/1cAAP9VAADcSQAAuT0AAJYxAABzJQAAUBkA1P/wALH/4gCO/9QAa//GAEj/uAAl/6oAAP+qAADckgAAuXoAAJZiAABzSgAAUDIA1P//ALH//wCO//8Aa///AEj//wAl//8AAP//AADc3AAAubkAAJaWAABzcwAAUFAA8vLyAObm5gDa2toAzs7OAMLCwgC2trYAqqqqAJ6engCSkpIAhoaGAHp6egBubm4AYmJiAFZWVgBKSkoAPj4+ADIyMgAmJiYAGhoaAA4ODgDw+/8ApKCgAICAgAAAAP8AAP8AAAD//wD/AAAA/wD/AP//AAD///8AAAAAAAAAAAAAJSglAAAAAAAAAAAAAAAAJSgoJQAAAAAAAAAAAAAAJSgoKCUAAAAAAAAAAAAAACgoKCgoJQAAAAAAACUlJSUoKPb2IyglAAAAAAAoKCgoKCMjI/YjKCUAAAAlKCgoKCgjKCj2KCgoJQAlKCgoKCgoIygo9igoKCglKCgoKCgo9vYoKPb2KCgoKCgoKCgoKPb2KCgj9igoJQAAAAAoKCgoIyMoIygoKAAAAAAAKCgoKCgjIyMoKCgAAAAAACgoKCgoIygoAAAAAAAAAAAoKCgoJQAoKAAAAAAAAAAAKCgoKAAAAAAAAAAAAAAAACgoKCgAAAAAAAAAAP+PAAD/DwAA/g8AAP4HAADgAwAA4AEAAMAAAACAAAAAAAAAAAAAAADwAQAA8AEAAPAPAADwTwAA8P8AAPD/AAA=" id="favicon" rel="shortcut icon" type="image/x-icon">
</head>
<body>
<header id="tiHeader">
  <div class="top">
    <ul>
      <li id="top_logo">
        <a href="https://www.ti.com">
          <img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAASIAAAAkCAYAAAAtkDcfAAAABGdBTUEAALGPC/xhBQAAAAFzUkdCAK7OHOkAAAAgY0hSTQAAeiYAAICEAAD6AAAAgOgAAHUwAADqYAAAOpgAABdwnLpRPAAAAAZiS0dEAP8A/wD/oL2nkwAAAAlwSFlzAAAASAAAAEgARslrPgAAE39JREFUeNrtnXmYVNWZxn/V1d3sLUsQFCRBQNSIONIRRsAgYAwadHBMTBzHmREQZzRqkplJ4sTETBadJMqok9G4jYkGnATCokGJRI2CBCxAxYSEtVFb9n1poLur8sf7He+p27eqF6pY9L7PU09Tt86999yzvN/7fec7lwSNIKU/pcA04PI8RZcDFwLbKhu7aIwYMWJ4KC3WhY3A2gM9gASQAd4F9sVEFSNGDB8lRb7+5cDv7DMb6HO0HzhGjBjHHoqiiFLBP88Futm/twObj/YDx4gR49hDMRVRK+B07/sqREYxYsSIkYWixYiANPAj4FEUI6oCDh3tB44RI8axh0ISUQdgFFI9SxD5JIDdiJSqgM5AZSpaiR0AFgP7WxjM7gv0R0Hx5qIEWAOsKGB7HE8oA4YAJwD13vEk6r/fExuRGEVEIYnoo8DPURxoJHAO8DjBYP400Bv4GQ2JqAStqI0C1rbg3kngG8C1iPQS3m9psskpEbp/xr7PAK4GDhawTY4XZNDq5n8gdzptbbIS+D6w8GhXMMYHG4UkooRdb5N9zgZa22/bgWrgb7xjYZSRTSDNwUeBC5CqqgZ2AbXebyd5Zbci9ZO2e1YAJwN/DfQD3ipgmxwvqAOeQqr2JwTj4sfIuMSIUVQUI0a0EhHCWd6xtcDe0LFCYrjd9wZEJPsQ0dQDV6I4lXvW7wEPIRVVArRBbt1NwCf5cBKRw3uIlMrsb/XRrlCMDwcKRUQZNPGTwJtAOzS5Hf6AlFAfK+vcoUJhNXA98HbEb++iSVVqdawG9nu/7wI2An9CMSaXfHm8IIlWKDPIrUwfxrUyjXwvJEqBcqvvwSLfK8bRRQKN0STq67pwgUIR0evAXXaD12joDv0B2AN81So0AbgkdI0SWk5OC1p4XhLFhYYQEOTVecrvASYjF2Y80JHsiZ+x55+CXMPewD8CH/Ge8R2kyLaGrj0M+IL9uxZ42NotF05BCaPDkGuZQQsCc1BMrg3wqxa2SxhtENG7+FECpWM8hNRnuF6T0MKEM1C/AF6x804DxgHnAV3tWVeihNd21i4vIlX2z8AZNJ1cn7L2vd76JorcMkANsAFtS0oBO+y3E4GJKF7mzk0gV/4RZLQceth9unpl5yNDfC3aVeBQa231xzx1Hwd8ynvWBFLnU4HPAwNonKwTKCzy38jYTrTzXJ9VAQ+i8eGjO/ImTiSYB9OtLW9EBqMxJKzv7gW22bH2wEUoPtwHiZEt1k6vAgOBJ5G3lB8pfUpTMDMFmRyfH6eCsqTgCymot992p2Co91t5CmZHXGN3CoalGq1RszESDbwMctU+G/q9DzDT6wBX7pD3qbPjdWiQlQOXAstC5y1CE82hDLiOQKlMR6RXFqpDqXWIf63v5XmmYWhlMm2ffdaZrt67geeBts1sq0vs/AyaPJfZ8QRwPvCGV7+DKLgdNmatEJnvsHKPockKcAVSr66N9xK40TX2/RGvX6q8srUECw/uU+f1TQa54G0RoW8LlU1HnL8feNnGiOuHCxHxuDLLgcHIaPkoRzHPDVbuOeBUu/911gf+vX6Up927oJVJv/x8FGdNIjJ5mfxjtN6O70OEBlCJxqQ7p9bGVZhYyqxvNlu5qdZnN+dpa9emtd6993v37gY8gcI0Gfu7x+qatvGxEfgrEMEMa3x8krTGyoVwXOUsAnWzGVjv/daZbLfNoQNiz/kpa8EjhDXALIINvVuQcltDEDxvDZyJ1M3lyPL+Gg32p5ACBHXoHu/atUgNlSOLfz2BtfBxOpoAGe+elwD3IQvnozsa1OciJXE3UqRpZKVHo7jYADQxChHzyiALNgNNDuyZvmbt9TCBtT6IVNkaq8OTVuYsq3dvNDnuRaqqxI5dam07GI2R85BCmgy8YO36WWShQWPqK2hA90IGYghSQrOBL6IFCNAknmz9UYpU1nVocWI48AAilRVoO9IiazuQklsU0SaH7DmXWN3nEaz4zkKTeKBXfhxSI6sjruVWmX3MReoKRIZzra4A66zt3dhIINV6LsEYfR7Z/l9YW2LP/iU0J+8nUF+1dv0/ofE6BS0wjbY6PGD1bo08n4/beVOQ4WgDfAKpqlHAb4B/Ba5BxuVea6s91j+Dgc/ZWBoCLHO76jt4AykXcq127SNbcpahSeuwlmw35BSy3TYf1wEvAS8eYTI6QLBkvQl4moau01yknG5ErlAVsmJ3WkO3QoPpRuCbdr3BwC3WBt8kmoRAA/kk1FlDEOmfiYzE9FDZocAg+/dkJPkdUlb3n1m9zqOwwXcnoR1htge+i4hmhleujsBK19ixMYhwaoA7kIJwWGzPOdraqdLqfgeaBG7C9AT+xe69AQ14R/zPAvfYuc+Rnfe0wPrOYRaadD9HCuY0q98Ku9cBr6z/7zD85/PTPuoIlMJBu8epiIx+GLpGa6Qgk3YvN8/C9/W/V6F+rgmVedaOX4vIfBuB6+z6rA3wLeuzKaFnOWh/9yFFmra6uRCBc5cdEaXQfHX3TiEiHECgpp8Hbg/1xwvAT4GvoznySAmydG2R9cn3CUtTh4Td/G40cSpoGKhuBdyGLOJtViYKPZF/ewpHD052RmEdmij+atITSBW5trgBWbgKK9sF+E/k1kShE7LG24H/QhYWAukfdn1O8Y5FGYc0ilNNQJa0GPg9gcrtivr+gkbOcarRBS7DqEMEMglZ7F8ity4cg8uFTchVXEfDWGN9RPllaDI69CxwGyXsOeZ6x64i2HvpMAip4flIRTYF+cbom4jAd4WOpwjUWCfgBwRuVBT2IsLKF6cM1+E5NMc7E3hQZTQMRYBWaL+OCClZghLWDiejuC0iopuRrOuBFIPfMB9DUu0raHLlC0p3RwrtWMP5SEruJ8hRwr5/l4BouqDkym+gjn6cgKhyXfdc5AIsRKrIYQRyH3xsJxgA/44G1KWI/P2YUBUipGJgPvBvBHsHeyM3ckCec1zZ1lbn25GM70U2oS5HruarNLT4jaHKzm9KPloFUgcOm5pwTnNRj/p+o30fCFzs/Z5A5NQWqbPGg7b5MRopr700XJl6DfgywcbzHkjJRzkeJYgochnPXEgjdfsuwcr0aBS7+zt7/k4E838vWpg4UIKY8iYUbzgc7LRr9EdbBdyNVoSOHes4ARiLgnd/a3/HI9nfP8c5q4FvE1ih4ajTlyIXKVe2doldvxy5NnVIyr5nv/dEKw4+FhJYtpMQIfwKdeivrZ5jUYcXCwmkWO4gGHADERn1ItpazyNwTU9DKvFpJO1nIjIfidR3sdEBhQFOtO/ryXYVC4UkIlWnikrRhHQran1RPGcJcleSTbxuVztvnH2uQC7rXeRWdgnU3rcRuLOno1hRXw4v7SOMd1CsDWRkrkLKZx4a34+iOdXb6vU+M72A/Mplh3HzauS3D/AadLNV6myK/+6jQqEXcgmmock2DQXkKsnfWbPtPOxZkyiGsT7POX2RalqJiAQUwH3FK3MZ2a7sKqSE/KBnORqAI1Aw8peInJqyEHE4+AkiPmd9RyA3zV/SdliAXNWN3rE2aDBejNyqWSi+dUaB63khWi36vtV3Nop11CKi+CLNt/5NxQGyl6iHEvTL5cjVnorcxKbuLBhg50y3zzSUBe/SK6Lgrv1Tso3jEBQOcSkghcAh4DuIgN3YSCKPaRDyoB6y3ycC5aWVvP/+oEUovjGVYMWgOViNpHQ4o3oPxcuoLgY2oADpPoLkxk5IHeUj01Kyc0dAy8jT0WCPwhhEIJMRYYMmx0xk5cpQxw0iICrs9xVodexCpDBOJIi9tEKk8ACymKspDg6huJbLv0lYvWsi2qIerRotQqtfw1BA9CMEMa/2dn4HlDtTqNfGnI8mXAnBhNyEFNxjZJNjoZFEJDwfqdt2SBW9gZTCOkSMzdnetBoZx1rvvO5ICTd2nTpEPN0QAZegFdo7kTdQKDJaac/5GfsMQO5gO4L9nv1Q8D5dCjL1RkaL0WD5QQtu/Bbydf2Yxh/RpOjbgusdLWwF/peGK1yvkn9ifB4tVy5AE7Mfmmh3IAuwM1S+ApEEiOhuQoM2jQZVDSKiDshyvhg6/8/Iyt+DrFl/FGv6FEGu0lmI7O4vYnvtRfGwrvY8JYiAEzSM8aSRG7IUkU5PpH4qrZ5OOV+AyOOZAtXxKUQ4bZD6Gm/1vQYR+oyWX7pRuHZ4EsXEyuzvl9HkvB/Ftjo245pvo/hOeGVtMQ1Xe6NQg0IJXdGqWAIZB5efVChsQwpsCjI4fZAL/0mUqtMRzYNJ71t4L2I1k/zuRBTqERF1tn+/a5/XEGtX2fd9zbzusYRnic4nAU2g2xFR3Yw62cVOPoPcgLCl+gRSOmlkOSajFYd7kOvlB54vRpM2gdSqvwpRg1Zb5qA4y2VkB8dPo/jYghYinEtZSna8I4lcMDfeMkgpr0Au5G1WbxdXaEVhXyu8BsUnnkaLJv9vdTkDqaKhofK+KmgsbuN+byzG8huC0Ed3pEZ2W10KhWk0feFpBxpnz3vPUUphFFEPsmOUtcjTmI9cyKvt3s497Bflaqwhd+DuoD1AOCK/A8Uu1iPrPdw+M5AS+HsUiMy3ilOPmH4ux/abHEuR2nFkUIGWOU9FVmopGhBP2O9J4FaC7F0IXJj2aCKMtXZzn7EoqdIRdz+ChMdbkcLKNUF2kq2e6jgyWIcmVzhlIIMClt9BqicX3iH7dSPFqvcB5LK6pfueNEwp8dXwSeTeCtWGIGu8sTG7BYU9XD5PK0QChYxNORKJ8kKiCKYa5bkVekPDCKTWcy2Y1KEx6tq5LoqI0mjJObyc+QYKaI9AbOZ31gZ7qNpKWF8JVfZx/2PHDsT+3SLutxepjQloso2nsD57c18tkshzTitEqpMIOnYSckl+i1YDQIR9FyIlkKv2bWQpQKQ1xtrtYUS+c7zPc8D/EUzqpN0jieIDP0TuUFR7urgSiNyXcuTwBlKEvqJOIELdbu1zA9ErqBUEWdu7KV4OFMg9nO19v4hgnx/IDXduz1CkXqNwPnKvtpA/38ZhFjLYIMXs9iQ2F/nGaDuUVHtVxDlRWIH6rJBxxLfQeH2E3AtVbikfYEkW04diRXchS98R5QJNCH5mOZoUdxJYi8YmfC+yM6pr0eS9D0ny/a4OBUaFV8cSon3x9l5jnYzIsNp7phLk4w5HQdZJiNUvQVK/BrlVvlWsQm7W43b/oSgt/6uIzHojVyHXANiBXJ0h9n04mhBONXwLqafZKBi+255tDMGkegGRfFNxAoHSStKQMFx+Vydyv6XgJWuTB8nOD1qAlpjvs/o9g2KINYhQryDIsZlOtHp2gU7s2lGJcqBVRD9HKJxAW4dchFEox63M+mU5IqF5yGW8Go2Hx6wfX0eGsy3aIzXR2ugBsl2i1lbXcD3W2XW/htx8f3W0VahsOI3BD/73RfNxp3csae04Ek3+z4X6rKOViYoBLURK+1Hyp32UhurYPke5tWhcX4Eyp59GbtlGAkM53q5VjeZJQ9jm1DLbhPoPKejvNq16v3dJwe9sw2pNCm5JQUUKEn5Zr/w13kbYjSm4NQUnhMsWGOcg39zfqLcQWTJnVQahCZtp4mexXfcW5Eq6eMf1ZMd1uiEVVOudux8pnq32PYXIJYrET0UW1L/3qyh58TU08N0mRbf50G3q3IeW8HPlPYVRgojypdD9XkEEWI7U6pt2vBqRaa5tPwlEOhutrbG6rLNr7CJ6M+sONKm7h65XigzAi17d9qIJHS5bQRB/cWVXoRhUeLPnlQQbazMoLPElFOvshkhzs1e/OqSU3ObPPWjy+ga2M4rVuY3O/0N2gu85KF46yTvWAWUZ13h1WYa8j3IU3F1K08foHEQSQ9F4zdhzTCD/Ruh/Qp7QRRG/dUGxTn8z8RK0OBKVKX83yodb5bWfv0G2zp5pLJBo0RsRPeK4BlmLMmvEN+3GOwkmIPZ3MBpMLpYwB8gUcT9ZAlnYs2n4HuZVBNL8UjRJmpLQVYKs4nY0SEoIXrGwF8XEnEs7EFknX5YmvHNcrGA1UgfhmMgwazMfSYL9UKuQ1RyF9v5UIKJbS5Cl3dTFAbed5GMRbfU2UlVjUM6L25O3C8XCcsVGnBv7MlrKbY2Wr5eg7R4jUeyrLZrQf0ZEuJSGCaBtkdQ/mezXZNQjcnrdK9sLKUX3jibXb9usvv4rMBLItRqHcnBKkYv1IIH1/rj1xZlIFbtXH6+xdl5M9upgH0R6Se/+8whiQeXWLnMRIYHiVOMi6vyOtf2n7bmaMkYTyGAttj7t7fXZXqQ2c/23XmVoTqdo6Br3t3qUheq4Fam88JaSc5BaXIfGaCUKUaRRSGKx9fd7rtItgpFRFzSJhjTxtM1Ikj0DR3RT6wcdYYI7XnAs1dsZjHQjZRIFqO/x9vK9QsGRc4M2Ptxs520oP6IpTJ1GvmBMQoWHc3OOt8F9LNXbva+osTKFqO+x8LxHA/XkaOMWE1Eo76gpr5p4HQX8YhKKESNGFgqx/6uahq9riMJcirPDOUaMGMc5DouIPGUzlfzvjc6gYGSshmLEiNEAhdoRvxm91iGX4mlxUDxGjBgffBw2EXkK57coKSzX61BPhqLmDMWIEeM4RUEUkZFRBu2vmohyEMIrA0OITnyKESPGhxwFe1mZkVEaJfVdiTIrV6Kkuh0o6au5/71NjBgxPgT4C61ogjdM12DoAAAAJXRFWHRkYXRlOmNyZWF0ZQAyMDE3LTA5LTA3VDEyOjU5OjM4LTA1OjAwEOyNOQAAACV0RVh0ZGF0ZTptb2RpZnkAMjAxNy0wOC0wOVQxMTowOTozOC0wNTowMFpMg/oAAAAZdEVYdFNvZnR3YXJlAEFkb2JlIEltYWdlUmVhZHlxyWU8AAAAAElFTkSuQmCC" />
        </a>
      </li>
    </ul>
  </div>
  <div class="nav">
  </div>
</header>
<div id="content">
  <h1>Readme</h1>
<h2 id="example-summary">Example Summary</h2>
<p>Empty project using DriverLib. This example shows a basic empty project using DriverLib with just main file and SysConfig initialization.</p>
<h2 id="peripherals-pin-assignments">Peripherals &amp; Pin Assignments</h2>
<table>
<thead>
<tr class="header">
<th>Peripheral</th>
<th>Pin</th>
<th>Function</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>SYSCTL</td>
<td></td>
<td></td>
</tr>
<tr class="even">
<td>DEBUGSS</td>
<td>PA20</td>
<td>Debug Clock</td>
</tr>
<tr class="odd">
<td>DEBUGSS</td>
<td>PA19</td>
<td>Debug Data In Out</td>
</tr>
</tbody>
</table>
<h2 id="boosterpacks-board-resources-jumper-settings">BoosterPacks, Board Resources &amp; Jumper Settings</h2>
<p>Visit <a href="https://www.ti.com/tool/LP-MSPM0G3507">LP_MSPM0G3507</a> for LaunchPad information, including user guide and hardware files.</p>
<table>
<thead>
<tr class="header">
<th>Pin</th>
<th>Peripheral</th>
<th>Function</th>
<th>LaunchPad Pin</th>
<th>LaunchPad Settings</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>PA20</td>
<td>DEBUGSS</td>
<td>SWCLK</td>
<td>N/A</td>
<td><ul><li>PA20 is used by SWD during debugging<br><ul><li><code>J101 15:16 ON</code> Connect to XDS-110 SWCLK while debugging<br><li><code>J101 15:16 OFF</code> Disconnect from XDS-110 SWCLK if using pin in application</ul></ul></td>
</tr>
<tr class="even">
<td>PA19</td>
<td>DEBUGSS</td>
<td>SWDIO</td>
<td>N/A</td>
<td><ul><li>PA19 is used by SWD during debugging<br><ul><li><code>J101 13:14 ON</code> Connect to XDS-110 SWDIO while debugging<br><li><code>J101 13:14 OFF</code> Disconnect from XDS-110 SWDIO if using pin in application</ul></ul></td>
</tr>
</tbody>
</table>
<h3 id="device-migration-recommendations">Device Migration Recommendations</h3>
<p>This project was developed for a superset device included in the LP_MSPM0G3507 LaunchPad. Please visit the <a href="https://software-dl.ti.com/msp430/esd/MSPM0-SDK/latest/docs/english/tools/ccs_ide_guide/doc_guide/doc_guide-srcs/ccs_ide_guide.html#sysconfig-project-migration">CCS User’s Guide</a> for information about migrating to other MSPM0 devices.</p>
<h3 id="low-power-recommendations">Low-Power Recommendations</h3>
<p>TI recommends to terminate unused pins by setting the corresponding functions to GPIO and configure the pins to output low or input with internal pullup/pulldown resistor.</p>
<p>SysConfig allows developers to easily configure unused pins by selecting <strong>Board</strong>→<strong>Configure Unused Pins</strong>.</p>
<p>For more information about jumper configuration to achieve low-power using the MSPM0 LaunchPad, please visit the <a href="https://www.ti.com/lit/slau873">LP-MSPM0G3507 User’s Guide</a>.</p>
<h2 id="example-usage">Example Usage</h2>
<p>Compile, load and run the example.</p>
<!-- Close div from before_body_template.html -->
</div>
<footer id="tiFooter">
  <p>TI is a global semiconductor design and manufacturing company. Innovate
  with 100,000+ analog ICs and embedded processors, along with software, tools
  and the industry‘s largest sales/support staff.</p>
  <p>
    <a href="https://www.ti.com/corp/docs/legal/copyright.shtml">© Copyright 1995-2024</a>, Texas Instruments Incorporated. All rights reserved. <br>
    <a href="https://www.ti.com/corp/docs/legal/trademark/trademrk.htm">Trademarks</a> | <a href="https://www.ti.com/corp/docs/legal/privacy.shtml">Privacy policy</a> | <a href="https://www.ti.com/corp/docs/legal/termsofuse.shtml">Terms of use</a> | <a href="https://www.ti.com/lsds/ti/legal/termsofsale.page">Terms of sale</a>
  </p>
</footer>
</body>
</html>

================
File: README.md
================
# 2021年F题 智能送药小车
  完成主车下位机代码和从车主控流程控制
# 技术亮点
   模块配置文件
   
   任务动态规划，实现任务的动态调整

================
File: Servo/Servo_config.c
================
#include "Servo_config.h"

#define Servo_TIM_CounterCycleTime    1000000.0/Servo_INST_CLK_FREQ    //us
#define Servo_kind servo_180
#define bias 0.0f

SERVO_CONFIG servo_config = {
    .pwm_port = Servo_INST,
    .CHANNEL = GPIO_Servo_C0_IDX,
    .CounterCycleTime = Servo_TIM_CounterCycleTime,
    .kind = Servo_kind,
    .delta_bias = bias
};

================
File: Servo/Servo_config.h
================
#ifndef SERVO_CONFIG_H
#define SERVO_CONFIG_H

#include "pwm.h"
#include "ti_msp_dl_config.h"

typedef enum
{
  servo_270,
	servo_180
}Servo_Category;

typedef struct
{
   GPTIMER_Regs *pwm_port;
   DL_TIMER_CC_INDEX  CHANNEL;
  float CounterCycleTime; //us

  Servo_Category kind;
  
  float delta_bias; //us, the bias of the servo angle
}SERVO_CONFIG;

extern SERVO_CONFIG servo_config;

 

#endif // SERVO_CONFIG_H

================
File: Servo/Servo_pwm.c
================
#include "Servo_pwm.h"

void Servo_pwminit(SERVO_CONFIG servo_config)
{
  pwm_init(servo_config.pwm_port);
}

float  Servo_Comparevaluecal(SERVO_CONFIG servo_config, float angle)
{
	 float range;
    if(servo_config.kind == servo_270)
		{
		  range = 270.0;
		}
		else if(servo_config.kind == servo_180)
		{
		  range = 180.0;
		}
	
	float k = 2000.0/range;
	float high_leveltime = k * (angle - servo_config.delta_bias) + 500.0;
	float comparevalue = high_leveltime/servo_config.CounterCycleTime;
	return comparevalue;
}


void Servo_setcompare(SERVO_CONFIG servo_config, uint16_t pwm)
{
  pwm_set(servo_config.pwm_port, servo_config.CHANNEL, pwm);
}

================
File: Servo/Servo_pwm.h
================
#ifndef _SERVO_PWM
#define _SERVO_PWM

#include "Servo_config.h"

void Servo_pwminit(SERVO_CONFIG servo_config);

void Servo_setcompare(SERVO_CONFIG servo_config, uint16_t pwm);

float  Servo_Comparevaluecal(SERVO_CONFIG servo_config, float angle);


#endif

================
File: Servo/Servo.c
================
#include "Servo.h"

void Servo_create(SERVO *servo, SERVO_CONFIG config)
{
   servo->servo_config = config;
}

void Servo_init(SERVO *servo)
{
  Servo_pwminit(servo->servo_config);
  servo->target_angle = 0.0f; // Initialize angle to 0
}

void Servo_setangle(SERVO *servo,float angle)
{
   servo->target_angle = angle;
   int pwm = (int)Servo_Comparevaluecal(servo->servo_config,angle);
   Servo_setcompare(servo->servo_config,pwm);
}

================
File: Servo/Servo.h
================
#ifndef _SERVO_H
#define _SERVO_H


#include "Servo_pwm.h"

typedef struct
{
   float target_angle;
   SERVO_CONFIG servo_config; // Servo configuration 
   uint16_t limit;
}SERVO;

void Servo_create(SERVO *servo, SERVO_CONFIG config);
void Servo_init(SERVO *servo);
void Servo_setangle(SERVO *servo, float angle);

#endif

================
File: System/gpio_encoder.c
================
#include "gpio_encoder.h"

//定义编码器数量
#define encoder_num 2
ENCODER_PORT encoder[encoder_num];

void encoder_init(int encoder_id,ENCODER_PORT encoder_port){
      encoder[encoder_id] = encoder_port;
}

void encoder_start(int encoder_id){
	 NVIC_EnableIRQ(encoder[encoder_id].IRQn);
}

int32_t encoder_getcounter(int encoder_id){
    int32_t counter = 0;
    counter = encoder[encoder_id].encoder_counter;
    encoder[encoder_id].encoder_counter = 0;
    return counter;
}

void GROUP1_IRQHandler(void){

  for(int i = 0; i < encoder_num; i++){
uint32_t encoder_itstatus = DL_GPIO_getEnabledInterruptStatus(encoder[i].gpio_port, encoder[i].EncoderA_PIN| encoder[i].EncoderB_PIN| encoder[i].EncoderC_PIN| encoder[i].EncoderD_PIN);

   if(encoder_itstatus & encoder[i].EncoderA_PIN)
   {
     if(DL_GPIO_readPins(encoder[i].gpio_port,encoder[i].EncoderC_PIN))
     {
         encoder[i].encoder_counter++;
     }
     else
     {
         encoder[i].encoder_counter--;
     }
     DL_GPIO_clearInterruptStatus(encoder[i].gpio_port,encoder[i].EncoderA_PIN);
   }


   else if(encoder_itstatus & encoder[i].EncoderB_PIN)
   {
     if(DL_GPIO_readPins(encoder[i].gpio_port,encoder[i].EncoderC_PIN))
     {
         encoder[i].encoder_counter--;
     }
     else
     {
         encoder[i].encoder_counter++;
     }
     DL_GPIO_clearInterruptStatus(encoder[i].gpio_port,encoder[i].EncoderB_PIN);
   }


   else if(encoder_itstatus & encoder[i].EncoderC_PIN)
   {
     if(DL_GPIO_readPins(encoder[i].gpio_port,encoder[i].EncoderA_PIN))
     {
        encoder[i].encoder_counter--;
     }
     else
     {
        encoder[i].encoder_counter++;
     }
     DL_GPIO_clearInterruptStatus(encoder[i].gpio_port,encoder[i].EncoderC_PIN);
   }


   else if(encoder_itstatus & encoder[i].EncoderD_PIN)
   {
     if(DL_GPIO_readPins(encoder[i].gpio_port,encoder[i].EncoderA_PIN))
     {
        encoder[i].encoder_counter++;
     }
     else
     {
        encoder[i].encoder_counter--;
     }
     DL_GPIO_clearInterruptStatus(encoder[i].gpio_port,encoder[i].EncoderD_PIN);
   }

  
   }
}

================
File: System/gpio_encoder.h
================
#ifndef GPIO_ENCODER_H
#define GPIO_ENCODER_H

#include <ti/driverlib/dl_gpio.h>

typedef struct
{
//中断线
    IRQn_Type IRQn;

//GPIO端口
    GPIO_Regs *gpio_port;

//编码器引脚
    uint32_t EncoderA_PIN;
    uint32_t EncoderB_PIN;
    uint32_t EncoderC_PIN;
    uint32_t EncoderD_PIN;

//编码器计数器
    int32_t encoder_counter;

//编码器ID
    int encoder_id;

}ENCODER_PORT;

void encoder_init(int encoder_id, ENCODER_PORT encoder_port);
void encoder_start(int encoder_id);
int32_t encoder_getcounter(int encoder_id);

#endif

================
File: System/my_delay.c
================
#include "my_delay.h"

//实现微秒级延时
void delay_us(uint32_t us)
{
    while(us--)
        delay_cycles(CPUCLK_FREQ/1000000);
}

//实现毫秒级延时
void delay_ms(uint32_t ms)
{
    while(ms--)
	    delay_cycles(CPUCLK_FREQ/1000);
}

================
File: System/my_delay.h
================
#ifndef _MY_DELAY_H
#define _MY_DELAY_H

#include "ti_msp_dl_config.h"

void delay_us(uint32_t us);
void delay_ms(uint32_t ms);

#endif

================
File: System/my_gpio.c
================
#include "my_gpio.h"

int gpio_readpin(GPIO_Regs * gpio,uint32_t pins)
{
	if(DL_GPIO_readPins(gpio,pins))	 
	{
	  return 1;
	}
	else
	{
		return 0;
	} 
	
}

void gpio_setpin(GPIO_Regs * gpio,uint32_t pins)
{
    DL_GPIO_setPins(gpio,pins);
}

void gpio_resetpin(GPIO_Regs * gpio,uint32_t pins)
{
    DL_GPIO_clearPins(gpio,pins);
}

================
File: System/my_gpio.h
================
#ifndef _MY_GPIO_H
#define _MY_GPIO_H

#include <ti/driverlib/dl_gpio.h>

int gpio_readpin(GPIO_Regs * gpio,uint32_t pins);
void gpio_setpin(GPIO_Regs * gpio,uint32_t pins);
void gpio_resetpin(GPIO_Regs * gpio,uint32_t pins);

#endif

================
File: System/pwm.c
================
#include "pwm.h"

void pwm_init(GPTIMER_Regs *gptimer)
{
    DL_Timer_startCounter (gptimer);
}

// DL_TIMER_CC_INDEX: D  L_TIMER_CC_0_INDEX
void pwm_set(GPTIMER_Regs * tim, DL_TIMER_CC_INDEX TIM_CHANNEL, uint32_t pwm)
{
    DL_Timer_setCaptureCompareValue(tim, pwm, TIM_CHANNEL);
}

================
File: System/pwm.h
================
#ifndef _PWM_H
#define _PWM_H

#include <ti/driverlib/dl_timerg.h>

void pwm_init(GPTIMER_Regs *gptimer);
void pwm_set(GPTIMER_Regs * tim, DL_TIMER_CC_INDEX TIM_CHANNEL, uint32_t pwm);


#endif

================
File: System/serial.c
================
#include "serial.h"

// int fputc(int ch, FILE *f) {
// HAL_UART_Transmit(&Debugger_UART, (uint8_t *)&ch, 1, 0xFFFF);
// return ch;
// }

void usart_printf(UART_Regs *uart,char *fmt, ...){
   uint16_t i, j;
   va_list ap;
   char TX_BUF[200];
   va_start(ap, fmt);
   vsprintf((char *)TX_BUF, fmt, ap);
   va_end(ap);
   i = strlen((const char *)TX_BUF); // 此次发送数据的长度
   for (j = 0; j < i; j++)                  // 循环发送数据
   {
      DL_UART_transmitDataBlocking(uart, TX_BUF[j]);
   }
}

void usart_rx_it_start(IRQn_Type IRQn)
{
    NVIC_ClearPendingIRQ(IRQn);
    NVIC_EnableIRQ(IRQn);
}

void usart_rx_it_stop(IRQn_Type IRQn)
{
     NVIC_DisableIRQ(IRQn);
}

void usart_transmit(UART_Regs *uart,unsigned char *p_data, unsigned int uiSize)
{	
    while(*p_data != '\0')  DL_UART_transmitDataBlocking(uart, *p_data++);
}

char usart_receivebyte(UART_Regs *uart)
{
     return DL_UART_Main_receiveData(uart);
}

================
File: System/serial.h
================
#ifndef _SERIAL_H
#define _SERIAL_H

#include <ti/driverlib/dl_uart_main.h>
#include "string.h"
#include "stdarg.h"
#include "stdio.h"
#include "stdint.h"


// 在某个公共头文件里（或 Debugger_printf 前面）加上：
#define Debugger_UART Debugger_UART_INST
#define Debugger_printf(fmt, ...)  usart_printf(Debugger_UART, fmt, ##__VA_ARGS__)

void usart_printf(UART_Regs *uart,char *fmt, ...);
void usart_rx_it_start(IRQn_Type IRQn);
void usart_rx_it_stop(IRQn_Type IRQn);
void usart_transmit(UART_Regs *uart,unsigned char *p_data, unsigned int uiSize);
char usart_receivebyte(UART_Regs *uart);

#endif

================
File: System/tim_it.c
================
#include "tim_it.h"

//使能中断
void tim_it_start(GPTIMER_Regs *gptimer,IRQn_Type IRQn)
{
    NVIC_EnableIRQ(IRQn);

    DL_TimerG_startCounter(gptimer);
}

================
File: System/tim_it.h
================
#ifndef _TIM_IT_H
#define _TIM_IT_H

#include <ti/driverlib/dl_timerg.h>

void tim_it_start(GPTIMER_Regs *gptimer,IRQn_Type IRQn);


#endif

================
File: targetConfigs/MSPM0G3507.ccxml
================
<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<configurations XML_version="1.2" id="configurations_0">
    <configuration XML_version="1.2" id="configuration_0">
        <instance XML_version="1.2" desc="Texas Instruments XDS110 USB Debug Probe" href="connections/TIXDS110_Connection.xml" id="Texas Instruments XDS110 USB Debug Probe" xml="TIXDS110_Connection.xml" xmlpath="connections"/>
        <connection XML_version="1.2" id="Texas Instruments XDS110 USB Debug Probe">
            <instance XML_version="1.2" href="drivers/tixds510cs_dap.xml" id="drivers" xml="tixds510cs_dap.xml" xmlpath="drivers"/>
            <instance XML_version="1.2" href="drivers/tixds510cortexM0.xml" id="drivers" xml="tixds510cortexM0.xml" xmlpath="drivers"/>
            <instance XML_version="1.2" href="drivers/tixds510sec_ap.xml" id="drivers" xml="tixds510sec_ap.xml" xmlpath="drivers"/>
            <property Type="choicelist" Value="1" id="The JTAG TCLK Frequency (MHz)">
                <choice Name="Fixed with user specified value" value="SPECIFIC">
                    <property Type="stringfield" Value="1MHz" id="-- Enter a value from 100.0kHz to 2.5MHz"/>
                </choice>
            </property>
            <property Type="choicelist" Value="2" id="SWD Mode Settings">
                <choice Name="SWD Mode - Aux COM port is target TDO pin" value="nothing"/>
            </property>
            <platform XML_version="1.2" id="platform_0">
                <instance XML_version="1.2" desc="MSPM0G3507" href="devices/MSPM0G3507.xml" id="MSPM0G3507" xml="MSPM0G3507.xml" xmlpath="devices"/>
            </platform>
        </connection>
    </configuration>
</configurations>

================
File: targetConfigs/readme.txt
================
The 'targetConfigs' folder contains target-configuration (.ccxml) files, automatically generated based
on the device and connection settings specified in your project on the Properties > General page.

Please note that in automatic target-configuration management, changes to the project's device and/or
connection settings will either modify an existing or generate a new target-configuration file. Thus,
if you manually edit these auto-generated files, you may need to re-apply your changes. Alternatively,
you may create your own target-configuration file for this project and manage it manually. You can
always switch back to automatic target-configuration management by checking the "Manage the project's
target-configuration automatically" checkbox on the project's Properties > General page.
